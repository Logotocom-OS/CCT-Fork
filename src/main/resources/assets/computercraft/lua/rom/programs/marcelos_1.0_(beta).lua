local function SelectColor(acolor)
if term.isColor and term.isColor() then
	term.setTextColor(acolor or colors.white)
	end
end

local function PrintMessage(...)
local mx,my = term.getSize()
local x,y = 0,0
term.clear()

local args = {...}
local i = 0
for i = 1,#args do
	term.setCursorPos(4, 2+i) 
	term.write(args[i]) 
	end

-- border
SelectColor(colors.cyan)
local astr = string.rep("X",mx)
local bstr = ""

term.setCursorPos(1, 1) 
term.write(astr) 
term.setCursorPos(1, my) 
term.write(astr) 

for y = 1,my do 
	term.setCursorPos(1, y)  
	term.write("X") 
	term.setCursorPos(mx, y)  
	term.write("X") 
	end
	
SelectColor(colors.white)
return #args+3
end

local free = 1+ PrintMessage("marcelOS installer","------------------","","","Thank you for using marcelOS","This Program will guide you through","the installation.")

SelectColor(colors.red)
term.setCursorPos(4, 7)
term.write("Thank you for using marcelOS") 
sleep(3)
term.setCursorPos(4, free)
SelectColor(colors.green)
term.write("press ENTER...")
SelectColor(colors.white)
read() 

free = 1+ PrintMessage("Page 1 of 3","","","This setup will copy all marcelOS ","files to your computer, then the PC will ","reboot and you can use your new OS :)","Keep in mind, that this installer ","MAY overwrite files!")
sleep(3)
term.setCursorPos(4, free)
SelectColor(colors.green)
print("press ENTER...")
SelectColor(colors.white)
read() 

free = 1+ PrintMessage("Page 2 of 3","","","all marcelOS files are licenced ","under the modified GPL 2.0,","read http://www.gnu.org/licenses/gpl-2.0.html!")
SelectColor(colors.red)
term.setCursorPos(4, 6)
term.write("all marcelOS files are licenced ")
term.setCursorPos(4, 7)
term.write("under the modified GPL 2.0,")
sleep(3)
term.setCursorPos(4, free)
SelectColor(colors.green)
term.write("press ENTER...")
SelectColor(colors.white)
read() 


free = 1+ PrintMessage("Page 3 of 3","","","for additional information, visite my website:","http://marcelmaertens.funpic.de")
sleep(3)
term.setCursorPos(4, free)
SelectColor(colors.green)
term.write("press ENTER to start Setup...")
SelectColor(colors.white)
read()   local  dest  =  "/"  local  myData  =  "<~t<true>folder<0||name<0|/>path<0|/>sub<0||file<0||name<0|COPYING.GPL.txt>path<0|/COPYING.GPL.txt>data<0|~<10>                    GNU GENERAL PUBLIC LICENSE~<10>                       Version 2, June 1991~<10|10> Copyright (C) 1989, 1991 Free Software Foundation, Inc.~<10>                          675 Mass Ave, Cambridge, MA 02139, USA~<10> Everyone is permitted to copy and distribute verbatim copies~<10> of this license document, but changing it is not allowed.~<10|10>                            Preamble~<10|10>  The licenses for most software are designed to take away your~<10>freedom to share and change it.  By contrast, the GNU General Public~<10>License is intended to guarantee your freedom to share and change free~<10>software--to make sure the software is free for all its users.  This~<10>General Public License applies to most of the Free Software~<10>Foundation's software and to any other program whose authors commit to~<10>using it.  (Some other Free Software Foundation software is covered by~<10>the GNU Library General Public License instead.)  You can apply it to~<10>your programs, too.~<10|10>  When we speak of free software, we are referring to freedom, not~<10>price.  Our General Public Licenses are designed to make sure that you~<10>have the freedom to distribute copies of free software (and charge for~<10>this service if you wish), that you receive source code or can get it~<10>if you want it, that you can change the software or use pieces of it~<10>in new free programs; and that you know you can do these things.~<10|10>  To protect your rights, we need to make restrictions that forbid~<10>anyone to deny you these rights or to ask you to surrender the rights.~<10>These restrictions translate to certain responsibilities for you if you~<10>distribute copies of the software, or if you modify it.~<10|10>  For example, if you distribute copies of such a program, whether~<10>gratis or for a fee, you must give the recipients all the rights that~<10>you have.  You must make sure that they, too, receive or can get the~<10>source code.  And you must show them these terms so they know their~<10>rights.~<10|10>  We protect your rights with two steps: (1) copyright the software, and~<10>(2) offer you this license which gives you legal permission to copy,~<10>distribute and/or modify the software.~<10|10>  Also, for each author's protection and ours, we want to make certain~<10>that everyone understands that there is no warranty for this free~<10>software.  If the software is modified by someone else and passed on, we~<10>want its recipients to know that what they have is not the original, so~<10>that any problems introduced by others will not reflect on the original~<10>authors' reputations.~<10|10>  Finally, any free program is threatened constantly by software~<10>patents.  We wish to avoid the danger that redistributors of a free~<10>program will individually obtain patent licenses, in effect making the~<10>program proprietary.  To prevent this, we have made it clear that any~<10>patent must be licensed for everyone's free use or not licensed at all.~<10|10>  The precise terms and conditions for copying, distribution and~<10>modification follow.~<10>~<10>                    GNU GENERAL PUBLIC LICENSE~<10>   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION~<10|10>  0. This License applies to any program or other work which contains~<10>a notice placed by the copyright holder saying it may be distributed~<10>under the terms of this General Public License.  The ~<34>Program~<34>, below,~<10>refers to any such program or work, and a ~<34>work based on the Program~<34|10>means either the Program or any derivative work under copyright law:~<10>that is to say, a work containing the Program or a portion of it,~<10>either verbatim or with modifications and/or translated into another~<10>language.  (Hereinafter, translation is included without limitation in~<10>the term ~<34>modification~<34>.)  Each licensee is addressed as ~<34>you~<34>.~<10|10>Activities other than copying, distribution and modification are not~<10>covered by this License; they are outside its scope.  The act of~<10>running the Program is not restricted, and the output from the Program~<10>is covered only if its contents constitute a work based on the~<10>Program (independent of having been made by running the Program).~<10>Whether that is true depends on what the Program does.~<10|10>  1. You may copy and distribute verbatim copies of the Program's~<10>source code as you receive it, in any medium, provided that you~<10>conspicuously and appropriately publish on each copy an appropriate~<10>copyright notice and disclaimer of warranty; keep intact all the~<10>notices that refer to this License and to the absence of any warranty;~<10>and give any other recipients of the Program a copy of this License~<10>along with the Program.~<10|10>You may charge a fee for the physical act of transferring a copy, and~<10>you may at your option offer warranty protection in exchange for a fee.~<10|10>  2. You may modify your copy or copies of the Program or any portion~<10>of it, thus forming a work based on the Program, and copy and~<10>distribute such modifications or work under the terms of Section 1~<10>above, provided that you also meet all of these conditions:~<10|10>    a) You must cause the modified files to carry prominent notices~<10>    stating that you changed the files and the date of any change.~<10|10>    b) You must cause any work that you distribute or publish, that in~<10>    whole or in part contains or is derived from the Program or any~<10>    part thereof, to be licensed as a whole at no charge to all third~<10>    parties under the terms of this License.~<10|10>    c) If the modified program normally reads commands interactively~<10>    when run, you must cause it, when started running for such~<10>    interactive use in the most ordinary way, to print or display an~<10>    announcement including an appropriate copyright notice and a~<10>    notice that there is no warranty (or else, saying that you provide~<10>    a warranty) and that users may redistribute the program under~<10>    these conditions, and telling the user how to view a copy of this~<10>    License.  (Exception: if the Program itself is interactive but~<10>    does not normally print such an announcement, your work based on~<10>    the Program is not required to print an announcement.)~<10>~<10>These requirements apply to the modified work as a whole.  If~<10>identifiable sections of that work are not derived from the Program,~<10>and can be reasonably considered independent and separate works in~<10>themselves, then this License, and its terms, do not apply to those~<10>sections when you distribute them as separate works.  But when you~<10>distribute the same sections as part of a whole which is a work based~<10>on the Program, the distribution of the whole must be on the terms of~<10>this License, whose permissions for other licensees extend to the~<10>entire whole, and thus to each and every part regardless of who wrote it.~<10|10>Thus, it is not the intent of this section to claim rights or contest~<10>your rights to work written entirely by you; rather, the intent is to~<10>exercise the right to control the distribution of derivative or~<10>collective works based on the Program.~<10|10>In addition, mere aggregation of another work not based on the Program~<10>with the Program (or with a work based on the Program) on a volume of~<10>a storage or distribution medium does not bring the other work under~<10>the scope of this License.~<10|10>  3. You may copy and distribute the Program (or a work based on it,~<10>under Section 2) in object code or executable form under the terms of~<10>Sections 1 and 2 above provided that you also do one of the following:~<10|10>    a) Accompany it with the complete corresponding machine-readable~<10>    source code, which must be distributed under the terms of Sections~<10>    1 and 2 above on a medium customarily used for software interchange; or,~<10|10>    b) Accompany it with a written offer, valid for at least three~<10>    years, to give any third party, for a charge no more than your~<10>    cost of physically performing source distribution, a complete~<10>    machine-readable copy of the corresponding source code, to be~<10>    distributed under the terms of Sections 1 and 2 above on a medium~<10>    customarily used for software interchange; or,~<10|10>    c) Accompany it with the information you received as to the offer~<10>    to distribute corresponding source code.  (This alternative is~<10>    allowed only for noncommercial distribution and only if you~<10>    received the program in object code or executable form with such~<10>    an offer, in accord with Subsection b above.)~<10|10>The source code for a work means the preferred form of the work for~<10>making modifications to it.  For an executable work, complete source~<10>code means all the source code for all modules it contains, plus any~<10>associated interface definition files, plus the scripts used to~<10>control compilation and installation of the executable.  However, as a~<10>special exception, the source code distributed need not include~<10>anything that is normally distributed (in either source or binary~<10>form) with the major components (compiler, kernel, and so on) of the~<10>operating system on which the executable runs, unless that component~<10>itself accompanies the executable.~<10|10>If distribution of executable or object code is made by offering~<10>access to copy from a designated place, then offering equivalent~<10>access to copy the source code from the same place counts as~<10>distribution of the source code, even though third parties are not~<10>compelled to copy the source along with the object code.~<10>~<10>  4. You may not copy, modify, sublicense, or distribute the Program~<10>except as expressly provided under this License.  Any attempt~<10>otherwise to copy, modify, sublicense or distribute the Program is~<10>void, and will automatically terminate your rights under this License.~<10>However, parties who have received copies, or rights, from you under~<10>this License will not have their licenses terminated so long as such~<10>parties remain in full compliance.~<10|10>  5. You are not required to accept this License, since you have not~<10>signed it.  However, nothing else grants you permission to modify or~<10>distribute the Program or its derivative works.  These actions are~<10>prohibited by law if you do not accept this License.  Therefore, by~<10>modifying or distributing the Program (or any work based on the~<10>Program), you indicate your acceptance of this License to do so, and~<10>all its terms and conditions for copying, distributing or modifying~<10>the Program or works based on it.~<10|10>  6. Each time you redistribute the Program (or any work based on the~<10>Program), the recipient automatically receives a license from the~<10>original licensor to copy, distribute or modify the Program subject to~<10>these terms and conditions.  You may not impose any further~<10>restrictions on the recipients' exercise of the rights granted herein.~<10>You are not responsible for enforcing compliance by third parties to~<10>this License.~<10|10>  7. If, as a consequence of a court judgment or allegation of patent~<10>infringement or for any other reason (not limited to patent issues),~<10>conditions are imposed on you (whether by court order, agreement or~<10>otherwise) that contradict the conditions of this License, they do not~<10>excuse you from the conditions of this License.  If you cannot~<10>distribute so as to satisfy simultaneously your obligations under this~<10>License and any other pertinent obligations, then as a consequence you~<10>may not distribute the Program at all.  For example, if a patent~<10>license would not permit royalty-free redistribution of the Program by~<10>all those who receive copies directly or indirectly through you, then~<10>the only way you could satisfy both it and this License would be to~<10>refrain entirely from distribution of the Program.~<10|10>If any portion of this section is held invalid or unenforceable under~<10>any particular circumstance, the balance of the section is intended to~<10>apply and the section as a whole is intended to apply in other~<10>circumstances.~<10|10>It is not the purpose of this section to induce you to infringe any~<10>patents or other property right claims or to contest validity of any~<10>such claims; this section has the sole purpose of protecting the~<10>integrity of the free software distribution system, which is~<10>implemented by public license practices.  Many people have made~<10>generous contributions to the wide range of software distributed~<10>through that system in reliance on consistent application of that~<10>system; it is up to the author/donor to decide if he or she is willing~<10>to distribute software through any other system and a licensee cannot~<10>impose that choice.~<10|10>This section is intended to make thoroughly clear what is believed to~<10>be a consequence of the rest of this License.~<10>~<10>  8. If the distribution and/or use of the Program is restricted in~<10>certain countries either by patents or by copyrighted interfaces, the~<10>original copyright holder who places the Program under this License~<10>may add an explicit geographical distribution limitation excluding~<10>those countries, so that distribution is permitted only in or among~<10>countries not thus excluded.  In such case, this License incorporates~<10>the limitation as if written in the body of this License.~<10|10>  9. The Free Software Foundation may publish revised and/or new versions~<10>of the General Public License from time to time.  Such new versions will~<10>be similar in spirit to the present version, but may differ in detail to~<10>address new problems or concerns.~<10|10>Each version is given a distinguishing version number.  If the Program~<10>specifies a version number of this License which applies to it and ~<34>any~<10>later version~<34>, you have the option of following the terms and conditions~<10>either of that version or of any later version published by the Free~<10>Software Foundation.  If the Program does not specify a version number of~<10>this License, you may choose any version ever published by the Free Software~<10>Foundation.~<10|10>  10. If you wish to incorporate parts of the Program into other free~<10>programs whose distribution conditions are different, write to the author~<10>to ask for permission.  For software which is copyrighted by the Free~<10>Software Foundation, write to the Free Software Foundation; we sometimes~<10>make exceptions for this.  Our decision will be guided by the two goals~<10>of preserving the free status of all derivatives of our free software and~<10>of promoting the sharing and reuse of software generally.~<10|10>                            NO WARRANTY~<10|10>  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY~<10>FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN~<10>OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES~<10>PROVIDE THE PROGRAM ~<34>AS IS~<34> WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED~<10>OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF~<10>MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS~<10>TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE~<10>PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,~<10>REPAIR OR CORRECTION.~<10|10>  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING~<10>WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR~<10>REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,~<10>INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING~<10>OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED~<10>TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY~<10>YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER~<10>PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE~<10>POSSIBILITY OF SUCH DAMAGES.~<10|10>                     END OF TERMS AND CONDITIONS~<10>~<10>        Appendix: How to Apply These Terms to Your New Programs~<10|10>  If you develop a new program, and you want it to be of the greatest~<10>possible use to the public, the best way to achieve this is to make it~<10>free software which everyone can redistribute and change under these terms.~<10|10>  To do so, attach the following notices to the program.  It is safest~<10>to attach them to the start of each source file to most effectively~<10>convey the exclusion of warranty; and each file should have at least~<10>the ~<34>copyright~<34> line and a pointer to where the full notice is found.~<10|10>    ~<60>one line to give the program's name and a brief idea of what it does.~<62|10>    Copyright (C) 19yy  ~<60>name of author~<62|10|10>    This program is free software; you can redistribute it and/or modify~<10>    it under the terms of the GNU General Public License as published by~<10>    the Free Software Foundation; either version 2 of the License, or~<10>    (at your option) any later version.~<10|10>    This program is distributed in the hope that it will be useful,~<10>    but WITHOUT ANY WARRANTY; without even the implied warranty of~<10>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the~<10>    GNU General Public License for more details.~<10|10>    You should have received a copy of the GNU General Public License~<10>    along with this program; if not, write to the Free Software~<10>    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.~<10|10>Also add information on how to contact you by electronic and paper mail.~<10|10>If the program is interactive, make it output a short notice like this~<10>when it starts in an interactive mode:~<10|10>    Gnomovision version 69, Copyright (C) 19yy name of author~<10>    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.~<10>    This is free software, and you are welcome to redistribute it~<10>    under certain conditions; type `show c' for details.~<10|10>The hypothetical commands `show w' and `show c' should show the appropriate~<10>parts of the General Public License.  Of course, the commands you use may~<10>be called something other than `show w' and `show c'; they could even be~<10>mouse-clicks or menu items--whatever suits your program.~<10|10>You should also get your employer (if you work as a programmer) or your~<10>school, if any, to sign a ~<34>copyright disclaimer~<34> for the program, if~<10>necessary.  Here is a sample; alter the names:~<10|10>  Yoyodyne, Inc., hereby disclaims all copyright interest in the program~<10>  `Gnomovision' (which makes passes at compilers) written by James Hacker.~<10|10>  ~<60>signature of Ty Coon~<62>, 1 April 1989~<10>  Ty Coon, President of Vice~<10|10>This General Public License does not permit incorporating your program into~<10>proprietary programs.  If your program is a subroutine library, you may~<10>consider it more useful to permit linking proprietary applications with the~<10>library.  If this is what you want to do, use the GNU Library General~<10>Public License instead of this License.>>file<0||name<0|COPYING.modifiedGPL.txt>path<0|/COPYING.modifiedGPL.txt>data<0|This is the file COPYING.modifiedGPL, it applies to all file in this folder and~<10>to all file in any subdirectory of this folder and it applies to all folders in this folder.~<10|10>These files are distributed under the Library GNU General Public License~<10>(see the file COPYING.LGPL) with the following modification:~<10|10>As a special exception, you must add a note at the startup of your program, that~<10>this program uses files by http://marcelmaertens.funpic.de/.~<10>For example: ~<34>some files by marcelmaertens.funpic.de~<34|10|10>As a special exception, you have to the copyright holders of this library give you~<10>permission to link this library with independent modules to produce an~<10>executable, regardless of the license terms of these independent modules,~<10>and to copy and distribute the resulting executable under terms of your choice,~<10>provided that you also meet, for each linked independent module, the terms~<10>and conditions of the license of that module. An independent module is a~<10>module which is not derived from or based on this library. If you modify this~<10>library, you may extend this exception to your version of the library, but~<10>you are not obligated to do so. If you do not wish to do so, delete this~<10>exception statement from your version.~<10|10|10>If you didn't receive a copy of the file COPYING.LGPL, contact:~<10>      Free Software Foundation, Inc.,~<10>      675 Mass Ave~<10>      Cambridge, MA  02139~<10>      USA>>folder<0||name<0|marcelOS>path<0|/marcelOS>sub<0||folder<0||name<0|apis>path<0|marcelOS/apis>sub<0||file<0||name<0|classapi>path<0|marcelOS/apis/classapi>data<0|--[[~<10>THANKS to Ian~<10>http://www.rtsoft.com/forums/showthread.php?1466-A-cleaner-easier-class-idiom-in-Lua~<10>]]~<10|10>function class(superclass, name)~<10>    local cls = superclass and superclass() or {}~<10>    cls.__name = name or ~<34|34|10>    cls.__super = superclass~<10>	cls.__index = cls~<10>    return setmetatable(cls, ~<10>	  {~<10>	  __call = function (c, ...)~<10>      local instance = setmetatable({__class = cls}, cls)~<10>      if cls.__init then~<10>         cls.__init(instance, ...)~<10>         end~<10>      return instance~<10>      end~<10>	  }~<10>	)~<10>end~<10|10>--[[~<10|10>function class()~<10>    local cls = {}~<10>    cls.__index = cls~<10>    return setmetatable(cls, ~<10>	  {~<10>	  __call = function (c, ...)~<10>      local instance = setmetatable({}, cls)~<10>      if cls.__init then~<10>         cls.__init(instance, ...)~<10>         end~<10>      return instance~<10>      end~<10>	  }~<10>	)~<10>end~<10>]]~<10|10>function issubclass(class1, class2)~<10>if (type(class1) ~<126>= ~<34>table~<34>) or (type(class2) ~<126>= ~<34>table~<34>) then~<10>	return false~<10>	end~<10>while true do~<10>    if class1 == class2 then~<10>        return true~<10>        end~<10>    class2 = class2.__super~<10>    if not class2 then~<10>        break~<10>		end~<10>    end~<10>return false~<10>end~<10|10>function isinstance(inst, cls)~<10>return (type(inst) == ~<34>table~<34>) and issubclass(inst.__class, cls)~<10>end>>file<0||name<0|driver>path<0|marcelOS/apis/driver>data<0|--drivers sorgt dafür das Alle Events richtig interpretiert werden. Dynamisch Events hinzugefügt werden können...~<10>boot.BootMsg(~<34>starting drivers~<34>)~<10|10>local drivers = {} -- SU Task hier sind alle wichtigen eigenschaften~<10>TDriver = classapi.class(nil,~<34>TDriver~<34>) ~<10>local version = ~<34>0.1~<34|10|10>driver_sides = {~<34>back~<34>,~<34>top~<34>,~<34>left~<34>,~<34>bottom~<34>,~<34>right~<34>,~<34>front~<34>}~<10|10|10>function TDriver:__init( _name )~<10>	self.name = _name~<10>	self.file = path.C(path.DRIVERS(),_name)~<10>	self.args = {}~<10>	self.init = false~<10>	drivers[#drivers+1] = self~<10>end~<10|10>function TDriver:Init()~<10>if (not self.init) then~<10>	local ver = self:GiveFunc(~<34>Driver_Initial~<34>)~<10>	if ver then~<10>		ver()~<10>		end~<10>	self.init = true~<10>	end~<10>end~<10|10>function findfunction(x)~<10>  assert(type(x) == ~<34>string~<34>)~<10>  local f=_G~<10>  for v in x:gmatch(~<34>[^%.]+~<34>) do~<10>    if type(f) ~<126>= ~<34>table~<34> then~<10>       return nil, ~<34>looking for '~<34>..v..~<34>' expected table, not ~<34>..type(f)~<10>    end~<10>    f=f[v]~<10>  end~<10>  if type(f) == ~<34>function~<34> then~<10>    return f~<10>  else~<10>    return nil, ~<34>expected function, not ~<34>..type(f)~<10>  end~<10>end~<10|10|10>function TDriver:GiveFunc(aname)~<10>local aevnt = findfunction(self.name .. ~<34>.~<34> .. aname)~<10>if aevnt then~<10>	return assert(aevnt)~<10>	else~<10>	boot.BootMsg(~<34>Driver '~<34> .. self.name .. ~<34>' failed to load!~<34>) ~<10>	return nil~<10>	end~<10>end~<10|10|10>-- USER FUNCTIONS~<10>function CreateDriver(name)~<10>local new = TDriver(name or ~<34|34>)~<10>os.loadAPI( new.file )~<10>local ver = new:GiveFunc(~<34>Driver_Meta_Version~<34>)~<10>if ver then~<10>	boot.BootMsg(~<34>Driver '~<34> .. new.name .. ~<34>' v.:~<34> .. tostring(ver()))~<10>	end~<10>end~<10|10>function LoadAllDrivers()~<10>local ok = false~<10>local fFile,obj = ~<34|34|10>local n,i = 0~<10|10>local tApis = fs.list( path.DRIVERS() )~<10>for n,sFile in ipairs( tApis ) do~<10>	if not fs.isDir( sFile ) then~<10>		ok = true~<10>		for i,obj in ipairs( drivers ) do~<10>			if obj.name == sFile then~<10>				ok = false~<10>				break~<10>				end~<10>			end~<10>		if ok then~<10>			CreateDriver(sFile)~<10>			end~<10>		end~<10>	end~<10>	~<10>for i,obj in ipairs( drivers ) do~<10>	obj:Init()~<10>	end~<10>end~<10|10|10>function EventInterpreter( _event )~<10>local i,obj = 0~<10>for i,obj in ipairs( drivers ) do~<10>	local aevnt = obj:GiveFunc(~<34>Driver_Event~<34>)~<10>	if aevnt and _event and _event.enabled then~<10>		local answ = aevnt(_event)~<10>		end~<10>	end~<10>end~<10|10>function API_Initial()~<10>LoadAllDrivers()~<10>local new = events.CreateEvent(~<34>Initialised~<34>,~<34>driver~<34>, ~<34>driver~<34>)~<10>mTask.RawRaiseEvent(new)~<10>end~<10|10|10>>>file<0||name<0|ehtf>path<0|marcelOS/apis/ehtf>data<0|--[[~<10>Yeah, this is the Epic EHTF Node system in LUA.~<10>Now easy Save Data of every type in a Simple String !~<10>e.g. if you want to send a huge complex ammount of information over rednet...~<10|10>I RECOMMENT TO TURN tsUseInsert ALWAYS OFF !!! BEACAUSE EITHER ME or LUA is to ****** to find out, that the lenght of a string ~<34>hel/lo Wörld~<34> 13 is...~<10|10>]]~<10|10>THTNode = classapi.class(nil,~<34>THTNode~<34>)~<10|10>function StCutOutFunc(Sender , achar)~<10>local result = ((achar == Sender.vardec._Begin)~<10>		or (achar == Sender.vardec._End) ~<10>		or (achar == Sender.vardec._Array) ~<10>		or (achar == Sender.vardec._System) ~<10>		or (achar == string.char(0)))  ~<10>return result~<10>end~<10|10>function THTNode:__init()~<10>	self.parent = nil~<10>	self.vardec = ehtfutils.TVarDec()~<10>	self.nodes = {}~<10>	self.Values = {} -- No Type needed, because lua :) ~<10>	self.about = ~<34|34|10>	self.CutOutfunc = StCutOutFunc~<10>	self.CaseSensitive = false~<10>	end~<10|10|10>--[[ ~<10>Missing:~<10|10|10>FindAllAbout~<10>FindAllAboutC~<10>FindAllVar~<10>ValidAbout~<10>GetCount~<10>GetItem~<10>SetItem~<10|10|10>Die FundAbout(about , p ) funktionen.... kein Out Parameter !~<10>]]~<10|10>--[[##################]]~<10>--[[       THTNode    ]]~<10>--[[##################]]   ~<10|10>function THTNode:Assign( from )~<10>local i = 0~<10>self.vardec = from.vardec~<10>self.CutOutfunc = from.CutOutfunc~<10>self.CaseSensitive = from.CaseSensitive~<10>self.about = from.about~<10>self.parent = from.parent~<10|10>self.Values = {}~<10>for i = 1,#from.Values do~<10>	self.Values[i] = from.Values[i]~<10>	end~<10>	~<10>self.nodes = {}~<10>for i = 1,#from.nodes do~<10>	self.nodes[i] = THTNode()~<10>	self.nodes[i]:Assign(from.nodes[i])~<10>	self.nodes[i].parent = self~<10>	end~<10>end~<10|10|10>--[[##################]]~<10>--[[  Add functtions  ]]~<10>--[[##################]]   ~<10|10>function THTNode:AddChild()~<10>local result = THTNode()~<10>self.nodes[#self.nodes+1] = result~<10>result.parent = self~<10>result.vardec = self.vardec~<10>result.CutOutfunc = self.CutOutfunc~<10>result.CaseSensitive = self.CaseSensitive~<10>return result~<10>end~<10|10>function THTNode:AddChildPos( pos )~<10>local result = THTNode()~<10>self:Insert(pos,result)~<10>result.parent = self~<10>result.vardec = self.vardec~<10>result.CutOutfunc = self.CutOutfunc~<10>result.CaseSensitive = self.CaseSensitive~<10>return result~<10>end~<10|10>function THTNode:Add(aabout , SVar)~<10>local result = nil~<10>local i = 0~<10>if type(aabout) == ~<34>table~<34> then~<10>	if classapi.isinstance(aabout,THTNode) then~<10>		result = #self.nodes+1~<10>		self.nodes[result] = aabout~<10>		aabout.parent = self~<10>		return result~<10>		end~<10>	end~<10>result = self:AddChild()~<10>result.about = aabout~<10>if type(SVar) == ~<34>table~<34> then~<10>	for i = 1,#SVar do~<10>		result:AddValue(SVar[i])~<10>		end~<10>	else~<10>	result:AddValue( SVar )~<10>	end~<10>return result~<10>end~<10|10>function THTNode:Load(aabout,alt)~<10>local result = alt ~<10>local p = self:FindAboutC(aabout)~<10>if p then~<10>	result = p.Values[1]~<10>	end~<10>return result~<10>end~<10|10>function THTNode:Load(aabout,alt)~<10>local result = alt ~<10>local p = self:FindAboutC(aabout)~<10>if p then~<10>	result = p.Values[1]~<10>	end~<10>return result~<10>end~<10|10>function THTNode:LoadI(aabout,alt)~<10>local result = alt ~<10>local p = self:FindAboutC(aabout)~<10>if p then~<10>	result = p:SValuesI(1)~<10>	end~<10>return result~<10>end~<10|10>function THTNode:LoadS(aabout,alt)~<10>local result = alt ~<10>local p = self:FindAboutC(aabout)~<10>if p then~<10>	result = p:SValuesS(1)~<10>	end~<10>return result~<10>end~<10|10>function THTNode:LoadB(aabout,alt)~<10>local result = alt ~<10>local p = self:FindAboutC(aabout)~<10>if p then~<10>	result = p:SValuesB(1)~<10>	end~<10>return result~<10>end~<10|10>function THTNode:ParentAddBehind()~<10>local result = nil~<10>if self.parent ~<126>= nil then~<10>	local  i = self.parent:FindNode(self)~<10>	if i ~<62> 0 then ~<10>		result = self.parent:AddChildPos(i+1)~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:ParentAddBefore()~<10>local result = nil~<10>if self.parent ~<126>= nil then~<10>	local  i = self.parent:FindNode(self)~<10>	if i ~<62> 0 then ~<10>		result = self.parent:AddChildPos(i-1)~<10>		end~<10>	end~<10>return result~<10>end~<10|10>--[[#####################]]~<10>--[[  useful functtions  ]]~<10>--[[#####################]]   ~<10|10>function THTNode:AddValue( SVar )~<10>local result = #self.Values+1~<10>self.Values[result] = SVar~<10>return result~<10>end~<10|10|10>function THTNode:UnGroup( aindex )~<10>local i = 0~<10>local result = nil~<10>if type(aindex) ~<126>= ~<34>number~<34> then~<10>	result = aindex~<10>	aindex = self:FindNode(aindex)	~<10>	else~<10>	result = self.nodes[aindex]~<10>	end~<10>if (aindex ~<60> 1) or (aindex ~<62> #self.nodes) then ~<10>	return nil~<10>	end~<10>self.nodes[aindex] = nil~<10>for i = aindex,#self.nodes-1 do~<10>	self.nodes[i] = self.nodes [i+1]~<10>	end~<10>result.parent = nil~<10>return result~<10>end~<10|10|10>function THTNode:Delet( aindex )~<10>local i = 0~<10>if type(aindex) ~<126>= ~<34>number~<34> then~<10>	aindex = self:FindNode(aindex)	~<10>	end~<10>if (aindex ~<60> 1) or (aindex ~<62> #self.nodes) then ~<10>	return~<10>	end~<10>self.nodes[aindex] = nil~<10>for i = aindex,#self.nodes-1 do~<10>	self.nodes[i] = self.nodes [i+1]~<10>	end~<10>end~<10|10>function THTNode:Reduceto( aindex)~<10>if type(aindex) == ~<34>number~<34> then ~<10>	self:INTRedureToNumber(aindex)~<10>	else~<10>	self:INTRedureToNode(aindex)~<10>	end~<10>end~<10|10>-- INTERNAL~<10>function THTNode:INTReducetoNumber( aindex )~<10>local i = 0~<10>for i = #self.nodes,aindex+1,-1 do~<10>	self.nodes[i] = nil~<10>	end~<10>end~<10|10>function THTNode:INTReducetoNode( anode )~<10>local i = 0~<10>for i = #self.nodes,1,-1 do~<10>	if self.nodes[i] == anode then~<10>		return~<10>		else~<10>		self.nodes[i] = nil~<10>		end~<10>	end~<10>end~<10>-- Public~<10|10>function THTNode:Insert( aindex, anode)~<10>local i = 0~<10>if aindex ~<62> #self.nodes+1 then ~<10>	return~<10>	end~<10>for i = #self.nodes+1,aindex+1,-1 do~<10>	self.nodes[i] = self.nodes[i-1]~<10>	end~<10>self.nodes[aindex] = anode~<10>anode.parent = self~<10>end~<10|10>function THTNode:Node(x)~<10>local i = 0~<10>local result = self~<10>for i = 1,#x do~<10>	if type(x[i]) == ~<34>number~<34> then~<10>		if (x[i] ~<62> 0) and (x[i] ~<60>= #self.nodes) then~<10>			result = result.nodes[x[i]]~<10>			else~<10>			result = nil~<10>			end~<10>		else~<10>		result = (result.FindAbout(x[i]))~<10>		end~<10>	if result == nil then~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>--[[###################]]~<10>--[[  Find functtions  ]]~<10>--[[###################]]~<10|10|10>function THTNode:FindNode( anode )~<10>local i = 0~<10>local result = -1~<10>for i = 1,#self.nodes do~<10>	if self.nodes[i] == anode then~<10>		result = i~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAbout( astring )~<10>local i = 0~<10>local result = nil~<10>astring = self:CaseFunc(astring)~<10>for i = 1,#self.nodes do~<10>	if self:CaseFunc(self.nodes[i].about) == astring then~<10>		result = self.nodes[i]~<10>		return result~<10>		end~<10>	result = self.nodes[i]:FindAbout(astring)~<10>	if result then~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAboutCi( astring )~<10>local i = 1~<10>local result = -1~<10>astring = self:CaseFunc(astring)~<10>for i = 1,#self.nodes do~<10>	if self:CaseFunc(self.nodes[i].about) == astring then~<10>		result = i~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAboutC( astring )~<10>local i = self:FindAboutCi( astring )~<10>local result = nil~<10>if i ~<62> 0 then~<10>	result = self.nodes[i]~<10>	return result~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAboutN( astring )~<10>local i = 0~<10>local result = nil~<10>astring = self:CaseFunc(astring)~<10>for i = #self.nodes,1,-1 do~<10>	if self:CaseFunc(self.nodes[i].about) == astring then~<10>		result = self.nodes[i]~<10>		return result~<10>		end~<10>	result = self.nodes[i]:FindAboutN(astring)~<10>	if result then~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAboutNC( astring )~<10>local i = self:FindAboutNCi( astring )~<10>local result = nil~<10>if i ~<62> 0 then~<10>	result = self.nodes[i]~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAboutNCi( astring )~<10>local i = 1~<10>local result = -1~<10>astring = self:CaseFunc(astring)~<10>for i = #self.nodes,1,-1 do~<10>	if self:CaseFunc(self.nodes[i].about) == astring then~<10>		result = i~<10>		return result ~<10>		end~<10>	end~<10>return result ~<10>end~<10|10>function THTNode:FindVar( SVar )~<10>local i = 1~<10>local i2 = 1~<10>local result = nil~<10>for i = 1,#self.nodes do~<10>	for i2 = 1,#self.Values do~<10>		if self.Values == SVar then~<10>			result = self.nodes[i]~<10>			return result ~<10>			end~<10>		end~<10>	result = self.nodes[i]:FindVar( SVar )~<10>	if result then ~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:SetSValues_Check( acardinal ,writemode )   ~<10>local i = 0~<10>local result = acardinal ~<62> 0~<10>if (acardinal ~<62> #self.Values) and (readmode) then~<10>	i = #self.Values+1~<10>	for i = i,acardinal-1 do~<10>		print(i)~<10>		self.Values[i] = ~<34|34|10>		end~<10>	end~<10>return result~<10>end~<10>	~<10>function THTNode:SValues( acardinal , aValue )~<10>local result = (aValue or nil)~<10>local writemode = aValue ~<126>= nil~<10>if self:SetSValues_Check(acardinal, writemode) then ~<10>	if writemode then ~<10>		self.Values[acardinal] = result~<10>		else~<10>		result = self.Values[acardinal]~<10>		end~<10>	else~<10>	result = ~<34|34|10>	end~<10>return result~<10>end~<10|10>function THTNode:SValuesS( acardinal , aValue )~<10>local result = tostring(aValue or ~<34|34>)~<10>local writemode = (aValue ~<126>= nil)~<10>if self:SetSValues_Check(acardinal, writemode) then ~<10>	if writemode then ~<10>		self.Values[acardinal] = result~<10>		else~<10>		result = tostring(self.Values[acardinal]) or ~<34|34|10>		end~<10>	else~<10>	result = ~<34|34|10>	end~<10>return result~<10>end~<10|10>function THTNode:SValuesI( acardinal , aValue )~<10>local result = tonumber(aValue or 0)~<10>local writemode = aValue ~<126>= nil~<10>if self:SetSValues_Check(acardinal, writemode) then ~<10>	if writemode then ~<10>		self.Values[acardinal] = result~<10>		else~<10>		result = tonumber(self.Values[acardinal]) or 0~<10>		end~<10>	else~<10>	result = 0~<10>	end~<10>return result~<10>end~<10|10>function THTNode:SValuesB( acardinal , aValue )~<10>local result = ehtfutils.toboolean(aValue or 0)~<10>local writemode = aValue ~<126>= nil~<10>if self:SetSValues_Check(acardinal, writemode) then ~<10>	if writemode then ~<10>		self.Values[acardinal] = result~<10>		else~<10>		result = ehtfutils.toboolean(self.Values[acardinal] or 0)~<10>		end~<10>	else~<10>	result = false~<10>	end~<10>return result~<10>end~<10>	~<10>function THTNode:CaseFunc( astr )~<10>local result = ~<34|34|10>if self.CaseSensitive then result = astr~<10>	else result = string.lower(astr) end~<10>return result~<10>end~<10|10>function THTNode:CutOutChars( astring , IntFunc )~<10>local i = 1~<10>local i2 = 1~<10>local von = 1~<10>local result = ~<34|34|10>local achar = ~<34|34|10>local offen = false~<10|10>for i = 1,string.len(astring) do~<10>	achar = string.char(string.byte(astring,i))~<10>	if (self.CutOutfunc and self:CutOutfunc(achar)) or ((not self.CutOutfunc) and StCutOutFunc(self,achar)) then -- Irgendwie wird CurOutFunc ned gespeichert... deswegen umgehung :)~<10>		if von ~<60> i then~<10>			if offen then ~<10>				result = result .. self.vardec._End~<10>				end~<10>			result = result .. string.sub(astring,von,i-1)~<10>			offen = false~<10>			end~<10>		~<10>		if offen then~<10>			result = result .. self.vardec._Array .. string.byte(achar)~<10>			else~<10>			result = result .. self.vardec._System .. self.vardec._Begin .. string.byte(achar)~<10>			end~<10>			~<10>		offen = true~<10>		von = i +1~<10>		i2 = i2 + 1~<10>		if IntFunc and ((i2 % 10000) == 0) then ~<10>			IntFunc(self)~<10>			end~<10>		end~<10>	end~<10>if offen then ~<10>	result = result .. self.vardec._End~<10>	end~<10>result = result .. string.sub(astring,von)~<10>return result~<10>end~<10|10>function THTNode:ToStr( mode , IntFunc )~<10>local i = 1~<10>local atext = ~<34|34|10>local result = ~<34|34|10>local lmode = vec3.Copy(mode or ehtfutils.stToStrMode)~<10|10>if IntFunc then ~<10>	IntFunc(self)~<10>	end~<10|10>if lmode[~<34>tsWriteMetaInfo~<34>] then~<10>	result = HTVardectoStr(self.vardec,stvardec())~<10>	end~<10>	~<10>result = result .. self:CutOutChars(self.about , IntFunc  ) .. self.vardec._Begin~<10>if lmode[~<34>tsWriteTypecast~<34>] then~<10>	result = result .. self.vardec._System .. ~<34>t~<34> .. self.vardec._Begin .. ~<34>true~<34> .. self.vardec._End ~<10>	end~<10>if lmode[~<34>tsUseTypecast~<34>] and (#self.Values ~<62> 0) then~<10>	result = result .. tostring(ehtfutils.GetArt(self.Values[1])) .. self.vardec._Array~<10>	end~<10>for i = 1,#self.Values do~<10>	atext = self:SValuesS(i)~<10>	if lmode[~<34>tsUseInsert~<34>] and (string.len(atext) ~<62> 20) then~<10>		atext = self.vardec._System .. 'i' .. self.vardec._Begin .. tostring(string.len(atext)) .. self.vardec._End .. atext~<10>		else~<10>		atext = self:CutOutChars(atext , IntFunc )~<10>		end~<10>	~<10>	if (i == #self.Values) and (#self.nodes == 0) and (string.len(atext) ~<62> 0) then ~<10>		result = result .. atext~<10>		else~<10>		result = result .. atext .. self.vardec._Array~<10>		end~<10>	end~<10>lmode[~<34>tsWriteMetaInfo~<34>] = false~<10>lmode[~<34>tsWriteTypecast~<34>] = false~<10>for i = 1,#self.nodes do~<10>	result = result .. self.nodes[i]:ToStr(lmode, IntFunc)~<10>	end~<10>result = result .. self.vardec._End	~<10>return result~<10>end~<10|10>function THTNode:FromStr( astring , vardec ,IntFunc )~<10>local a,b,c = HTStrtoNode(astring, self, vardec ,IntFunc)~<10>self = a~<10>return b,c~<10>end~<10|10>function THTNode:LoadfromFile( path , vardec )~<10>local b,c = self:FromStr(ehtfutils.FileToString(path), vardec)~<10>return b,c~<10>end~<10|10>function THTNode:SavetoFile( path, mode )~<10>local a = self:ToStr( mode )~<10>ehtfutils.StringToFile(path , a)~<10>end~<10|10|10>function HTStrtoNode(astring,resultNODE,vardec,IntFunc) -- resultNode - result (TEHTFStatus) - i;~<10>local deep = 0~<10>local sysdeep = 0~<10>local atext = ~<34|34|10>local systext = ~<34|34|10>local charpuffer = ~<34|34|10>local obj = {nil}~<10>local i = 1~<10>local instsys = false~<10>local curtypecast = -1~<10>local typecast = false~<10>local systypecast = false~<10>local syscurtypecast = 0~<10>local sysnode = nil~<10>local newnode = nil~<10>local p,o = nil~<10>local rp = ~<34>EHTFnone~<34|10>local result = ~<34>EHTFerror~<34|10>local lastsystemsymbol = -1~<10|10>function d(b)~<10>if b or (b == nil) then ~<10>	deep = deep + 1~<10>	else~<10>	deep = deep -1~<10>	end~<10>result = (deep ~<62> 0)~<10>return result~<10>end~<10|10>function Insert_Value()~<10>if deep ~<62>= 1 then~<10>	if typecast then~<10>		if (#obj[deep].Values == 0) and (curtypecast == -1) then~<10>			curtypecast = tonumber(atext or 0) or 0~<10>			else~<10>			obj[deep]:AddValue(ehtfutils.HTStrtoSVar(atext,curtypecast))~<10>			end~<10>		else~<10>		obj[deep]:AddValue(ehtfutils.HTStrtoSVar(atext,-1)) -- he should guesses~<10>		end~<10>	atext = ~<34|34|10>	end~<10>end~<10|10>function InterpretSystemNode(anode)~<10>local result = ~<34>EHTFNone~<34|10>local i2 = 0~<10>local astrpuffer = string.lower(anode.about)~<10|10>if (astrpuffer == ~<34|34>) then~<10>	for i2 = 1,#anode.Values do~<10>		atext = atext.. string.char(anode:SValuesI(i2))~<10>		end~<10>	elseif (astrpuffer == ~<34>_b~<34>) then~<10>		vardec._Begin = string.char(anode:SValuesI(1) or 0)~<10>		elseif (astrpuffer == ~<34>_e~<34>) then~<10>			vardec._End = string.char(anode:SValuesI(1) or 0)~<10>			elseif (astrpuffer == ~<34>_a~<34>) then~<10>				vardec._Array = string.char(anode:SValuesI(1) or 0)~<10>				elseif (astrpuffer == ~<34>_s~<34>) then~<10>					vardec._System = string.char(anode:SValuesI(1) or 0)~<10>					elseif (astrpuffer == ~<34>t~<34>) then~<10>						typecast = anode:SValuesB(1)~<10>						elseif (astrpuffer == ~<34>il~<34>) then~<10>							if (anode:SValuesI(1)+anode:SValuesI(2)-1) ~<62> string.len(astring) then~<10>								result = ~<34>EHTFincorrectString~<34|10>								return result~<10>								end~<10>							atext = atext .. string.sub(astring,anode:SValuesI(1),anode:SValuesI(1)+anode:SValuesI(2))~<10>							elseif (astrpuffer == ~<34>i~<34>) then~<10>								if (i+anode:SValuesI(1)) ~<62> string.len(astring) then~<10>									result = ~<34>EHTFincorrectString~<34|10>									return result~<10>									end~<10>								atext = atext .. string.sub(astring,i+1,i+anode:SValuesI(1))~<10>								i = i + anode:SValuesI(1)~<10>								elseif (astrpuffer == ~<34>g~<34>) then ~<10>									i = anode:SValuesI(1)~<10>									elseif (astrpuffer == ~<34>e~<34>) then ~<10>										result = ~<34>EHTFexit~<34|10>										return result~<10>										end	~<10|10|10>for i2 = 1,#anode.nodes do~<10>	InterpretSystemNode(anode.nodes[i2])					~<10>	end~<10>return result~<10>end~<10|10>if vardec == nil then~<10>	vardec = ehtfutils.stvardec()~<10>	end~<10|10>while i ~<60>= string.len(astring) do~<10>	charpuffer = string.char(string.byte(astring,i))~<10>	if charpuffer == vardec._Begin then --[[ BEGIN ]]  ~<10>		if not d() then~<10>			result = ~<34>EHTFincorrectString~<34|10>			return resultNODE , result , i~<10>			end~<10>		newnode = THTNode()~<10>		newnode.vardec = vardec~<10>		obj[deep] = newnode~<10>		if string.len(atext) ~<62> 0 then ~<10>			newnode.about = atext~<10>			end~<10>	~<10>		if (lastsystemsymbol ~<62> 0) then~<10>			instsys = true --[[ SYSTEM ]]~<10>			end~<10>		~<10>		if instsys and (sysnode == nil) then~<10>			--newnode.about = vardec._System~<10>			newnode.about = string.sub(astring,lastsystemsymbol+1,i-1)~<10>			systypecast = typecast~<10>			syscurtypecast = curtypecast~<10>			typecast = false~<10>			sysnode = newnode~<10>			sysdeep = deep~<10>			--systext = string.sub(atext,1,#atext-1)~<10>			systext = string.sub(atext,1,#atext-(i-lastsystemsymbol)+1)~<10>			else~<10>			if deep ~<62> 1 then~<10>				obj[deep-1]:Add(newnode)~<10>				else~<10>				if resultNODE then~<10>					resultNODE:Assign(obj[1]) -- neuer node~<10>					obj[1] = nil~<10>					obj[1] = resultNODE~<10>					else~<10>					resultNODE = obj[1]~<10>					end~<10>				end~<10>			end~<10>		~<10>		curtypecast = -1~<10>		atext = ~<34|34|10>		else~<10>		if charpuffer == vardec._End then --[ END ]]~<10>			if string.len(atext) ~<62> 0 then ~<10>				Insert_Value()~<10>				end~<10>			if (not d(false)) and (i ~<126>= string.len(astring)) then~<10>				result = ~<34>EHTFdonePart~<34> -- Der node ist offiziel vorbei, hier komtm aber noch was dahinter. evt nen zweiter , andere Node !~<10>				return resultNODE , result , i~<10>				end~<10>			curtypecast = -1~<10>			if IntFunc then~<10>				rp = IntFunc(obj[deep],instsys)~<10>				if rp ~<126>= EHTFnone then~<10>					return rp~<10>					end~<10>				end~<10>			if instsys and (deep ~<60> sysdeep) then~<10>				sysdeep = 0~<10>				instsys = false~<10>				atext = atext .. systext -- systext ist das was vot dem systemaufruf da stand~<10>				typecast = systypecast~<10>				curtypecast = syscurtypecast~<10>				rp = InterpretSystemNode(sysnode)~<10>				if rp ~<126>= ~<34>EHTFNone~<34> then~<10>					result = rp~<10>					return resultNODE , result , i~<10>					end~<10>				sysnode = nil~<10>				lastsystemsymbol = -1~<10>				end~<10>			else~<10>			if charpuffer == vardec._Array then ~<10>				Insert_Value() --[[ Array ]]~<10>				else~<10>				if charpuffer == vardec._System then~<10>					lastsystemsymbol = i ~<10>					else~<10>					atext = atext .. charpuffer --[[ Normal ]]~<10>					end~<10>				end~<10>			end~<10>		end~<10>	i = i + 1~<10>	end~<10>if deep ~<60> 1 then ~<10>	result = ~<34>EHTFdone~<34|10>	else~<10>	result = ~<34>EHTFincorrectString~<34> --  Hier fehlt was. Der String bricht ab bevor alles geschlossen werden kann !~<10>	end~<10>	~<10>return resultNODE , result , i~<10>end>>file<0||name<0|ehtfutils>path<0|marcelOS/apis/ehtfutils>data<0|TEHTFStatus = {~<34>EHTFdone~<34>,~<34>EHTFdonePart~<34>,~<34>EHTFerror~<34>,~<34>EHTFexit~<34>,~<34>EHTFincorrectString~<34>,~<34>EHTFnone~<34>}~<10|10>TVarDec = classapi.class(nil,~<34>TVarDec~<34>)~<10|10>function TVarDec:__init()~<10>	self._Begin = ~<34|60|34|10>	self._End = ~<34|62|34|10>	self._Array = ~<34|124|34|10>	self._System = ~<34|126|34|10>	end~<10|10>ToStrPar = {~<34>tsWriteMetaInfo~<34>,~<34>tsWriteTypecast~<34>,~<34>tsUseTypecast~<34>,~<34>tsUseInsert~<34>}~<10>ToStrMode = {[~<34>tsWriteMetaInfo~<34>] = true,[~<34>tsWriteTypecast~<34>] = true,[~<34>tsUseTypecast~<34>] = true,[~<34>tsUseInsert~<34>] = true}~<10>stToStrMode =  {[~<34>tsWriteMetaInfo~<34>] = false,[~<34>tsWriteTypecast~<34>] = true,[~<34>tsUseTypecast~<34>] = true,[~<34>tsUseInsert~<34>] = true}~<10>stToStrModeAll =  {[~<34>tsWriteMetaInfo~<34>] = true,[~<34>tsWriteTypecast~<34>] = true,[~<34>tsUseTypecast~<34>] = true,[~<34>tsUseInsert~<34>] = true}~<10>EHTFversion = ~<34>0.9.8~<34|10|10>function stvardec()~<10>return TVarDec()~<10>end~<10|10>function TVarDec:Assign(vardec)~<10>-- Pflicht da Klasse und kein Record !~<10>self._Begin = vardec._Begin~<10>self._End = vardec._End~<10>self._Array = vardec._Array~<10>self._System = vardec._System~<10>end~<10|10>function FileToString( apath )~<10>local result = ~<34|34|10>local file = fs.open(apath,~<34>r~<34>)~<10>if file then~<10>	result = file.readAll()~<10>	file.close()~<10>	end~<10>return result~<10>end~<10|10>function FileToStringB( apath )~<10>local result = ~<34|34|10>local file = fs.open(apath,~<34>rb~<34>)~<10>local sLine = ~<34|34|10>if file then~<10>	sLine = file.read()~<10>	while sLine do~<10>		result = result .. sLine~<10>		sLine = file.read()~<10>		end~<10>	file.close()~<10>	end~<10>return result~<10>end~<10|10>function StringToFile( apath , astring )~<10>local file = fs.open(apath,~<34>w~<34>)~<10>if file then~<10>	file.write(astring)~<10>	file.close()~<10>	end~<10>end~<10|10>function HTStrtoSVar(astr,typecast)~<10>-- Andere funktion...~<10>local result~<10>if typecast == 0 then~<10>	result = tostring(astr)~<10>	elseif (typecast == 1) or (typecast == 2) then~<10>		result = tonumber(astr)~<10>		elseif typecast == 3 then~<10>			result = toboolean(astr)~<10>			else~<10>			result = astr~<10>			end~<10>return result~<10>end~<10|10>function GetArt(SVar)~<10>-- NEW FUNCTION~<10>local result = 0~<10>if type(SVar) == ~<34>number~<34> then ~<10>	result = 1~<10>	elseif type(SVar) == ~<34>string~<34> then~<10>		result = 0~<10>		elseif type(SVar) == ~<34>boolean~<34> then~<10>			result = 3~<10>			else~<10>			result = -1~<10>			end~<10>return result~<10>end~<10|10>function toboolean(avalue)~<10>if type(avalue) == ~<34>number~<34> then~<10>	return (avalue == -1)~<10>	elseif type(avalue) == ~<34>string~<34> then~<10>		return (string.lower(avalue) == ~<34>true~<34>)~<10>		elseif type(avalue) == ~<34>boolean~<34> then~<10>			return avalue~<10>			else~<10>			return (avalue ~<126>= nil)~<10>			end~<10>end~<10|10>function HTVardectoStr(newvardec, oldvardec)~<10>local result = oldvardec._System .. oldvardec._Begin.. ~<34>v~<34>  .. oldvardec._Begin .. EHTFversion .. oldvardec._End~<10>       .. ~<34>_b~<34>   .. oldvardec._Begin .. string.byte(newvardec._Begin)   .. oldvardec._End~<10>       .. ~<34>_e~<34>     .. oldvardec._Begin .. string.byte(newvardec._End)     .. oldvardec._End~<10>       .. ~<34>_a~<34>   .. oldvardec._Begin .. string.byte(newvardec._Array)   .. oldvardec._End~<10>       .. ~<34>_s~<34>  .. oldvardec._Begin .. string.byte(newvardec._System)  .. oldvardec._End~<10>       .. oldvardec._End~<10>return result~<10>end>>file<0||name<0|events>path<0|marcelOS/apis/events>data<0|-- marcelOS functions~<10>boot.BootMsg(~<34>starting events~<34>)~<10|10>local TEvents = classapi.class(nil,~<34>TEvents~<34>)  -- SU Task hier sind alle wichtigen eigenschaften~<10|10>function TEvents:__init( name , owner , ... )~<10>	self.name = name~<10>	self.owner = owner~<10>	self.params = {...}~<10>	self.enabled = true -- set to false if you want to KILL the event....~<10>end~<10|10>function TEvents:copy( _event ) ~<10>self.name = _event.name~<10>self.owner = _event.owener~<10>self.enabled = _event.enabled~<10>self.params = {}~<10>local i,obj = 0~<10>for i,obj in ipairs(_event.params) do~<10>	self.params[i] = obj	~<10>	end~<10>end~<10|10>function TEvents:instring() ~<10>local astr = ~<34>NAME: ~<34> .. self.name .. ~<34>    Owner: ~<34> .. self.owner .. ~<34>    Params:~<34|10>local i,obj = 0~<10>for i,obj in ipairs(self.params) do~<10>	astr = astr .. ~<34> ~<34> .. obj ~<10>	end~<10>return astr~<10>end~<10|10>function CreateEvent(event, owner , ...)~<10>return TEvents(event, owner , ...)~<10>end~<10|10>function CreateEventCopy(event, newname , newowner)~<10>local new = events.CreateEvent()~<10>new:copy(event)~<10>if newname then~<10>	new.name = newname~<10>	end~<10> if newowner then~<10>	new.owner = newowner~<10>	end~<10>return new~<10>end~<10|10>function API_Initial()~<10>new = events.CreateEvent(~<34>Initialised~<34>,~<34>events~<34>, ~<34>events~<34>)~<10>mTask.RawRaiseEvent(new)~<10>end>>file<0||name<0|ip>path<0|marcelOS/apis/ip>data<0|local trustDHCP = {}~<10>local DNS = {}~<10>UsedChannel = 1~<10>OwnIP = nil~<10>boot.BootMsg(~<34>starting ip~<34>)~<10|10>TipCon = classapi.class(nil,~<34>TipCon~<34>) ~<10>function TipCon:__init(_ip)~<10>	self.ip = _ip~<10>	self.server = Legal(_ip)~<10>	self.pos = {0/0,0/0,0/0}~<10>	self.moving = false -- anderer Timeout bei ~<34>moving~<34|10>	self.lastping = os.clock()~<10>	self.meta_own = false -- Ob der angegebene Meta Wert von der Con selber stammmt... Wenn ja, dann ist er ~<34>gültiger~<34> als wenn er von nem anderen Server gebracht wird :)~<10>	self.con = vec3.TList()~<10>	self.entf = -1 --only change on direct conntact !!!~<10>	self.parents = {} -- Alle PC die Zum PC connected sind !!!~<10>end~<10|10>function TipCon:Add(_ip)~<10>local new = TipCon(_ip)~<10>self.con:Add(new)~<10>vec3.AddCon(new.parents,self)~<10>return new~<10>end~<10|10>function TipCon:tostring()~<10>local result = ~<34|34|10>local p = ehtf.THTNode()~<10>local o = nil~<10>local i,obj = 0,nil~<10>p:Add(~<34>ip~<34>,self.ip)~<10>p:Add(~<34>server~<34>,ehtfutils.toboolean(self.server))~<10>p:Add(~<34>moving~<34>,self.moving)~<10>p:Add(~<34>pos~<34>,{self.pos[1],self.pos[2],self.pos[3]})~<10>o = p:Add(~<34>con~<34>,~<34|34>)~<10>if self.con  ~<126>= nil then~<10>	for i,obj in ipairs(self.con) do~<10>		o:SValuesS(i,obj:tostring()) ~<10>		end~<10>	end~<10>result = p:ToStr()~<10>return result~<10>end~<10|10>function TipCon:LoadfromString( astring , direct) -- set direct to false if the message doesn't came from the original computer...~<10>-- adding a new con~<10>local p = ehtf.THTNode()~<10>local o = nil~<10>local aint = 0~<10>local cur = nil~<10>local astr = ~<34|34|10>local i,obj = 0,nil~<10>local i2,obj2 = 0,nil~<10>local a,b,c = 0~<10>local dochange = direct or (direct == nil) or (not self.meta_own)~<10|10>p:FromStr( astring )~<10>o = p:FindAboutC(~<34>ip~<34>)~<10>if o then~<10>	aint = o:SValuesI(1)~<10>	if aint == os.computerID() then -- Nobody says what you should think :)~<10>		return OwnIP~<10>		end~<10>	end~<10>	~<10>-- Search CON and Add to current or create new~<10>for i,obj in ipairs(self.con) do~<10>	if obj.ip == aint then~<10>		cur = obj~<10>		-- delet current conections if cur...~<10>		if dochange then~<10>			cur.con = vec3.TList()~<10>			end~<10>		break~<10>		end~<10>	end~<10>if cur == nil then~<10>	a,cur,c = OwnIP:GetDHCP(aint) -- currently only 1 instance but only one pointer~<10>	if cur then~<10>		--vec3.AddCon(cur.parents,self)~<10>		--vec3.AddCon(self.con,cur)~<10>		end~<10>	end~<10>if cur == nil then~<10>	cur = self:Add(aint)~<10>	end~<10|10>if dochange then~<10>	if direct then ~<10>		-- attention, once it is true it can't be false any more... Currently the Con wil be deletet if it is not in direct range, so it will be set again to false...~<10>		cur.meta_own = true~<10>		end~<10>	cur.ip = aint~<10>	o = p:FindAboutC(~<34>server~<34>)~<10>	if o then~<10>		cur.server = (o:SValuesB(1) or (vec3.contains(trustDHCP,aint))) -- ich glaub dem Sender einfach mal das er vertrauenswürdig ist...~<10>		end~<10>	o = p:FindAboutC(~<34>moving~<34>)~<10>	if o then~<10>		cur.moving = o:SValuesB(1) -- ich glaub dem Sender einfach mal das er vertrauenswürdig ist...~<10>		end~<10>	o = p:FindAboutC(~<34>pos~<34>)~<10>	if o then~<10>		cur.pos = {o:SValuesI(1), o:SValuesI(2), o:SValuesI(3)}~<10>		end~<10>	end~<10>o = p:FindAboutC(~<34>con~<34>)~<10>if o then~<10>	for i2,obj2 in ipairs(o.nodes) do~<10>		cur:LoadfromString( obj2:ToStr() , false)		~<10>		end~<10>	end~<10>	~<10>return cur~<10>end~<10|10>function TipCon:GetDHCP_C(_ip) -- only search childs... --parentClass, selfClass , pos~<10>for i,obj in ipairs(self.con) do~<10>	if tostring(obj.ip) == tostring(_ip) then~<10>		return self , obj , i~<10>		end~<10>	end~<10>return nil , nil , -1~<10>end~<10|10|10>function TipCon:GetDHCP(_ip) --parentClass, selfClass , pos~<10>for i,obj in ipairs(self.con) do~<10>	if tostring(obj.ip) == tostring(_ip) then~<10>		return self , obj , i~<10>		end~<10>	end~<10>for i,obj in ipairs(self.con) do~<10>	local a,b,c = obj:GetDHCP(_ip)~<10>	if b then~<10>		return a , b , c~<10>		end~<10>	end~<10>return nil , nil , -1~<10>end~<10|10>function TipCon:GetSendDHCP(_ip) -- ParentIP or _ip , parent of IP, selfClass of IP~<10>for i,obj in ipairs(self.con) do~<10>	if tostring(obj.ip) == tostring(_ip) then~<10>		return _ip , self , obj , i~<10>		end~<10>	end~<10>for i,obj in ipairs(self.con) do~<10>	local a,b,c = obj:GetDHCP(_ip)~<10>	if b then~<10>		return obj.ip , obj , b , c~<10>		end~<10>	end~<10>return _ip , nil , nil , -1~<10>end~<10|10>function GetDHCP(_ip)~<10>-- ändert self~<10>local a,b,c = OwnIP:GetDHCP(_ip)~<10>if c == OwnIP then~<10>	a = _ip~<10>	b = true~<10>	c = self~<10>	end~<10>return a,b,c~<10>end~<10|10>function StandartRegister()~<10>trustDHCP = {}~<10>DNS = {}~<10|10>local i,obj = 0,nil~<10>local p = ehtf.THTNode()~<10>local o,o2 = nil,nil~<10>p:LoadfromFile(path.C(path.DATA(),~<34>ip/settings~<34>))~<10>o = p:FindAboutC(~<34>DHCP~<34>)~<10>if o then~<10>	for i,obj in ipairs(o.Values) do~<10>		trustDHCP[i] = o:SValuesI(i)~<10>		end~<10>	end~<10>o = p:FindAboutC(~<34>DNS~<34>)~<10>if o then~<10>	for i,obj in ipairs(o.nodes) do~<10>		DNS[i] = {tostring(obj.about), tonumber(obj:SValuesI(i))}~<10>		end~<10>	end~<10>end~<10|10>function GetIP(_dns)~<10>local i,obj = 0~<10>for i,obj in ipairs(DNS) do~<10>	if obj[1] and (string.lower(obj[1]) == string.lower(_dns or ~<34|34>) )then~<10>		return tonumber(obj[2])~<10>		end~<10>	end~<10>return (tonumber(_dns) or _dns)~<10>end~<10|10>function Legal(_sender)~<10>local a,b = vec3.contains(trustDHCP,_sender)~<10>return a~<10>end~<10|10>function HasModem()~<10>local i,obj = 0~<10>for i,obj in ipairs(mperipheral.Peripherals) do~<10>    if obj.type == ~<34>modem~<34> then~<10>	   return true~<10>       end~<10>    end~<10>return false~<10>end~<10|10>function Ping(_ServerIP)~<10>SendMessage(nil,_ServerIP,nil,-1,~<34>Ping~<34>,tostring(os.time()))~<10>end~<10|10>function PingAll()~<10>SendMessage(nil,nil,nil,-1,~<34>Ping~<34>,tostring(os.time()))~<10>end~<10|10>function DHCPMessage(_ClientIP , _ServerIP , _DHCP ,_port, _meta , _msg)~<10>local result = false~<10>local i = GetIP(_ServerIP)~<10|10>-- Checken ob Ping~<10>if (tonumber(_port) == -1) and ((_ServerIP == ~<34|34>) or (tonumber(os.computerID()) == tonumber(i))) then~<10>	SendMessage(nil, _ClientIP, nil,-2,_meta, _msg .. ~<34> ~<34> ..tostring(os.time()))~<10>	result = true~<10>-- Checken ob DHCP~<10>elseif (tonumber(os.computerID()) ~<126>= tonumber(i)) and (_ServerIP ~<126>= ~<34|34>) then~<10>	SendMessage(_ClientIP, _ServerIP, nil,_port,_meta, _msg)~<10>	result = true~<10>	end~<10>	~<10>	~<10>return result~<10>end~<10|10|10>function SendMessage(_ClientIP, _ServerIP, _DHCP,_port,_meta, _msg)~<10>if _ClientIP ~<126>= nil then _ClientIP = GetIP(_ClientIP) end~<10>_ServerIP = GetIP(_ServerIP)~<10>RawSendMessage(_ClientIP, _ServerIP, _DHCP,_port,_meta, _msg)~<10>end~<10|10>function RawSendMessage(_ClientIP, _ServerIP, _DHCP,_port,_meta, _msg)~<10>local tosend = ~<34|34> ~<10>local toall = (_ServerIP == nil)~<10>local b = true~<10>if _ClientIP == nil then _ClientIP = tonumber(os.computerID()) end~<10>if (_DHCP == nil) and (not toall) then ~<10>	_DHCP,b = OwnIP:GetSendDHCP(_ServerIP)~<10>	end~<10>if _msg and _ClientIP and (_DHCP or toall) then ~<10>	tosend = string.len(_ClientIP  or ~<34|34>) .. ~<34>/~<34> .. ~<10>			 string.len(_ServerIP  or ~<34|34>) .. ~<34>/~<34> .. ~<10>			 string.len(_port  or ~<34|34>) .. ~<34>/~<34> .. ~<10>			 string.len(_meta  or ~<34|34>) .. ~<34>/~<34> .. ~<10>			 (_ClientIP or ~<34|34>) .. ~<10>			 (_ServerIP or ~<34|34>) .. ~<10>			 (_port or ~<34|34>) .. ~<10>			 (_meta or ~<34|34>) .. ~<10>			 (_msg or ~<34|34>)~<10>	if toall then ~<10>		rednet.broadcast(tosend)~<10>		else~<10>		rednet.send(tonumber(_DHCP or 0),tosend)~<10>		end~<10>	return true , _ClientIP, _ServerIP, _DHCP,_port,_meta, _msg~<10>	else~<10>	return false , _ClientIP, _ServerIP, _DHCP,_port,_meta, _msg~<10>	end~<10>end~<10|10|10>function GetMessage(_rawmsg)~<10>local a,b,c,d = ~<34|34|10>local _ServerIP = ~<34|34|10>local _ClientIP = ~<34|34|10>local _msg = ~<34|34|10>local begin,begin2,begin3,begin4,begin5  = 0~<10>local _meta = ~<34|34|10>local _port = ~<34|34|10>local nr1,nr2,nr3,nr4 = 0~<10>for a,b,c,d in string.gmatch(_rawmsg, ~<34>(%w+)/(%w+)/(%w+)/(%w+)/~<34>) do~<10>	~<10>	nr1 = tonumber(a)~<10>	nr2 = tonumber(b)~<10>	nr3 = tonumber(c)~<10>	nr4 = tonumber(d)~<10>	if nr1 == nil then return ~<34>Error~<34>,nil,nil,nil,nil,false end~<10>	if nr2 == nil then return nil,~<34>Error~<34>,nil,nil,nil,false end~<10>	if nr3 == nil then return nil,nil,~<34>Error~<34>,nil,nil,false end~<10>	if nr4 == nil then return nil,nil,nil,~<34>Error~<34>,nil,false end~<10>	~<10>	begin = string.len(a..~<34>/~<34>..b..~<34>/~<34>..c..~<34>/~<34>..d..~<34>/~<34>)~<10>	begin2 = begin + nr1~<10>	begin3 = begin2 + nr2~<10>	begin4 = begin3 + nr3~<10>	begin5 = begin4 + nr4~<10>	_ClientIP = string.sub(_rawmsg,begin+1,begin2)~<10>	_ServerIP = string.sub(_rawmsg,begin2+1,begin3)~<10>	_port = string.sub(_rawmsg,begin3+1,begin4)~<10>	_meta = string.sub(_rawmsg,begin4+1,begin5)~<10>	_msg = string.sub(_rawmsg,begin5+1)~<10>	return _ClientIP , _ServerIP , _port, _meta , _msg  , true~<10>	end~<10>return nil,nil,nil,nil,nil,false~<10>end~<10|10>OwnIP = TipCon(tonumber(os.getComputerID()))~<10|10>function API_Initial()~<10>StandartRegister()~<10>new = events.CreateEvent(~<34>Initialised~<34>,~<34>ip~<34>, ~<34>ip~<34>)~<10>mTask.RawRaiseEvent(new)~<10>end~<10>>>file<0||name<0|lps>path<0|marcelOS/apis/lps>data<0|-- marcelOS functions~<10>local pos = {0,64,0}~<10>local richtung = {1,0,0}~<10|10>boot.BootMsg(~<34>starting lps~<34>)~<10|10>function InvStacks()~<10>local i = 0~<10>local result = 0~<10>for i = 1,9 do~<10>	if turtle.getItemCount( i ) == 0 then result = result + 1 end ~<10>	end~<10>return result~<10>end~<10|10>function Reset(_pos , _richtung)~<10>local i = 0~<10>if _pos then~<10>	for i in ipairs(pos) do pos[i] = _pos[i]end~<10>	end~<10>if _richtung then~<10>	for i in ipairs(richtung) do richtung[i] = _richtung[i] end~<10>	end~<10>boot.BootMsg(ShowPos())~<10>end~<10|10>function ShowPos()~<10>return ~<34>Pos: ~<34> .. pos[1] .. ~<34> ~<34> .. pos[2] .. ~<34> ~<34> .. pos[3] .. ~<34> Richtung: ~<34> .. richtung[1] .. ~<34> ~<34> .. richtung[2] .. ~<34> ~<34> .. richtung[3]~<10>end~<10|10>local function geh()~<10>local i = 0~<10>pos = vec3.ADD(pos,richtung)~<10>end~<10|10>function dRechts()~<10>local a,b = 0~<10>a = richtung[1]~<10>b = richtung[3]~<10>richtung[1] = -b~<10>richtung[3] = a~<10>turtle.turnRight()~<10>end~<10|10>function dLinks()~<10>local a,b = 0~<10>a = richtung[1]~<10>b = richtung[3]~<10>richtung[1] = b~<10>richtung[3] = -a~<10>turtle.turnLeft()~<10>end~<10|10>function Vec( _vec )~<10>return {tonumber(_vec[1]),tonumber(_vec[2]),tonumber(_vec[3])}~<10>end~<10|10>function CorDreh( _richtung )~<10>local i = 1~<10>for i = 1,3 do~<10>	if tonumber(_richtung[i]) ~<62> 1 then _richtung[i]  = 1 end~<10>	if tonumber(_richtung[i]) ~<60> -1 then _richtung[i]  = -1 end~<10>	end~<10>if (tonumber(_richtung[1]) == 0) and (tonumber(_richtung[3]) == 0) then _richtung[1] = 1 end~<10>return Vec(_richtung)~<10>end~<10|10>function Dreheauf(_richtung)~<10>if ((-richtung[1] == _richtung[3]) and (richtung[3] == _richtung[1])) then dLinks() end~<10>while ((richtung[1] ~<126>= _richtung[1]) or (richtung[3] ~<126>= _richtung[3])) do dRechts() end~<10>end~<10|10>function Fplus( _max )~<10>local i = 0~<10>if not _max then~<10>	local _max = 100~<10>	end~<10>	~<10>while not turtle.forward() do~<10>	i = i + 1~<10>	if (i~<62>_max) then return false end~<10>	turtle.dig()~<10>	end~<10>geh()~<10>return true~<10>end~<10|10>function FUpplus( _max )~<10>local i = 0~<10>if not _max then~<10>	local _max = 100~<10>	end~<10>while not turtle.up() do~<10>	i = i + 1~<10>	if (i~<62>_max) then return false end~<10>	turtle.digUp()~<10>	end~<10>pos[2] = pos[2] + 1~<10>return true~<10>end~<10|10|10>function FDownplus( _max )~<10>local i = 0~<10>if not _max then~<10>	local _max = 100~<10>	end~<10>while not turtle.down() do~<10>	i = i + 1~<10>	if (i~<62>_max) then return false end~<10>	turtle.digDown()~<10>	end~<10>pos[2] = pos[2] - 1~<10>return true~<10>end~<10|10>function GOXZ( _length , _max)~<10>for i = 1,_length do ~<10>	if (not Fplus(_max)) then break end ~<10>	end~<10>end~<10|10>function GOX( _length , _max)~<10>if _length ~<62> 0 then~<10>	Dreheauf({1,0,0})~<10>	else~<10>	Dreheauf({-1,0,0})~<10>	_length = - _length~<10>	end~<10>GOXZ(_length , _max)~<10>end~<10|10>function GOZ( _length , _max)~<10>if _length ~<62> 0 then~<10>	Dreheauf({0,0,1})~<10>	else~<10>	Dreheauf({0,0,-1})~<10>	_length = - _length~<10>	end~<10>GOXZ(_length , _max)~<10>end~<10|10>function GOY( _length , _max)~<10>if _length ~<62> 0 then~<10>	for i = 1,_length do ~<10>		if (not FUpplus(_max)) then break end ~<10>		end~<10>	else~<10>	_length = - _length~<10>	for i = 1,_length do ~<10>		if (not FDownplus(_max)) then break end ~<10>		end~<10>	end~<10>end~<10|10>function TurtleGO(_str)~<10>local i = 0~<10>local c = {}~<10|10>local fak = 0~<10>local mult =0 ~<10>--for a in string.gmatch(_str, ~<34>%w+~<34>) do c[#c+1] = string.lower(a) print(a) end~<10>c = mStrings.split(_str , ~<34> ~<34>)~<10>for i in ipairs(c) do ~<10>	c[i] = string.lower(c[i])~<10>	end~<10|10>if (c[2] ~<126>= ~<34>d~<34>) then fak = 0 end~<10>if (c[2] == ~<34>g~<34>) then fak = 100 end~<10>if (c[3] == nil) then c[3] = c[2] end~<10>mult = (tonumber(c[3]) or 1)~<10|10>boot.BootMsg(~<34|34>)~<10>for i in ipairs(c) do ~<10>	boot.BootMsg(c[i]) ~<10>	end~<10|10|10>if c[1] == ~<34>f~<34> then~<10>	boot.BootMsg(~<34>GETTA~<34>)~<10>	if (c[2] == ~<34>d~<34>) then ~<10>		turtle.dig()~<10>    	else~<10>		GOXZ(mult , fak)~<10>		end~<10>elseif c[1] == ~<34>b~<34> then~<10>	dRechts()~<10>	dRechts()~<10>	if (c[2] == ~<34>d~<34>) then ~<10>		turtle.dig()~<10>    	else~<10>		GOXZ(mult , fak)~<10>		end~<10>elseif c[1] == ~<34>x~<34> then~<10>	GOX( mult , fak)~<10>elseif c[1] == ~<34>y~<34> then~<10>	GOY( mult , fak)~<10>elseif c[1] == ~<34>z~<34> then~<10>	GOZ( mult , fak)~<10>elseif c[1] == ~<34>l~<34> then~<10>	for i = 1,mult do dLinks() end~<10>elseif c[1] == ~<34>r~<34> then~<10>	for i = 1,mult do dRechts() end~<10>elseif c[1] == ~<34>u~<34> then~<10>	if (c[2] == ~<34>d~<34>) then ~<10>		turtle.digUp()~<10>    	else~<10>		for i = 1,mult do FUpplus(fak) end~<10>		end~<10>elseif c[1] == ~<34>d~<34> then~<10>	if (c[2] == ~<34>d~<34>) then ~<10>		turtle.digDown()~<10>    	else~<10>		for i = 1,mult do FDownplus(fak) end~<10>		end~<10>elseif c[1] == ~<34>dr~<34> then~<10>	Dreheauf(CorDreh({c[2],0,c[3]}))~<10>elseif c[1] == ~<34>m~<34> then~<10>	Move(Vec({c[2],c[3],c[4]}),CorDreh({c[5],c[6],c[7]}),100)~<10>elseif c[1] == ~<34>mt~<34> then~<10>	MoveTo(Vec({c[2],c[3],c[4]}),CorDreh({c[5],c[6],c[7]}),100)~<10>elseif c[1] == ~<34>reset~<34> then~<10>	Reset(Vec({c[2],c[3],c[4]}),CorDreh({c[5],c[6],c[7]}))~<10>	end~<10>end~<10|10>function Move(_pos , _fak)~<10>GOX(_pos[1] , _fak)~<10>GOY(_pos[2] , _fak)~<10>GOZ(_pos[3] , _fak)~<10>end~<10|10>function MoveR(_pos , _richtung , _fak)~<10>Move(_pos , _fak)~<10>Dreheauf(_richtung)~<10>end~<10|10>function MoveTo(_pos , _fak)~<10>GOX(_pos[1]-pos[1] , _fak)~<10>GOY(_pos[2]-pos[2] , _fak)~<10>GOZ(_pos[3]-pos[3] , _fak)~<10>end~<10|10>function MoveToR(_pos , _richtung , _fak)~<10>MoveTo(_pos , _fak)~<10>Dreheauf(_richtung)~<10>end~<10|10>function API_Initial()~<10>local file = fs.open(path.C(path.DATA(),~<34>lps/pos~<34>),~<34>r~<34>)~<10>local sLine = file:readLine()~<10>if sLine then~<10>	pos = mStrings.split(sLine,~<34> ~<34>)~<10>	end~<10>sLine = file:readLine()~<10>if sLine then~<10>	richtung = mStrings.split(sLine,~<34> ~<34>)~<10>	end	~<10>file:close()~<10|10>local new = events.CreateEvent(~<34>Initialised~<34>,~<34>lps~<34>, ~<34>lps~<34>)~<10>mTask.RawRaiseEvent(new)~<10>end~<10>>>file<0||name<0|md5>path<0|marcelOS/apis/md5>data<0|#!/usr/bin/env lux~<10|10>-- An MD5 mplementation in Lua, requires bitlib~<10>-- 10/02/2001 jcw@equi4.com~<10|10>-- FAST HASH, but the results are wrong, there is an error somewhere...~<10|10>local ff=4294967295~<10>local consts={}~<10|10>string.gsub([[ d76aa478 e8c7b756 242070db c1bdceee~<10>	f57c0faf 4787c62a a8304613 fd469501~<10>	698098d8 8b44f7af ffff5bb1 895cd7be~<10>	6b901122 fd987193 a679438e 49b40821~<10>	f61e2562 c040b340 265e5a51 e9b6c7aa~<10>	d62f105d 02441453 d8a1e681 e7d3fbc8~<10>	21e1cde6 c33707d6 f4d50d87 455a14ed~<10>	a9e3e905 fcefa3f8 676f02d9 8d2a4c8a~<10>	fffa3942 8771f681 6d9d6122 fde5380c~<10>	a4beea44 4bdecfa9 f6bb4b60 bebfbc70~<10>	289b7ec6 eaa127fa d4ef3085 04881d05~<10>	d9d4d039 e6db99e5 1fa27cf8 c4ac5665~<10>	f4292244 432aff97 ab9423a7 fc93a039~<10>	655b59c3 8f0ccc92 ffeff47d 85845dd1~<10>	6fa87e4f fe2ce6e0 a3014314 4e0811a1~<10>	f7537e82 bd3af235 2ad7d2bb eb86d391~<10>	67452301 efcdab89 98badcfe 10325476 ]],~<10>  '(%w+)', function (s) table.insert(consts,tonumber(s,16)) end)~<10>  ~<10>function base(x)~<10>while x ~<62> ff do~<10>	x = x - ff~<10>	end~<10>while x ~<60> 0 do~<10>	x = x + ff~<10>	end~<10>return x~<10>end~<10|10>function transform(A,B,C,D)~<10>  local f=function (x,y,z) return  bit.bor(base(bit.band(x,y)),base(bit.band(base(-x-1),z))) end~<10>  local g=function (x,y,z) return bit.bor(base(bit.band(x,z)),base(bit.band(y,base(-z-1)))) end~<10>  local h=function (x,y,z) return bit.bxor(x,bit.bxor(y,z)) end~<10>  local i=function (x,y,z) return bit.bxor(y,bit.bor(x,base(-z-1))) end~<10>  local z=function (f,a,b,c,d,x,s,ac)~<10>		local p1 = base(a+f(b,c,d)+x+ac)~<10>	    a=bit.band(p1,ff)~<10>	    -- be *very* careful that left shift does not cause rounding!~<10>	    return base(bit.bor(bit.blshift(bit.band(a,bit.brshift(ff,s)),s),bit.brshift(a,32-s))+b)~<10>	  end~<10>  local a,b,c,d=base(A),base(B),base(C),base(D)~<10>  local t=consts~<10|10>  a=z(f,a,b,c,d,X[ 0], 7,t[ 1])~<10>  d=z(f,d,a,b,c,X[ 1],12,t[ 2])~<10>  c=z(f,c,d,a,b,X[ 2],17,t[ 3])~<10>  b=z(f,b,c,d,a,X[ 3],22,t[ 4])~<10>  a=z(f,a,b,c,d,X[ 4], 7,t[ 5])~<10>  d=z(f,d,a,b,c,X[ 5],12,t[ 6])~<10>  c=z(f,c,d,a,b,X[ 6],17,t[ 7])~<10>  b=z(f,b,c,d,a,X[ 7],22,t[ 8])~<10>  a=z(f,a,b,c,d,X[ 8], 7,t[ 9])~<10>  d=z(f,d,a,b,c,X[ 9],12,t[10])~<10>  c=z(f,c,d,a,b,X[10],17,t[11])~<10>  b=z(f,b,c,d,a,X[11],22,t[12])~<10>  a=z(f,a,b,c,d,X[12], 7,t[13])~<10>  d=z(f,d,a,b,c,X[13],12,t[14])~<10>  c=z(f,c,d,a,b,X[14],17,t[15])~<10>  b=z(f,b,c,d,a,X[15],22,t[16])~<10|10>  a=z(g,a,b,c,d,X[ 1], 5,t[17])~<10>  d=z(g,d,a,b,c,X[ 6], 9,t[18])~<10>  c=z(g,c,d,a,b,X[11],14,t[19])~<10>  b=z(g,b,c,d,a,X[ 0],20,t[20])~<10>  a=z(g,a,b,c,d,X[ 5], 5,t[21])~<10>  d=z(g,d,a,b,c,X[10], 9,t[22])~<10>  c=z(g,c,d,a,b,X[15],14,t[23])~<10>  b=z(g,b,c,d,a,X[ 4],20,t[24])~<10>  a=z(g,a,b,c,d,X[ 9], 5,t[25])~<10>  d=z(g,d,a,b,c,X[14], 9,t[26])~<10>  c=z(g,c,d,a,b,X[ 3],14,t[27])~<10>  b=z(g,b,c,d,a,X[ 8],20,t[28])~<10>  a=z(g,a,b,c,d,X[13], 5,t[29])~<10>  d=z(g,d,a,b,c,X[ 2], 9,t[30])~<10>  c=z(g,c,d,a,b,X[ 7],14,t[31])~<10>  b=z(g,b,c,d,a,X[12],20,t[32])~<10|10>  a=z(h,a,b,c,d,X[ 5], 4,t[33])~<10>  d=z(h,d,a,b,c,X[ 8],11,t[34])~<10>  c=z(h,c,d,a,b,X[11],16,t[35])~<10>  b=z(h,b,c,d,a,X[14],23,t[36])~<10>  a=z(h,a,b,c,d,X[ 1], 4,t[37])~<10>  d=z(h,d,a,b,c,X[ 4],11,t[38])~<10>  c=z(h,c,d,a,b,X[ 7],16,t[39])~<10>  b=z(h,b,c,d,a,X[10],23,t[40])~<10>  a=z(h,a,b,c,d,X[13], 4,t[41])~<10>  d=z(h,d,a,b,c,X[ 0],11,t[42])~<10>  c=z(h,c,d,a,b,X[ 3],16,t[43])~<10>  b=z(h,b,c,d,a,X[ 6],23,t[44])~<10>  a=z(h,a,b,c,d,X[ 9], 4,t[45])~<10>  d=z(h,d,a,b,c,X[12],11,t[46])~<10>  c=z(h,c,d,a,b,X[15],16,t[47])~<10>  b=z(h,b,c,d,a,X[ 2],23,t[48])~<10|10>  a=z(i,a,b,c,d,X[ 0], 6,t[49])~<10>  d=z(i,d,a,b,c,X[ 7],10,t[50])~<10>  c=z(i,c,d,a,b,X[14],15,t[51])~<10>  b=z(i,b,c,d,a,X[ 5],21,t[52])~<10>  a=z(i,a,b,c,d,X[12], 6,t[53])~<10>  d=z(i,d,a,b,c,X[ 3],10,t[54])~<10>  c=z(i,c,d,a,b,X[10],15,t[55])~<10>  b=z(i,b,c,d,a,X[ 1],21,t[56])~<10>  a=z(i,a,b,c,d,X[ 8], 6,t[57])~<10>  d=z(i,d,a,b,c,X[15],10,t[58])~<10>  c=z(i,c,d,a,b,X[ 6],15,t[59])~<10>  b=z(i,b,c,d,a,X[13],21,t[60])~<10>  a=z(i,a,b,c,d,X[ 4], 6,t[61])~<10>  d=z(i,d,a,b,c,X[11],10,t[62])~<10>  c=z(i,c,d,a,b,X[ 2],15,t[63])~<10>  b=z(i,b,c,d,a,X[ 9],21,t[64])~<10|10>  return A+a,B+b,C+c,D+d~<10>end~<10|10>function beInt(s)~<10>local v=0~<10>for i=1,string.len(s) do v=v*256+string.byte(s,i) end~<10>return v~<10>end~<10>-- convert raw string to little-endian int~<10>function leInt(s)~<10>local v=0~<10>for i=string.len(s),1,-1 do v=v*256+string.byte(s,i) end~<10>return v~<10>end~<10>-- cut up a string in little-endian ints of given size~<10>function leStrCuts(s,...)~<10>local o,r=1,{}~<10>for i=1,#arg do~<10>  table.insert(r,leInt(string.sub(s,o,o+arg[i]-1)))~<10>  o=o+arg[i]~<10>end~<10>return r~<10>end~<10|10>function md5(s)~<10>  local msgLen=string.len(s)~<10>  local padLen=56-(msgLen % 64)~<10>  if (msgLen % 64)~<62>56 then padLen=padLen+64 end~<10>  if padLen==0 then padLen=64 end~<10>  s=s..string.char(128)..string.rep(string.char(0),padLen-1)~<10>  s=s..leIstr(8*msgLen)..leIstr(0)~<10>  local t=consts~<10>  local a,b,c,d=t[65],t[66],t[67],t[68]~<10>  for i=1,string.len(s),64 do~<10>    X=leStrCuts(string.sub(s,i,i+63),4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4)~<10>    X[0]=table.remove(X,1) -- zero based!~<10>    a,b,c,d=transform(a,b,c,d)~<10>  end~<10>  local swap=function (w) return beInt(leIstr(w)) end~<10>  return string.format(~<34>%08x%08x%08x%08x~<34>,swap(a),swap(b),swap(c),swap(d))~<10>end~<10|10>-- convert little-endian 32-bit int to a 4-char string~<10>function leIstr(i)~<10>  local f=function (s) ~<10>  return string.char(~<10>  bit.band(base(base(bit.brshift(i,s))),255)~<10>  ) ~<10>  end~<10>  i = base(i)~<10>  return f(0)..f(8)..f(16)..f(24)~<10>end~<10|10>  --[[  ~<10>s0='message digest'~<10>s1='abcdefghijklmnopqrstuvwxyz'~<10>s2='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'~<10>s3='1234567890123456789012345678901234567890'..'1234567890123456789012345678901234567890'~<10|10>print(md5(~<34|34>)=='d41d8cd98f00b204e9800998ecf8427e')~<10>    print(md5(~<34>a~<34>)=='0cc175b9c0f1b6a831c399e269772661')~<10>    print(md5(~<34>abc~<34>)=='900150983cd24fb0d6963f7d28e17f72')~<10>    print(md5(s0)=='f96b697d7cb7938d525a2f31aaf161d0')~<10>    print(md5(s1)=='c3fcd3d76192e4007dfb496cca67e13b')~<10>    print(md5(s2)=='d174ab98d277d9f5a5611c2c9f419d9f')~<10>    print(md5(s3)=='57edf4a22be3c955ac49da2e2107b67a')~<10>	~<10>	print(~<34>DD~<34>)~<10>    print(md5(~<34|34>))~<10>    print(md5(~<34>a~<34>))~<10>    print(md5(~<34>abc~<34>))~<10>    print(md5(s0))~<10>    print(md5(s1))~<10>    print(md5(s2))~<10>    print(md5(s3))~<10|10>if 1 then ~<10>  sizes={10,50,100,500,1000,5000,10000}~<10>  for i=1,#sizes do~<10>    local s=string.rep(' ',sizes[i])~<10>    local t=os.clock()~<10>    for j=1,10 do~<10>      md5(s)~<10>    end~<10>    print(string.format('%6d bytes: %4d mSec',sizes[i],(os.clock()-t)*100))~<10>  end~<10>end~<10>sleep(5)--]]>>file<0||name<0|mgps>path<0|marcelOS/apis/mgps>data<0|-- marcelOS functions~<10>local pos = {0,64,0}~<10>local orientation = 0 -- internal minecraft orientation... 0 = positiv z    1 = negative x      2 = negative z    3 = positive x~<10|10>-- additional~<10>local lastmove = -1~<10>local lastcheckGPS = -1~<10>local lastmovedir = {0,0,0}~<10|10>-- setting~<10>local lastmovetimeout = 15 -- after 15 sec of not moving -~<62> standing still ~<10>local lastmovemaxdif = 1 -- if standing still, max movement = 1 meters of cur pos~<10>local normalmovedif = 100~<10>local maxmapheight = 260~<10>local digmode = false~<10>local notmoving = true -- activate this, if you are sure, the turtle won't ever move ! Event not with RP Frames or Piston~<10>local realtimebackup = false -- may save a lot and cause a lot of harddrive operations ...~<10|10>boot.BootMsg(~<34>starting mgps~<34>)~<10|10>function GetPos()~<10>local x = vec3.Copy(pos)~<10>return x~<10>end~<10|10>function SetDigmode(_abool)~<10>digmode = _abool~<10>end~<10|10>function GetDigmode(_abool)~<10>return digmode~<10>end~<10|10>function GetOrientation()~<10>local x = orientation~<10>return x~<10>end~<10|10>function GetMovement()~<10>local x = {0,0,0}~<10>if orientation == 0 then x = {0,0,1}~<10>	elseif orientation == 1 then x = {-1,0,0}~<10>		elseif orientation == 2 then x = {0,0,-1}~<10>			elseif orientation == 3 then x = {1,0,0} end~<10>return x~<10>end~<10|10>function SetPos(apos,aorientation)~<10>if apos then ~<10>	pos = vec3.Copy(apos)~<10>	end~<10>if aorientation then~<10>	orientation = aorientation~<10>	end~<10>end~<10|10>--[[ STEAL :D ]]~<10>function trilaterate( A, B, C )~<10|10>	local a2b = B.position - A.position~<10>	local a2c = C.position - A.position~<10>		~<10>	if math.abs( a2b:normalize():dot( a2c:normalize() ) ) ~<62> 0.999 then~<10>		return nil~<10>	end~<10>	~<10>	local d = a2b:length()~<10>	local ex = a2b:normalize( )~<10>	local i = ex:dot( a2c )~<10>	local ey = (a2c - (ex * i)):normalize()~<10>	local j = ey:dot( a2c )~<10>	local ez = ex:cross( ey )~<10|10>	local r1 = A.distance~<10>	local r2 = B.distance~<10>	local r3 = C.distance~<10>		~<10>	local x = (r1*r1 - r2*r2 + d*d) / (2*d)~<10>	local y = (r1*r1 - r3*r3 - x*x + (x-i)*(x-i) + j*j) / (2*j)~<10>		~<10>	local result = A.position + (ex * x) + (ey * y)~<10|10>	local zSquared = r1*r1 - x*x - y*y~<10>	if zSquared ~<62> 0 then~<10>		local z = math.sqrt( zSquared )~<10>		local result1 = result + (ez * z)~<10>		local result2 = result - (ez * z)~<10>		~<10>		local rounded1, rounded2 = result1:round(), result2:round()~<10>		if rounded1.x ~<126>= rounded2.x or rounded1.y ~<126>= rounded2.y or rounded1.z ~<126>= rounded2.z then~<10>			return result1, result2~<10>		else~<10>			return rounded1~<10>		end~<10>	end~<10>	return result:round()~<10>	~<10>end~<10|10>function narrow( p1, p2, fix )~<10>	local dist1 = math.abs( (p1 - fix.position):length() - fix.distance )~<10>	local dist2 = math.abs( (p2 - fix.position):length() - fix.distance )~<10>	~<10>	if math.abs(dist1 - dist2) ~<60> 0.05 then~<10>		return p1, p2~<10>	elseif dist1 ~<60> dist2 then~<10>		return p1:round()~<10>	else~<10>		return p2:round()~<10>	end~<10>end~<10|10|10|10|10>function ComputePos()~<10>if notmoving then~<10>	-- NO I'm not Moving, so why compute this all :)~<10>	return pos,true~<10>	end~<10>local curpos = vector.new( pos[1] , pos[2] , pos[3])~<10>local goodpos = {}~<10>local i,obj = 0,nil~<10>local result = false~<10>for i,obj in ipairs(ip.OwnIP.con) do~<10>	if obj.lastping ~<62>= lastmove then~<10>		goodpos[#goodpos+1] = obj~<10>		end~<10>	end~<10>print(~<34>available PCs ~<34> .. tostring(#goodpos))~<10|10>if #goodpos ~<62>= 3 then~<10>	--[[  Copied from Original :) ]]~<10>	~<10>	local tFixes = {}~<10>	local p1, p2 = nil~<10>	local i,obj = 1,nil~<10>	while i ~<60>= #goodpos  and (p1 == nil or p2 ~<126>= nil) do~<10>		obj = goodpos[i]~<10>		local tFix = { id = obj.id, position = vector.new( obj.pos[1], obj.pos[2], obj.pos[3] ), distance = obj.entf }~<10>		table.insert( tFixes, tFix )~<10>		if #tFixes ~<62>= 3 then~<10>			if not p1 then~<10>				p1, p2 = trilaterate( tFixes[1], tFixes[2], tFixes[#tFixes] )~<10>				else~<10>				p1, p2 = narrow( p1, p2, tFixes[#tFixes] )~<10>				end~<10>			end~<10>		i = i + 1~<10>		end~<10>	if p1 then~<10>		p1 = p1:round()~<10>		end~<10>	if p1 and p2 then~<10>		-- Could be both, p1 or p2 !!!~<10>		p2 = p2:round()~<10>		local p1a = (p1 - curpos):length() ~<10>		local p2a = (p2 - curpos):length() ~<10>		if p1a ~<62> p2a then~<10>			p1 = p2 --change p1 and p2~<10>			p1a = p2a~<10>			end~<10>		p2 = nil~<10>		end~<10>	if p1 and (not p2) and (not(p1.x  ~<126>= p1.x)) and (not(p1.y  ~<126>= p1.y)) and (not(p1.z  ~<126>= p1.z)) and (p1.y ~<62>= 0) and (p1.y ~<60>= maxmapheight) then -- checking fpr nan :D~<10>		local maxdiff = nil~<10>		local p1a = (p1 - curpos):length() ~<10>		if (lastcheckGPS ~<62> 0) then~<10>			if (os.clock() - lastmove ~<60> lastmovetimeout) or (lastmove ~<60> lastmovetimeout) then~<10>				maxdiff = normalmovedif~<10>				else ~<10>				maxdiff = lastmovemaxdif~<10>				end~<10>			end~<10>		if (maxdiff == nil) or (p1a ~<60>= maxdiff) then~<10>			print( ~<34>Position is ~<34>..vec3.round(p1.x)..~<34>,~<34>..vec3.round(p1.y)..~<34>,~<34>..vec3.round(p1.z) )~<10>			pos = {vec3.round(p1.x), vec3.round(p1.y), vec3.round(p1.z)}~<10>			lastcheckGPS = os.clock()~<10>			ChangePos()~<10>			result = true~<10>			else~<10>			print(maxdiff)~<10>			print(p1a)~<10>			print(lastcheckGPS)~<10>			print( ~<34>Position is ~<34>..p1.x..~<34>,~<34>..p1.y..~<34>,~<34>..p1.z )~<10>			print( ~<34>Position was ~<34>..curpos.x..~<34>,~<34>..curpos.y..~<34>,~<34>..curpos.z )~<10>			print(~<34>You moved the Turtle to fast or Network error...~<34>)~<10>			end~<10>		~<10>		~<10>		end~<10>	end~<10|10>return pos,result~<10>-- Search all dircet OwnIP-PC's and search for their pos and their entf (need to be added!). Use not moving if you can ! ~<10>-- if not enough pc's in the nead and there are 4 different possibilities, chose the nearest to the current...~<10>end~<10|10>function ChangePos()~<10>local p = ehtf.THTNode()~<10>p:Add(~<34>pos~<34>,pos)~<10>p:Add(~<34>orientation~<34>,orientation)~<10>p:SavetoFile(path.C(path.DATA(),~<34>mgps/pos~<34>))~<10>ip.OwnIP.pos = pos~<10>lastmove = os.clock()~<10>end~<10|10>function InvStacks()~<10>local i = 0~<10>local result = 0~<10>for i = 1,9 do~<10>	if turtle.getItemCount( i ) == 0 then result = result + 1 end ~<10>	end~<10>return result~<10>end~<10|10>function forward()~<10>if digmode and turtle.detect() then~<10>	turtle.dig() ~<10>	end~<10>if turtle.forward() then~<10>	pos = vec3.Add(pos,GetMovement())~<10>	lastmove = os.clock()~<10>	if realtimebackup then~<10>		ChangePos()~<10>		end~<10>	return true~<10>	end~<10>return false~<10>end~<10|10>function back()~<10>if turtle.back() then~<10>	pos = vec3.Dec(pos,GetMovement())~<10>	lastmove = os.clock()~<10>	if realtimebackup then~<10>		ChangePos()~<10>		end~<10>	return true~<10>	end~<10>return false~<10>end~<10|10>function up(_sleep)~<10>if digmode and turtle.detectUp() then~<10>	turtle.digUp() ~<10>	end~<10>if turtle.up() then~<10>	pos[2] = pos[2] + 1~<10>	lastmove = os.clock()~<10>	if realtimebackup then~<10>		ChangePos()~<10>		end~<10>	return true~<10>	end~<10>return false~<10>end~<10|10>function down(_sleep)~<10>if digmode and turtle.detectDown() then~<10>	turtle.digDown()~<10>	end~<10>if turtle.down() then~<10>	pos[2] = pos[2] - 1~<10>	lastmove = os.clock()~<10>	if realtimebackup then~<10>		ChangePos()~<10>		end~<10>	return true~<10>	end~<10>return false~<10>end~<10|10>function turnLeft(_sleep)~<10>if turtle.turnLeft() then~<10>	if orientation ~<60>= 0 then~<10>		orientation = orientation - 1~<10>		else~<10>		orientation = 3 + orientation~<10>		end~<10>	return true~<10>	end~<10>return false~<10>end~<10|10>function turnRight(_sleep)~<10>if turtle.turnRight() then~<10>	if orientation ~<62>= 3 then~<10>		orientation = orientation - 3~<10>		else~<10>		orientation = orientation + 1~<10>		end~<10>	return true~<10>	end~<10>return false~<10>end~<10|10>function Left(_sleep)~<10>return (turnLeft() and forward())~<10>end~<10|10>function Right(_sleep)~<10>return (turnRight() and forward())~<10>end~<10|10|10|10>function API_Initial()~<10>local p = ehtf.THTNode()~<10>p:LoadfromFile(path.C(path.DATA(),~<34>mgps/pos~<34>))~<10>local o = p:FindAboutC(~<34>pos~<34>) ~<10>if o then~<10>	pos = {o:SValuesI(1),o:SValuesI(2),o:SValuesI(3)}~<10>	end~<10>o = p:FindAboutC(~<34>orientation~<34>) ~<10>if o then~<10>	orientation = o:SValuesI(1)~<10>	end~<10>if ip.OwnIP then ~<10>	ip.OwnIP.pos = pos ~<10>	end~<10>	~<10>p = ehtf.THTNode()~<10>p:LoadfromFile(path.C(path.DATA(),~<34>mgps/settings~<34>))~<10>o = p:FindAboutC(~<34>lastmovetimeout~<34>) ~<10>if o then~<10>	lastmovetimeout = o:SValuesI(1)~<10>	end~<10>o = p:FindAboutC(~<34>lastmovemaxdif~<34>) ~<10>if o then~<10>	lastmovemaxdif = o:SValuesI(1)~<10>	end~<10>o = p:FindAboutC(~<34>normalmovedif~<34>) ~<10>if o then~<10>	normalmovedif = o:SValuesI(1)~<10>	end~<10>o = p:FindAboutC(~<34>maxmapheight~<34>) ~<10>if o then~<10>	maxmapheight = o:SValuesI(1)~<10>	end	~<10>o = p:FindAboutC(~<34>digmode~<34>) ~<10>if o then~<10>	digmode = o:SValuesB(1)~<10>	end		~<10>o = p:FindAboutC(~<34>notmoving~<34>) ~<10>if o then~<10>	notmoving = o:SValuesB(1)~<10>	end			~<10>o = p:FindAboutC(~<34>realtimebackup~<34>) ~<10>if o then~<10>	realtimebackup = o:SValuesB(1)~<10>	end	~<10|10>local new = events.CreateEvent(~<34>Initialised~<34>,~<34>mgps~<34>, ~<34>mgps~<34>)~<10>mTask.RawRaiseEvent(new)~<10>end>>file<0||name<0|mperipheral>path<0|marcelOS/apis/mperipheral>data<0|-- marcelOS windows functions~<10>boot.BootMsg(~<34>starting Peripherals~<34>)~<10|10>TermPeripheral = nil~<10|10>Peripherals = {}~<10>TPeripheral = classapi.class(nil,~<34>TPeripheral~<34>)~<10|10>function TPeripheral:__init( name )~<10>	self.name = name~<10>	self.UUID = mStrings.UUID()~<10>	self.side = ~<34|34|10>	self.type = ~<34|34|10>	self.p = nil~<10>	self.owner = ~<34>system~<34|10>	self.pos = {0,0,0} -- schonmal hinzugefügt !~<10>	self.size = {1,1,1}~<10>	Peripherals[#Peripherals+1] = self~<10>end~<10|10>function TPeripheral:call(method, ...)~<10>return p.call(method, ...)~<10>end~<10|10|10>function TPeripheral:conToSide(aside)~<10>local b = (aside == self.side)~<10>return b~<10>end~<10|10>function CreatePeripheral(name)~<10>local new = TPeripheral(name or ~<34|34>)~<10>return new~<10>end~<10|10|10>function API_Initial()~<10>new = events.CreateEvent(~<34>Initialised~<34>,~<34>mperipheral~<34>, ~<34>mperipheral~<34>)~<10>mTask.RawRaiseEvent(new)~<10>end~<10|10>TermPeripheral = CreatePeripheral(~<34>term~<34>)~<10>TermPeripheral.pos = {0,0,0}~<10>TermPeripheral.size = {0,0,0}~<10>TermPeripheral.side = ~<34>term~<34|10>TermPeripheral.type = ~<34>term~<34|10>TermPeripheral.p = term>>file<0||name<0|mStrings>path<0|marcelOS/apis/mStrings>data<0|-- marcelOS functions~<10>boot.BootMsg(~<34>starting mStrings~<34>)~<10|10>TTextChar = classapi.class(nil,~<34>TTextChar~<34>) ~<10|10>function TTextChar:__init()~<10>	self.text = ~<34|34|10>	self.CursorX = 1~<10>	self.caret = ~<34>#~<34|10>	self.caret2 = ~<34> ~<34|10>	self.caretvis = true~<10>end~<10|10>function TTextChar:Caret()~<10>if self.caretvis then~<10>	return self.caret~<10>	else~<10>	return self.caret2~<10>	end~<10>end~<10|10>function TTextChar:Blink()~<10>self.caretvis = not self.caretvis~<10>end~<10|10>function TTextChar:GetText() ~<10>return string.sub(self.text,1,self.CursorX) .. self:Caret() .. string.sub(self.text,self.CursorX+1)~<10>end~<10|10>function TTextChar:SetText(_atext)~<10>-- CursorX ~<10>-- maybee lastChange ~<10>self.text = _atext or ~<34|34|10>if self.CursorX ~<62> string.len(self.text) then~<10>	self.CursorX = string.len(self.text)~<10>	end~<10>end~<10|10>function TTextChar:GetCutText(_width) ~<10>local astr = self:GetText()~<10>local offset = 3~<10>if string.len(astr) ~<62> _width then~<10>	if self.CursorX+offset-_width ~<62> 0 then~<10>		astr = string.sub(astr,self.CursorX+offset-_width,self.CursorX+offset)~<10>		else~<10>		astr = string.sub(astr,1,_width)~<10>		end~<10>	end~<10>return astr~<10>end~<10|10>function TTextChar:Add(_astr)~<10>self.text = string.sub(self.text,1,self.CursorX) .. _astr .. string.sub(self.text,self.CursorX+1)~<10>self:Right(string.len(_astr))~<10>end~<10|10>function TTextChar:Del(_acount)~<10>if self.CursorX ~<62> (_acount or 1) then~<10>	self.text = string.sub(self.text,1,self.CursorX-(_acount or 1)) .. string.sub(self.text,self.CursorX+1)~<10>	else~<10>	self.text = string.sub(self.text,self.CursorX+1)~<10>	end~<10>self:Left(_acount)~<10>end~<10|10>function TTextChar:Left(_acount)~<10>if self.CursorX ~<62>= (_acount or 1) then~<10>	self.CursorX = self.CursorX - (_acount or 1)~<10>	return true~<10>	else~<10>	self.CursorX = 1~<10>	return false~<10>	end~<10>end~<10|10>function TTextChar:Right(_acount)~<10>if self.CursorX ~<60>= (string.len(self.text)-(_acount or 1)) then~<10>	self.CursorX = self.CursorX + (_acount or 1)~<10>	return true~<10>	else~<10>	self.CursorX = string.len(self.text)~<10>	return false~<10>	end~<10>end~<10|10|10>function FileEnding( _str )~<10>local x = string.len(_str)~<10>local ok = false~<10>local result = ~<34|34|10>while x ~<62> 0 do~<10>	if string.char(string.byte(_str , x)) == ~<34>.~<34> then~<10>		ok = true~<10>		break~<10>		end~<10>	x = x - 1~<10>	end~<10>if ok then~<10>	result = string.sub(_str,x)~<10>	end~<10>return result~<10>end~<10|10>function merge(_atable,sep,_count,firstnosep)~<10>local i = 1~<10>local obj = ~<34|34|10>for i = 1,_count do~<10>	if (i ~<60> _count) and (not (firstnosep and (i == 1))) then ~<10>		obj = obj .. tostring(_atable[i]) .. sep~<10>		else~<10>		obj = obj .. tostring(_atable[i])~<10>		end~<10>	end ~<10>return obj~<10>end~<10|10>function split(astr,sep)~<10>local sep, fields = sep or ~<34>:~<34>, {}~<10>local pattern = string.format(~<34>([^%s]+)~<34>, sep)~<10>astr:gsub(pattern, function(c) fields[#fields+1] = c end)~<10>return fields~<10>end~<10|10>function SplitInt(astr,sep)~<10>local sep, fields = sep or ~<34>:~<34>, {}~<10>local pattern = string.format(~<34>([^%s]+)~<34>, sep)~<10>astr:gsub(pattern, function(c) fields[#fields+1] = c end)~<10>for i,obj in ipairs(fields) do ~<10>	fields[i] = tonumber(fields[i]) ~<10>	end~<10>return fields~<10>end ~<10|10>function doubleTable( astr , aseperator , aseperator2)~<10>local result = {}~<10>--local a = Worter(astr,aseperator)~<10>local a = split(astr,aseperator)~<10>local i,obj = 0~<10>for i,obj in ipairs(a) do~<10>	result[#result+1] = split(obj, aseperator2)~<10>	end~<10>return result~<10>end ~<10|10>function doubleTableINT( _str , _seperator , _seperator2)~<10>local result = doubleTable( _str , _seperator , _seperator2)~<10>local i,obj = 0~<10>for i,obj in ipairs(result) do~<10>	for i2,obj2 in ipairs(obj) do~<10>		result[i][i2] = tonumber(obj2)~<10>		end~<10>	end~<10>return result~<10>end ~<10|10>function TabletoStr( _table , _seperator)~<10>local result = ~<34|34|10>local i,obj = 1,nil~<10>for i,obj in ipairs(_table) do~<10>	if i ~<62> 1 then ~<10>		result = result .. (_seperator or ~<34> ~<34>).. tostring(obj)~<10>		else~<10>		result = tostring(obj)~<10>		end~<10>	end~<10>return result~<10>end ~<10|10>function UUID()~<10>local chars = {~<34>0~<34>,~<34>1~<34>,~<34>2~<34>,~<34>3~<34>,~<34>4~<34>,~<34>5~<34>,~<34>6~<34>,~<34>7~<34>,~<34>8~<34>,~<34>9~<34>,~<34>a~<34>,~<34>b~<34>,~<34>c~<34>,~<34>d~<34>,~<34>e~<34>,~<34>f~<34>}~<10>local uuid = {[9]=~<34>-~<34>,[14]=~<34>-~<34>,[15]=~<34>4~<34>,[19]=~<34>-~<34>,[24]=~<34>-~<34>}~<10>local index = 0~<10>for i = 1,36 do~<10>	if (uuid[i]==nil) then~<10>			index = math.random (16)~<10>			uuid[i] = chars[index]~<10>			end~<10>	end~<10>return table.concat(uuid)~<10>end>>file<0||name<0|mTask>path<0|marcelOS/apis/mTask>data<0|--[[~<10|10>Style~<10>values = lower case. small length  ~<34>astr~<34> ~<34>i~<34> ~<34>testdir~<34|10>Function names = CamelCase. medium length ~<34>GetValue~<34> ~<34>SetToNil~<34> ~<34>SValuesS~<34|10>const = upper case. underscores . large length ~<34>HELLO_VALUE_NUMBER~<34> ~<34>EXPERIMENTAL_FAKTOR~<34|10|10>]]~<10|10|10>--mTask is my kernel. The Task is to run multiple Programs at the same time~<10>boot.BootMsg(~<34>starting mTask~<34>)~<10>local task = {} -- SU Task everything important ist here~<10>TTask = classapi.class(nil,~<34>TTask~<34>)~<10>TGTask = classapi.class(nil,~<34>TGTask~<34>)  -- Gerneral / Global Task unimportant stuff ~<10>local lastsleep =  os.clock() -- it checls when the last sleep was to protect this program from beeing stopped by terminal xD~<10>local tEnv = {~<10>[~<34>mTask~<34>] = mTask,~<10>[~<34>shell~<34>] = shell,~<10>[~<34>term~<34>] = term~<10>}~<10>local verwaltungTask = nil~<10>local runningtask = nil~<10>local acount = 0~<10>local lastactivity = 0~<10>local rootEvents = {} -- All Events that must run as ROOT !!!~<10|10>function TGTask:__init(_name)~<10>	self.name = _name~<10>	self.su = false~<10>	self.file = ~<34|34|10>	self.args = vec3.TList(2)~<10>	self.freeze = -1~<10>	self.freezeUntilEvent = false~<10>	self.lastrun = -1~<10>	self.lastruntime = -1~<10>	self.events = {} -- Events will be pushed in this Array... User must Empty this !!!~<10>	self.useevents = false -- Aktivates Alle Events~<10>	self.eventfilter = vec3.TList()~<10>end~<10|10>function TTask:__init(_name)~<10>	self.g = TGTask(_name)~<10>	self.started = false~<10>	self.rt_fak = 20 -- if realtime then every second, else every 1st line~<10>	self.rt_last = -1~<10>	self.co = nil~<10>	task[#task+1] = self~<10>end~<10|10>-- Intern~<10|10>local function FindTask( _gtask )~<10>local i,obj = 0~<10>if _gtask ~<126>= nil then~<10>	for i, obj in ipairs(task) do~<10>		if (obj.g == _gtask) then ~<10>			return obj, i ~<10>			end~<10>		end~<10>	end~<10>return nil , -1~<10>end~<10|10>function isSu()~<10>return ((runningtask == nil) or (runningtask.su))~<10>end~<10|10>function RunningTask( _sudo)~<10>if _sudo and isSu() then~<10>   return runningtask~<10>   else~<10>   if runningtask then~<10>	  return runningtask.g --gib nicht den original  Task zurück! ~<10>	  else~<10>	  return nil~<10>	  end~<10>   end~<10>end~<10|10>function GetProgram(index)~<10>if (index ~<62> 0) and (index ~<60>= #task) then~<10>	if isSu() then~<10>		return task[index].g , task[index]~<10>		else~<10>		return task[index].g , nil~<10>		end~<10>	end~<10>end~<10|10>local function Debug(result,msg)~<10>if not result then~<10>	if runningtask ~<126>= nil then~<10>		print(~<34>An Error occurred... terminated: ~<34> .. runningtask.g.name) ~<10>		else~<10>		print(~<34>Unknown Error occurred...~<34>)~<10>		end~<10>	if msg then~<10>		print(~<34>Errorcode: ~<34>  .. tostring(msg))~<10>		end~<10>	end~<10|10>end~<10|10>local function verwaltung()~<10>if verwaltungTask then~<10>	local fileok,sPath = verwaltungTask:EditFile(false)~<10>	local sargs = verwaltungTask.g.args~<10>	if fileok and (sPath ~<126>= nil) then~<10>		verwaltungTask.started = true~<10>		local result,b,c = pcall(os.run, tEnv, sPath, unpack(sargs))~<10>		-- result is true if all is ok, on error it's false!~<10>		Debug(b,c)~<10>		return result~<10>		else~<10>		return false~<10>		end~<10>	~<10>	end~<10>end~<10|10>local function sudoVerwaltung()~<10>if verwaltungTask then~<10>	local fileok,sPath = verwaltungTask:EditFile(true)~<10>	local sargs = verwaltungTask.g.args~<10>	if fileok and (sPath ~<126>= nil) then~<10>	    verwaltungTask.started = true~<10>		local result,b,c = pcall(os.run, tEnv, sPath, unpack(sargs))~<10>		Debug(b,c)~<10>		return result~<10>		else~<10>		return false~<10>		end~<10>	~<10>	end~<10>end~<10|10|10|10>local function KernalPanic(errormsg)~<10>if not errormsg then errormsg = ~<34>'no error msg'~<34> end ~<10>local mx,my = term.getSize()~<10>local x,y = 0,0~<10>term.clear()~<10>os.sleep(0)~<10>local continuetime = os.clock() + 30~<10|10>-- data~<10>term.setCursorPos(4, 3) ~<10>term.write(~<34>KERNEL PANIC ! ~<34>) ~<10>term.setCursorPos(4, 5)~<10>term.write(~<34>an Error occured in marcelOS~<34>)~<10>term.setCursorPos(4, 6)~<10>term.write(~<34>marcelOS will continue running in 30 sec ~<34>)~<10>term.setCursorPos(3, my-2)~<10>term.write(~<34>[Enter] = continue          [R] = reboot~<34>)~<10>if term.isColor() then~<10>	term.setTextColor(colors.cyan)~<10>	end~<10>term.setCursorPos(3, 10)~<10>print(errormsg)~<10|10>-- border~<10>if term.isColor() then~<10>	term.setTextColor(colors.red)~<10>	end~<10>local astr = string.rep(~<34>X~<34>,mx)~<10>local bstr = ~<34|34|10|10>term.setCursorPos(1, 1) ~<10>term.write(astr) ~<10>term.setCursorPos(1, my) ~<10>term.write(astr) ~<10|10>for y = 1,my do ~<10>	term.setCursorPos(1, y)  ~<10>	term.write(~<34>X~<34>) ~<10>	term.setCursorPos(mx, y)  ~<10>	term.write(~<34>X~<34>) ~<10>	end~<10>	~<10>if term.isColor() then~<10>	term.setTextColor(colors.white)~<10>	end~<10>	~<10>while os.clock() ~<60> continuetime do~<10>	bstr = tostring(math.floor(continuetime - os.clock()))~<10>	term.setCursorPos(4, 6)~<10>	term.write(~<34>marcelOS will continue running in ~<34> .. bstr .. ~<34> sec  ~<34>)~<10|10>	local timer = os.startTimer( 0.5 )~<10>	local _event, p1, p2, p3, p4, p5 = os.pullEvent()~<10>	while ((_event ~<126>= ~<34>timer~<34>) or (p1 ~<126>= timer)) do~<10>		if (_event == ~<34>key~<34>) then~<10>			if (p1 == 28) then~<10>			    term.setCursorPos(1, my)  ~<10>				return~<10>				end~<10>			if (p1 == 19) then~<10>				os.reboot()~<10>				end~<10>			end~<10>		_event, p1, p2, p3, p4, p5 = os.pullEvent()~<10>		end~<10>	end~<10>term.setCursorPos(1, my) ~<10>end~<10|10>local function SaveRun(func,...)~<10>local x = {pcall(func,...)}~<10>if x[1] then~<10>	-- ok~<10>	return unpack(x,2)~<10>	else~<10>	KernalPanic(tostring(x[2] or ~<34|34>))~<10>	end~<10>end~<10|10|10|10>-- RUN Function Official~<10>function TGTask:run()~<10>if self.file then~<10>	boot.BootMsg(~<34>prg  ~<34> .. self.file)~<10>	boot.BootMsg(~<34>arg  ~<34> .. mStrings.TabletoStr(self.args,~<34> ~<34>))~<10>	verwaltungTask = FindTask(self)~<10>	if verwaltungTask then~<10>		local acur = runningtask~<10>		runningtask = verwaltungTask~<10>		verwaltungTask.co = coroutine.create(verwaltung)~<10>		coroutine.resume(verwaltungTask.co) ~<10>		runningtask = acur~<10>		end~<10>	verwaltungTask = nil~<10>	end~<10>end~<10|10>function TTask:sudoRun() --Curently~<10>if self.g.file then~<10>	boot.BootMsg(~<34>sudo-prg  ~<34> ..self.g.file)~<10>	boot.BootMsg(~<34>sudo-arg  ~<34> .. mStrings.TabletoStr(self.g.args,~<34> ~<34>))~<10>	self.su = true~<10>	verwaltungTask = self~<10>	if verwaltungTask and isSu() then ~<10>	    local acur = runningtask~<10>		runningtask = verwaltungTask  ~<10>		verwaltungTask.co = coroutine.create(sudoVerwaltung)~<10>		coroutine.resume(verwaltungTask.co) ~<10>		runningtask = acur~<10>		end~<10>	verwaltungTask = nil~<10>	end~<10>end~<10|10>function TGTask:Stop()~<10>local m = FindTask(self)~<10>if (m) and ((not m.su) or (m.su and isSu())) then~<10>	print(~<34>KILL~<34>)~<10>	-- either a normal function or a su function, which is killed by another su function :)~<10>	m.co = nil~<10>	windows.DestroyTaskWindow(self) ~<10>	end~<10>end~<10|10>function TGTask:ValidEvent(event)~<10>if (self.useevents) then~<10>	return true~<10>	else~<10>	local p = self.eventfilter:IndexOf(event.name)~<10>	return (p ~<62> -1)~<10>	end~<10>end~<10|10>function TGTask:WaitForEvent(filter)~<10>local ok = true~<10>while ok do~<10>	local puf = self:CheckForEvent(filter)~<10>	if puf then~<10>		ok = false~<10>		return puf.name , unpack(puf.params)~<10>		else~<10>		sleepEvent(self,10)~<10>		end~<10>	end~<10>end~<10|10>function TGTask:CheckForEvent(filter)~<10>-- This functions is for Compatibile Native Programs~<10>local i,obj = 0 ~<10>local puf = nil~<10>local last = 0~<10>for i, obj in ipairs(self.events) do ~<10>	last = i~<10>	if ((not filter) or (obj.name == filter)) then~<10>		puf = self.events[i]~<10>		self.events[i] = nil ~<10>		break~<10>		end~<10>	self.events[i] = nil ~<10>	end	~<10>for i = last+1,#self.events	do~<10>	self.events[i-last] = self.events[i]~<10>	self.events[i] = nil~<10>	end~<10>return puf	~<10>end~<10|10>function TGTask:DoRead()~<10>local sLine = ~<34|34|10>local nPos = 0~<10>	while true do~<10>		local sEvent, param = self:WaitForEvent()~<10>		if sEvent == ~<34>char~<34> then~<10>			sLine = string.sub( sLine, 1, nPos ) .. param .. string.sub( sLine, nPos + 1 )~<10>			nPos = nPos + 1~<10>			~<10>		elseif sEvent == ~<34>key~<34> then~<10>		    if param == keys.enter then~<10>				-- Enter~<10>				break~<10>				~<10>			elseif param == keys.left then~<10>				-- Left~<10>				if nPos ~<62> 0 then~<10>					nPos = nPos - 1~<10>				end~<10>				~<10>			elseif param == keys.right then~<10>				-- Right				~<10>				if nPos ~<60> string.len(sLine) then~<10>					nPos = nPos + 1~<10>				end~<10>			elseif param == keys.backspace then~<10>				-- Backspace~<10>				if nPos ~<62> 0 then~<10>					sLine = string.sub( sLine, 1, nPos - 1 ) .. string.sub( sLine, nPos + 1 )~<10>					nPos = nPos - 1					~<10>				end~<10>			elseif param == keys.home then~<10>				-- Home~<10>				nPos = 0	~<10>			elseif param == keys.delete then~<10>				if nPos ~<60> string.len(sLine) then~<10>					sLine = string.sub( sLine, 1, nPos ) .. string.sub( sLine, nPos + 2 )				~<10>				end~<10>			elseif param == keys[~<34>end~<34>] then~<10>				-- End~<10>				nPos = string.len(sLine)~<10>			end~<10>		end~<10>	end~<10>return sLine~<10>end~<10|10>-- Intern Functions  ~<10|10>function TTask:EditFile(_sudo)~<10>local nPath = path.C(path.TEMP(),self.g.file)~<10>local result = false~<10>local Data = ~<34|34|10>if (not _sudo) or (not isSu()) then~<10>	_sudo = false~<10>	end~<10>	~<10|10>if fs.exists(self.g.file) then~<10>	local a,Data = pcall(mTaskModify.EditFile,self)~<10>	if not a then~<10>		print(~<34>COMPILE ERROR!!!~<34>)~<10>		print(Data)~<10>		print(~<34|34>)~<10>		end~<10>	if not fs.exists(nPath) then fs.makeDir(nPath) end ~<10>	fs.delete(nPath)~<10>	ehtfutils.StringToFile(nPath,Data)~<10>	result = true~<10>	end~<10>return result, nPath~<10>end~<10|10>-- AUTOMATIC FUNCTIONS~<10>function Idle()~<10>if runningtask then~<10>	if runningtask.rt_last ~<62>= runningtask.rt_fak-1 then~<10>		runningtask.rt_last = -1~<10>		coroutine.yield(runningtask)~<10>		else~<10>		runningtask.rt_last = runningtask.rt_last + 1~<10>		end~<10>	end~<10>end~<10|10>function LastStarted()~<10>if verwaltungTask then~<10>	if isSu() then~<10>	   return verwaltungTask.g , verwaltungTask~<10>	   else~<10>	   return verwaltungTask.g --gib nicht den original  Task zurück!~<10>	   end~<10>   end~<10>end~<10|10>function sleep(_handle, _count )~<10>if ( _handle ~<126>= nil ) then ~<10>	_handle.freeze = os.clock() + (_count or 0)~<10>	_handle.freezeUntilEvent = false~<10>	coroutine.yield(runningtask)~<10>	end	~<10>end~<10|10>function sleepEvent(_handle , _count )~<10>if ( _handle ~<126>= nil ) then ~<10>	_handle.freezeUntilEvent = true~<10>	_handle.freeze = os.clock() + (_count or 10)~<10>	coroutine.yield(runningtask)~<10>	end	~<10>end~<10|10>-- USER FUNCTIONS~<10>function CreateTask(name , _sudo)~<10>local new = TTask(name or ~<34|34>)~<10>if _sudo and isSu() then~<10>   return new.g ,new , #task~<10>   else~<10>   return new.g, nil , #task --dont return whole task only global one~<10>   end~<10>end~<10|10>function CurProgramms( _except )~<10>local result = {}~<10>for i,v in ipairs(task) do~<10>	if (v ~<126>= nil) and (v ~<126>= _except) then~<10>		result[#result+1] = v.g~<10>		end~<10>	end~<10>return result~<10>end~<10|10|10>function RaiseHandleEvent ( _handle,_event ) -- to 1 handle~<10>if _handle:ValidEvent(_event) then ~<10>	_handle.events[#_handle.events+1] = _event~<10>	if _handle.freezeUntilEvent then~<10>		_handle.freeze = -1~<10>		end~<10>	end~<10>end~<10|10>function RaiseEvent ( _event ) -- all handles~<10>local i,obj = 0~<10>for i,obj in ipairs(task) do~<10>	RaiseHandleEvent(obj.g,_event)~<10>	end~<10>end~<10|10>function RaiseRootEvent ( _event ) -- only drivers !!! if isSU~<10>if (isSu() or true) and _event then -- ERROR ERROR ERROR ERROR ERROR - SAFTY ERROR, DELETE THE ~<34>or true~<34>	~<10>	rootEvents[#rootEvents+1] = _event~<10>	end~<10>end~<10|10>function RawRaiseEvent ( _event ) -- all drivers and handles~<10>SaveRun(driver.EventInterpreter, _event )~<10>if _event and _event.enabled then ~<10>   RaiseEvent( _event )~<10>   end~<10>end~<10|10>function RunAll()~<10>local curtime = os.clock()~<10>local softsleep = false~<10>local maxsleep = curtime + 10 -- make the pc max sleep 10 seconds :)~<10>if lastactivity+5 ~<62> curtime then -- letzte aktivität kleiner als 10 sek~<10>	maxsleep = curtime + 5~<10>	end~<10>local i = 0~<10>local obj = nil~<10>local n = 0~<10>for i = #task,1,-1 do~<10>	if (task[i] == nil) or ((task[i].co == nil) and (task[i].started)) or ((task[i].co) and (coroutine.status(task[i].co) == 'dead')) then~<10>		if (task[i].g ~<126>= nil) then windows.DestroyTaskWindow(task[i].g) end~<10>		task[i] = task[#task]~<10>		task[#task] = nil~<10>		end~<10>	end~<10|10>for i, obj in ipairs(task) do~<10>	if (obj.g.freeze ~<60> maxsleep) then ~<10>		maxsleep = obj.g.freeze ~<10>		end~<10>	if (obj.g.freezeUntilEvent) then~<10>		softsleep = true~<10>		end~<10>	end~<10>	~<10>if (not softsleep) and (maxsleep-curtime ~<62> 2) then ~<10>	maxsleep = curtime+2~<10>	end~<10>if maxsleep ~<62>= curtime then~<10>	mTask.GetEvents(maxsleep-curtime,softsleep)~<10>	end~<10>	~<10>-- Root Events~<10>for i,obj in ipairs(rootEvents) do~<10>	SaveRun(driver.EventInterpreter,obj)~<10>	end~<10>rootEvents = {}~<10>	~<10>-- this takes time! so no curtime but os.clock()~<10>for i, obj in ipairs(task) do~<10>	if (os.clock() ~<62> obj.g.freeze) and obj.co then ~<10>		runningtask = obj~<10>		local buf = os.clock()~<10>		coroutine.resume(obj.co) ~<10>		obj.g.lastrun = os.clock()~<10>		obj.g.lastruntime = obj.g.lastrun - buf~<10>		end~<10>	end~<10>runningtask = nil~<10>SaveRun(windows.mayDraw)~<10>end~<10|10>function GetEvents( _atime , _stopatfirstevent)~<10>local timer = nil~<10>if _atime then~<10>	timer = os.startTimer( _atime )~<10>	end~<10>local i,obj~<10>local _event, p1, p2, p3, p4, p5 = os.pullEvent()~<10>while ((_event ~<126>= ~<34>timer~<34>) or (p1 ~<126>= timer)) do~<10>	lastactivity = os.clock()~<10>	if (_event ~<126>= ~<34>timer~<34>) then~<10>	    local myevent = events.CreateEvent(_event , ~<34>system~<34> , p1 , p2 , p3 , p4 , p5)~<10>		--print(myevent:instring())~<10>		RawRaiseEvent(myevent)~<10>		end~<10>	SaveRun(windows.mayDraw)~<10>	if _stopatfirstevent or (not _atime) then ~<10>		_event = ~<34>timer~<34|10>		p1 = timer~<10>		else~<10>		_event, p1, p2, p3, p4, p5 = os.pullEvent()	~<10>		end~<10>	end~<10>end~<10|10>function API_Initial()~<10>new = events.CreateEvent(~<34>Initialised~<34>,~<34>mTask~<34>, ~<34>mTask~<34>)~<10>mTask.RawRaiseEvent(new)~<10>end>>file<0||name<0|mTaskModify>path<0|marcelOS/apis/mTaskModify>data<0|--[[~<10>Just Put all the modify stuff here so that mTask is cleaner :)~<10|10|10>test line~<10>--print(ah ,func(hello(), offset ,  offsetfunc(nooffset,   ~<34>this~<34> ..  ~<34>alotoffset~<34>    )  ,asd(isthishello,thisislove(),hello,ld(x))),bfunc,cfunc())~<10>]]~<10|10>boot.BootMsg(~<34>starting mTaskModify~<34>)~<10|10|10|10|10|10|10>TTaskModiPos = classapi.class(nil,~<34>TTaskModiPos~<34>)~<10>function TTaskModiPos:__init()~<10>	self.start = -1~<10>	self.type = ~<34>data~<34|10>	self.data = ~<34|34|10>	self.parent = nil~<10>	self.Params = vec3.TList()~<10>end~<10|10>function TTaskModiPos:GetString()~<10>-- Builds a string out of all params ...~<10>local i,obj = 0,nil~<10>local result = ~<34|34|10>local astr = ~<34|34|10>if self.type == ~<34>func~<34> then~<10>	result = self.about .. ~<34>(~<34|10>	for i,obj in ipairs(self.Params) do~<10>		result = result .. obj:GetString()~<10>		if (i ~<126>= #self.Params) and (obj.type == ~<34>param~<34>) then~<10>			result = result .. ~<34>,~<34|10>			end~<10>		end~<10>	result = result .. ~<34>)~<34|10>elseif self.type == ~<34>param~<34> then~<10>	result = self.data~<10>elseif self.type == ~<34>data~<34> then~<10>	result = self.data~<10>elseif self.type == ~<34>line~<34> then~<10>	local i2,obj2 = 0,nil~<10>	for i2,obj2 in ipairs(self.Params) do~<10>		result = result .. ~<34> ~<34> .. obj2:GetString() .. ~<34> ~<34|10>		end	~<10>	end~<10>return result~<10>end~<10|10>function TTaskModiPos:ToEHTF()~<10>-- Builds a string out of all params ...~<10>local i,obj = 0,nil~<10>local result = ehtf.THTNode()~<10>result:Add(~<34>start~<34>,self.start)~<10>result:Add(~<34>type~<34>,self.type)~<10>if self.about then~<10>	result:Add(~<34>about~<34>,self.about or ~<34|34>)~<10>	end~<10>if self.data then~<10>	result:Add(~<34>data~<34>,self.data or ~<34|34>)~<10>	end~<10>if self.lineid then~<10>	result:Add(~<34>lineid~<34>,self.lineid or ~<34|34>)~<10>	end~<10>if self.Params and (#self.Params ~<62> 0)then~<10>	local p = result:Add(~<34>Params~<34>,~<34|34>)~<10>	for i,obj in ipairs(self.Params) do~<10>		p:Add(obj:ToEHTF())~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function DelString(astr)~<10>local i,maxi,mini = 0,0,0~<10>local achar = 0~<10|10>for i = string.len(astr),1,-1 do~<10>	achar = string.byte(astr,i)~<10>	if (achar ~<62>= 33) then~<10>		maxi = i -- obere Grenze~<10>		break~<10>		end~<10>	end~<10>	~<10>for i = 1,maxi do~<10>	achar = string.byte(astr,i)~<10>	if (achar ~<62>= 33) then~<10>		mini = i -- untere Grenze~<10>		break~<10>		end~<10>	end~<10|10>return string.sub(astr,mini,maxi)~<10>end~<10|10>function SepParam(astr)~<10>local result = {}~<10>local i = 0~<10>local bstr = ~<34|34|10>local last = 1~<10|10>for i = 1,string.len(astr) do~<10>	achar = string.byte(astr,i)~<10>	if (achar == 44) then~<10>		bstr = string.sub(astr,last,i-1)~<10>		result[#result+1] = DelString(bstr)~<10>		last = i+1~<10>		end~<10>	end~<10>if string.len(astr) ~<62>= last then~<10>	bstr = string.sub(astr,last)~<10>	result[#result+1] = DelString(bstr)~<10>	end~<10|10>return result~<10>end~<10|10>function CompleteLine(astr)~<10>-- Check ob alle ~<34>(~<34> bzw ~<34>{~<34> auch geschlossen werden...~<10>local i,obj = 0,nil~<10>local NCount = 0 --(  40   41~<10>local GCount = 0 --{  123  125~<10>local ECount = 0 --[  91   93~<10>local inComment1 = false --' 39~<10>local inComment2 = false --~<34> 34~<10>for i = 1,string.len(astr) do~<10>	local a = string.byte(astr,i)~<10>	--print(tostring(inComment1) .. ~<34> ~<34> .. tostring(inComment2))~<10>	if a == 39 then inComment1 = not inComment1 end~<10>	if not inComment1 then~<10>		if a == 34 then inComment2 = not inComment2 end~<10>		if not inComment2 then~<10>			if a == 40 then~<10>				NCount = NCount +1~<10>				elseif a == 41 then~<10>					NCount = NCount -1~<10>					elseif a == 123 then~<10>						GCount = GCount + 1~<10>							elseif a == 125 then~<10>								GCount = GCount - 1~<10>									elseif a == 91 then~<10>										ECount = ECount + 1~<10>											elseif a == 93 then~<10>												ECount = ECount - 1~<10>												end~<10>			end~<10>		end~<10>	end~<10>return ((NCount == 0) and (GCount == 0) and (ECount == 0))~<10>end~<10|10>function KillComments(astr)~<10>local i,obj = 0,nil~<10>local inCom = false~<10>local inText = false~<10>local last = ~<34|34|10>local amax = string.len(astr)~<10>for i = 1,amax do~<10>	local a = string.sub(astr,i,i)~<10>	local b = string.sub(astr,i,i+1)~<10>    if (a == ~<34|92|34|34>) then~<10>		if last ~<126>= ~<34|92|92|34> then~<10>			inCom = not inCom~<10>			end~<10>		end~<10>	if b == ~<34>--~<34> then~<10>		if string.sub(astr,i,i+3) ~<126>= ~<34>--[[~<34> then~<10>			if (not inCom) and (not inText) then~<10>				astr = string.sub(astr,1,i-1)~<10>				return astr~<10>				end~<10>			else~<10>			inCom = true~<10>			end	~<10>		end~<10>	if b == ~<34>]]~<34> then~<10>		inCom = false~<10>		end~<10>	last = a~<10>	end~<10>return astr~<10>end~<10|10>function GenerateInfo(aTask,loading)~<10>local astr = ~<34|34|10>local bstr = ~<34|34> --only intern~<10>local cstr = ~<34|34|10>local lineend =  string.char(13).. string.char(10)~<10>local file = nil~<10|10>local Lines = {} -- holds all lines~<10|10>local i,obj = 1,nil~<10>local i2,obj2 = 1,nil~<10>local new = nil~<10>local sLine = ~<34|34|10>local cLine = ~<34|34|10|10>file = fs.open(aTask.g.file,~<34>r~<34>)~<10>sLine = file.readLine()~<10>while sLine do~<10>	if ((cstr == ~<34|34>) and CompleteLine(sLine))then~<10>		new = TTaskModiPos()~<10>		new.type =~<34>line~<34|10>		new.data = loading(aTask,#Lines+1,sLine)~<10>		new.lineid = #Lines + 1~<10>		Lines[#Lines + 1] = new~<10>		else~<10>		cstr = cstr .. ~<34> ~<34> .. KillComments(sLine)~<10>		if CompleteLine(cstr) then~<10>			new = TTaskModiPos()~<10>			new.type =~<34>line~<34|10>			new.data = loading(aTask,#Lines+1,cstr)~<10>			new.lineid = #Lines + 1~<10>			Lines[#Lines + 1] = new~<10>			cstr = ~<34|34|10>			end~<10>		end~<10>	sLine = file.readLine()~<10>	end	~<10>file.close()~<10|10>function InitialFunc(_funcs,_deep,_astart,_obj)~<10>_funcs[_deep] = TTaskModiPos()~<10>_funcs[_deep].start = _astart~<10>_funcs[_deep].parent = _funcs[_deep-1]~<10>_funcs[_deep].line = _obj ~<10>_funcs[_deep-1].Params:Add(_funcs[_deep])~<10>end~<10|10>function AddParam(_funcs,_deep,_astart,_obj,_i2)~<10>_deep = _deep + 1~<10>InitialFunc(_funcs,_deep,_astart,_obj)~<10>_funcs[_deep].start = _astart~<10>_funcs[_deep].type = ~<34>param~<34|10>_funcs[_deep].pend = _i2-1	~<10>_funcs[_deep].data = string.sub(_obj.data,_funcs[_deep].start,_funcs[_deep].pend)~<10>_deep = _deep - 1~<10>end~<10|10>function AddData(_funcs,_deep,_astart,_obj,_i2)~<10>AddParam(_funcs,_deep,_astart,_obj,_i2)~<10>_funcs[_deep+1].type = ~<34>data~<34|10>end~<10|10>for i,obj in ipairs(Lines) do	~<10>	-- NEW~<10>	local deep = 1~<10>	local funcs = vec3.TList()~<10>	funcs:Add(obj)~<10>	local strbetween = false~<10>	local laststr = 1~<10>	local p = nil~<10>	local astart = 1~<10>	~<10>	for i2 = 1,string.len(obj.data) do~<10>		achar = string.byte(obj.data,i2)	~<10>		-- 40: (~<10>		-- 41: )~<10>		-- 9: Tab~<10>		-- 32: Leerzeichen~<10>		-- 44: ,~<10>		if (achar == 40) then~<10>			if ((i2-1) ~<62>= astart) then~<10>				--AddData(funcs,deep,astart,obj,i2)~<10>				end~<10>			deep = deep + 1~<10>			InitialFunc(funcs,deep,astart,obj)~<10>			funcs[deep].start = astart~<10>			funcs[deep].paramstart = i2~<10>			funcs[deep].type = ~<34>func~<34|10>			funcs[deep].about = DelString(string.sub(obj.data,funcs[deep].start,funcs[deep].paramstart-1))~<10>			astart = i2+1~<10>			elseif (achar == 41) then~<10>				funcs[deep].pend = i2	~<10>				funcs[deep].data = string.sub(obj.data,funcs[deep].start,funcs[deep].pend)~<10>				~<10>				-- Add the last entry to Function !~<10>				if ((i2-1) ~<62>= astart) then~<10>					AddParam(funcs,deep,astart,obj,i2)~<10>					end~<10>				~<10>				-- Finish Function~<10>				astart = i2+1~<10>				deep = deep - 1~<10>				~<10>				elseif (achar == 44) and (deep ~<62> 1) and ((i2-1) ~<62>= astart) then~<10>					-- Add an entry to Function !~<10>					AddParam(funcs,deep,astart,obj,i2)~<10>					astart = i2+1~<10>					elseif (achar == 32) and (deep == 1) then~<10>						if ((i2-1) ~<62>= astart) then~<10>							AddData(funcs,deep,astart,obj,i2)~<10>							end~<10>						astart = i2+1~<10>						end~<10>		end~<10>	if (string.len(obj.data) ~<62>= astart) then~<10>		AddData(funcs,deep,astart,obj,string.len(obj.data)+1)~<10>		astart = string.len(obj.data)+1~<10>		end~<10>	end~<10>return Lines~<10>end~<10|10|10>function afunc(aTask,acount,astr)~<10>-- ON LOADING~<10>local result = astr~<10>local lineend =  string.char(13).. string.char(10)~<10>if acount == 1 then~<10>	aTask.mTaskModifiy_mMultiOS = (DelString(astr) == ~<34>--mMultiOS~<34>)~<10>	result = ~<34> local Application ,ApplicationSU = mTask.LastStarted() coroutine.yield() ~<34> .. result~<10>	end ~<10>if (acount == 2) and (aTask.mTaskModifiy_mMultiOS) then~<10>	local p,o,o2,o3,o4 = nil,nil,nil,nil,nil~<10>	p = ehtf.THTNode()~<10>	p:FromStr(astr)~<10>	result = ~<34|34|10>	if p then~<10>		o = p:FindAboutC(~<34>marcelOS~<34>)~<10>		if not o then~<10>			o = p:FindAboutC(~<34>Other~<34>)~<10>			end~<10>		if o then~<10>			o2 = o:FindAboutC(~<34>info~<34>)~<10>			if o2 then~<10>				o3 = o2:FindAboutC(~<34>IdleCount~<34>)~<10>				if o3 then~<10>					aTask.rt_fak = o3:SValuesI(1)~<10>					end~<10>				o3 = o2:FindAboutC(~<34>changePrint~<34>)~<10>				if o3 then~<10>					aTask.mTaskModify_changePrint = o3:SValuesB(1)~<10>					end~<10>				o3 = o2:FindAboutC(~<34>eventfilter~<34>)~<10>				if o3 then~<10>					local i = 1~<10>					for i = 1,#o3.Values do~<10>						result = result .. ' Application.eventfilter:AddOnce(~<34>' .. o3:SValuesS(i) .. '~<34>) ' ~<10>						end~<10>					end~<10>				o3 = o2:FindAboutC(~<34>EventManager~<34>)~<10>				if o3 and o3:SValuesB(1) then~<10>					result = result .. ~<34> local function EventHandle() ~<34> .. lineend .. ~<34> local i,obj = 0  for i, obj in ipairs(Application.events) do getEvent(obj) if (Application.window) then Application.window:Event(obj) end Application.events[i] = nil end ~<34> .. lineend .. ~<34> end ~<34>									~<10>					end~<10>				o3 = o2:FindAboutC(~<34>Debug~<34>)~<10>				if o3 and o3:SValuesB(1) then~<10>					result = result .. ~<34> local function Debug(title,msg,color) ~<34> .. lineend .. ~<34> if ThrowDebug then ThrowDebug(Application,title,msg,color) end ~<34> .. lineend .. ~<34> end ~<34>									~<10>					end~<10>				end~<10>			o2 = o:FindAboutC(~<34>code~<34>)~<10>			if o2 then~<10>				result = result .. o2:SValuesS(1)~<10>				end~<10>			end~<10>		end~<10>	end~<10>if (acount == 2) and (not aTask.mTaskModifiy_mMultiOS) then~<10>	result = ~<34>  Application.window  =  windows.CreateWindow( Application.name , Application , true)  ~<34> .. result~<10>	end~<10>return result~<10>end~<10|10|10>function bfunc(aTask,acount,astr)~<10>-- AFTER EDITITNG~<10>local ok = true~<10>if (DelString(astr) == ~<34|34>) or (aTask.su) then ok = false~<10>	elseif (acount ~<60>= 2) and (aTask.mTaskModifiy_mMultiOS) then ok = false~<10>    elseif (string.find(astr,~<34>end~<34>) ~<126>= nil) or (astr == ~<34>end~<34>) then ok = false~<10>	elseif (string.find(astr,~<34>or~<34>) ~<126>= nil) or (astr == ~<34>or~<34>) then ok = false -- eigentlich nur am ende !~<10>	elseif (string.find(astr,~<34>and~<34>) ~<126>= nil) or (astr == ~<34>and~<34>) then ok = false~<10>	elseif (string.find(astr,~<34>=~<34>) ~<126>= nil) or (astr == ~<34>=~<34>) then ok = false~<10>	elseif (string.find(astr,~<34>return~<34>) ~<126>= nil) or (astr == ~<34>return~<34>) then ok = false~<10>	elseif (string.find(astr,~<34>break~<34>) ~<126>= nil) or (astr == ~<34>break~<34>) then ok = false~<10>	end~<10>if ok then~<10>	aTask.mTaskModifiy_linefak = aTask.mTaskModifiy_linefak + 1~<10>	if (math.fmod(aTask.mTaskModifiy_linefak,aTask.rt_fak) ~<62> 0) then ~<10>		ok = false~<10>		aTask.mTaskModifiy_linefak = 0~<10>		end~<10>	end~<10>if ok then ~<10>	astr = astr .. ~<34> mTask.Idle() ~<34|10>	end~<10>return astr~<10>end~<10|10>function EditFile(aTask)~<10>local Lines = GenerateInfo(aTask,afunc)~<10>local i,obj = 0,nil~<10>local i2,obj2 = 0,nil~<10>local p = ~<34|34|10>print(~<34>EditFile~<34>)~<10>aTask.g.useevents = not aTask.mTaskModifiy_mMultiOS~<10>aTask.mTaskModifiy_linefak = 0~<10>for i2,obj2 in ipairs(Lines) do~<10>	for i,obj in ipairs(obj2.Params) do~<10>		if obj.type == ~<34>func~<34> then~<10>			if (obj.about == ~<34>sleep~<34>) or (obj.about == ~<34>os.sleep~<34>) then ~<10>				obj.about = ~<34>mTask.sleep~<34|10>				local new = TTaskModiPos()~<10>				new.pend = -1~<10>				new.data = ~<34>Application~<34|10>				new.start = 1~<10>				new.type = ~<34>param~<34|10>				vec3.insertPos(obj.Params,new,1)~<10>				end~<10>			if ((obj.about == ~<34>print~<34>) or (obj.about == ~<34>term.print~<34>)) and ((aTask.mTaskModify_changePrint == nil) or (aTask.mTaskModify_changePrint == true)) then ~<10>				obj.about = ~<34>Application.window:print~<34|10>				end~<10>			if ((obj.about == ~<34>slowPrint~<34>) or (obj.about == ~<34>textutils.slowPrint~<34>)) then ~<10>				obj.about = ~<34>Application.window:print~<34|10>				end~<10>			if (obj.about == ~<34>write~<34>) or (obj.about == ~<34>term.write~<34>) then ~<10>				obj.about = ~<34>Application.window:write~<34|10>				end~<10>			if (obj.about == ~<34>run~<34>) or (obj.about == ~<34>os.run~<34>) then ~<10>				obj.about = ~<34> local co = mTask.CreateTask(~<34> .. (obj.Params[2].data or ~<34|34>) .. ~<34>)  co.file = ~<34> .. (obj.Params[2].data or ~<34|34>) .. ~<34> co.args = ~<34> .. (obj.Params[3].data or ~<34|34>) .. ~<34> co:run() ~<34|10>				obj.type = ~<34>data~<34|10>				obj.Params = vec3.TList() -- no function any more~<10>				end~<10>			if (obj.about == ~<34>shell.run~<34>) then ~<10>				obj.about = ~<34> local co = mTask.CreateTask(~<34> .. (obj.Params[1].data or ~<34|34>) .. ~<34>)  co.file = ~<34> .. (obj.Params[1].data or ~<34|34>) .. ~<34> co.args = ~<34> .. (obj.Params[2].data or ~<34|34>) .. ~<34> co:run() ~<34|10>				obj.type = ~<34>data~<34|10>				obj.Params = vec3.TList() -- no function any more~<10>				end~<10>			if (obj.about == ~<34>shell.resolve~<34>) then ~<10>				obj.about = ~<34|34|10>				end~<10>			if (obj.about == ~<34>send~<34>) or (obj.about == ~<34>rednet.send~<34>) then ~<10>				obj.about = ~<34>ip.SendMessage( nil, ~<34> .. (obj.Params[1].data or ~<34|34>) .. ~<34>, nil, 100, nil , ~<34> .. (obj.Params[2].data or ~<34|34>) .. ~<34> ) ~<34|10>				obj.Params = vec3.TList() -- no function any more~<10>				end	~<10>			if (obj.about == ~<34>term.getSize~<34>) then ~<10>				obj.data = ~<34> Application.window.width , Application.window.height ~<34|10>				obj.type = ~<34>data~<34|10>				obj.Params = vec3.TList() -- no function any more~<10>				end	~<10>			if (obj.about == ~<34>term.setBackgroundColor~<34>) or (obj.about == ~<34>term.setBackgroundColour~<34>) then ~<10>				obj.about = ~<34>Application.window.l:setBackColor~<34|10>				end	~<10>			if (obj.about == ~<34>term.setTextColor~<34>) or (obj.about == ~<34>term.setTextColour~<34>) then ~<10>				obj.about = ~<34>Application.window.l:setFontColor~<34|10>				end	~<10>			if (obj.about == ~<34>term.clear~<34>) then ~<10>				obj.about = ~<34>Application.window.l:clear~<34|10>				obj.data = ~<34>Application.window.l:clear()~<34|10>				obj.Params = vec3.TList() -- no function any more~<10>				end~<10>			if (obj.about == ~<34>term.clearLine~<34>) then ~<10>				obj.about = ~<34>Application.window.l:clearLine~<34|10>				obj.data = ~<34>Application.window.l:clearLine()~<34|10>				obj.Params = vec3.TList() -- no function any more~<10>				end	~<10>			if (obj.about == ~<34>term.setCursorPos~<34>) then ~<10>				obj.about = ~<34>Application.window.l:setCursorPos~<34>		~<10>				end~<10>			if (obj.about == ~<34>term.getCursorPos~<34>) then ~<10>				obj.about = ~<34>Application.window.l:getCursorPos~<34|10>				end~<10>			if (obj.about == ~<34>os.pullEvent~<34>) then ~<10>				obj.about = ~<34>Application:WaitForEvent~<34>		~<10>				end~<10>			if (obj.about == ~<34>read~<34>) then ~<10>				obj.about = ~<34>Application:DoRead~<34>		~<10>				end~<10>			end~<10>		end~<10>	end~<10>	~<10>p = string.char(13) .. string.char(10)~<10>local Data = ~<34|34|10>local last = 1~<10>local i3,obj3 = 0,nil~<10>--print(~<34>startEdit~<34>)~<10|10|10>--local anode = ehtf.THTNode()~<10>for i2,obj2 in ipairs(Lines) do~<10>	--anode:Add(obj2:ToEHTF())~<10>	Data = Data .. bfunc(aTask,i2,obj2:GetString()) .. p~<10>	--Data = Data .. obj2.data .. p~<10>	end~<10>--anode:SavetoFile(~<34>Heyho.ehtf~<34>)~<10>--print(~<34>finishEdit~<34>)~<10>return Data~<10>end>>file<0||name<0|mView>path<0|marcelOS/apis/mView>data<0|-- marcelOS Monitor functions~<10>boot.BootMsg(~<34>starting mView~<34>)~<10>TMonitorBlock = classapi.class(nil,~<34>TMonitorBlock~<34>) ~<10>TMonitor = classapi.class(nil,~<34>TMonitor~<34>) ~<10>TScreen = classapi.class(nil,~<34>TScreen~<34>) ~<10>local config = ehtf.THTNode()~<10|10>Tvwindow = classapi.class(nil,~<34>Tvwindow~<34>) -- Includes a virtual Window for dubble buffered read write...~<10>main = nil~<10>second = nil~<10|10>function Tvwindow:__init()~<10>	self.width = 0~<10>	self.height = 0~<10>	self.CursorX = 1~<10>	self.CursorY = 1~<10>	self.FontColor = colors.white~<10>	self.BackColor = colors.black~<10>	self.lines = {}~<10>	self.colors = {}~<10>	self.bcolors = {}~<10>end~<10|10>function Tvwindow:clear()~<10>local i = 0~<10>local i2 = 0~<10>local atext = string.rep(~<34> ~<34>,self.width)~<10>for i =1,self.height do~<10>	self.lines[i] = atext~<10>	self.colors[i] = {}~<10>	self.bcolors[i] = {}~<10>	for i2=1,self.width do~<10>		self.colors[i][i2] = colors.white~<10>		self.bcolors[i][i2] = colors.black~<10>		end~<10>	end~<10>self.CursorX = 1~<10>self.CursorY = 1~<10>end~<10|10>function Tvwindow:clearLine()~<10>local atext = string.rep(~<34> ~<34>,self.width)~<10>local i = 1~<10>self.lines[self.CursorY] = atext~<10>self.colors[self.CursorY] = {}~<10>self.bcolors[self.CursorY] = {}~<10>for i=1,self.width do~<10>	self.colors[self.CursorY][i] = colors.white~<10>	self.bcolors[self.CursorY][i] = colors.black~<10>	end~<10>self.CursorX = 1~<10>end~<10|10|10>function Tvwindow:SetSize(x,y)~<10>local atext = ~<34|34|10>local i,i2 = 0,0~<10>if (x - self.width) ~<62> 1 then~<10>	atext = string.rep(~<34> ~<34>,x - self.width)~<10>	for i =1,self.height do~<10>		self.lines[i] = self.lines[i] .. atext~<10>		for i2=self.width+1,x do~<10>			self.colors[i][i2] = colors.white~<10>			self.bcolors[i][i2] = colors.black~<10>			end~<10>		end~<10>	end~<10>if x ~<62> 0 then~<10>	atext = string.rep(~<34> ~<34>,x)~<10>	for i =self.height+1,y do~<10>		self.lines[i] = atext~<10>		self.colors[i] = {}~<10>		self.bcolors[i] = {}~<10>		for i2=1,x do~<10>			self.colors[i][i2] = colors.white~<10>			self.bcolors[i][i2] = colors.black~<10>			end~<10>		end~<10>	end~<10>self.width = x~<10>self.height = y~<10>end~<10|10>function Tvwindow:valid(x,y)~<10>return (y ~<62> 0) and (y ~<60>= self.height) and (x ~<62> 0) and (x ~<60>= self.width)~<10>end~<10|10>function Tvwindow:ClearChars( acount )~<10>if acount ~<62> 0 then~<10>	local text = string.rep(~<34> ~<34>,acount)~<10>	self.CursorX = self.CursorX - acount~<10>	self:writePos(self.CursorX,self.CursorY,text)~<10>	end~<10>end~<10|10>function Tvwindow:write( text)~<10>self:writePos(self.CursorX,self.CursorY,text , self.FontColor , self.BackColor )~<10>self.CursorX = self.CursorX + string.len(text)~<10>end~<10|10>function Tvwindow:print( text )~<10>self:writePos(self.CursorX,self.CursorY,text , self.FontColor , self.BackColor  )~<10>self.CursorX = 1~<10>self.CursorY = self.CursorY + 1~<10>end~<10|10>function Tvwindow:writePos(x, y ,text , color , bgcolor )~<10>text = tostring(text or ~<34|34>)~<10>if (x ~<60> 1) then~<10>	text = string.sub(text,2-x)~<10>	x = 1~<10>	end~<10>local astr = (self.lines[y] or ~<34|34>)~<10>local i = 0~<10>self.lines[y] = string.sub(astr,1,x-1) .. text .. string.sub(astr,x+string.len(text))~<10>if color and bgcolor then~<10>	if not self.colors[y] then ~<10>		self.colors[y] = {}~<10>		end~<10>	if not self.bcolors[y] then ~<10>		self.bcolors[y] = {}~<10>		end~<10>	for i = x,x+string.len(text)-1 do~<10>		self.colors[y][i] = color~<10>		self.bcolors[y][i] = bgcolor~<10>		end	~<10>elseif color then~<10>	if not self.colors[y] then ~<10>		self.colors[y] = {}~<10>		end~<10>	for i = x,x+string.len(text)-1 do~<10>		self.colors[y][i] = color~<10>		end	~<10>elseif bgcolor then~<10>	if not self.bcolors[y] then ~<10>		self.bcolors[y] = {}~<10>		end~<10>	for i = x,x+string.len(text)-1 do~<10>		self.bcolors[y][i] = bgcolor~<10>		end	~<10>	end~<10|10>end~<10|10>function Tvwindow:GetLine(y)~<10>if (y ~<62> 0) and (y ~<60>= self.height) then~<10>	return (self.lines[y] or ~<34|34>)~<10>	else~<10>	return ~<34|34|10>	end~<10>end~<10|10>function Tvwindow:SetLine(y,text)~<10>if (y ~<62> 0) and (y ~<60>= self.height) then~<10>	local atext = string.rep(~<34> ~<34>,self.width-string.len(text))~<10>	self.lines[y] = text..atext~<10>	return true~<10>	else~<10>	return false~<10>	end~<10>end~<10|10>-- TERM COMPATIBLE PROCEDURES !!!~<10|10>function Tvwindow:setBackColor(acolor)~<10>self.BackColor = acolor~<10>end~<10|10>function Tvwindow:setFontColor(acolor)~<10>self.FontColor = acolor~<10>end~<10|10>function Tvwindow:setCursorPos(_x,_y)~<10>self.CursorX = _x~<10>self.CursorY = _y~<10>end~<10|10>function Tvwindow:getCursorPos()~<10>return self.CursorX,self.CursorY~<10>end~<10|10|10|10>function TMonitorBlock:__init(_parent) -- one block of a physical monitor~<10>	self.parent = _parent -- master~<10>	self.lpos = {-1,-1} -- no TBOX because size = 1 -- local !!!~<10>	self.pos = vec3.TBox() -- term pos~<10>	self.border = {false,false,false,false}~<10>end~<10|10>function TMonitorBlock:Border()~<10>local x,y = 0,0~<10>if self.border[1] then~<10>	x = x + 1~<10>	end~<10>if self.border[2] then~<10>	y = y + 1~<10>	end~<10>if self.border[3] then~<10>	x = x + 1~<10>	end~<10>if self.border[4] then~<10>	y = y + 1~<10>	end~<10>return {x,y}~<10>end~<10|10>function TMonitorBlock:GenerateSize()~<10>local xc,yc = 16,16 -- 16 / 16 of the block are mon~<10>local t = self:Border()~<10>xc = xc - 2.5 * t[1]~<10>yc = yc - 2.5 * t[2]~<10>--local xfak = 31/(3*16)  / self.parent.textScale~<10>--local yfak = 7/16       / self.parent.textScale~<10>--local xfak = 0.66203703703703703703703703703704 / self.parent.textScale~<10>--local yfak = 0.44166666666666666666666666666667 / self.parent.textScale~<10>local xfak = 143/(107*2*self.parent.textScale)~<10>local yfak = 53/(59*2*self.parent.textScale)~<10>--x2 =  math.floor((16*monitors-4)/.759)~<10|10>local x,y = 1,1~<10>if self.parent.m ~<126>= mperipheral.TermPeripheral then~<10>	x = xfak*xc~<10>	y = yfak*yc	~<10>	else~<10>	x,y = self.parent.m.p.getSize()~<10>	end~<10|10>return {x,y}~<10>end~<10|10>function TMonitor:__init(_name , _m , _parent) -- one block of a physical monitor~<10>	self.name = _name~<10>	self.parent = _parent~<10>	self.textScale = 0.5~<10>	self.m = _m -- Mperipheral~<10>	self.ppos = vec3.TBox() -- Physical POS~<10>	self.lpos = vec3.TBox() -- Physical POS where the TOTAL monitor is at 1 ~<124> 1~<10>	self.pos = vec3.TBox() -- term pos~<10>	self.gpos = vec3.TBox() -- global POS !!!~<10>	self.blocks = {}~<10>	if _m then ~<10>		if _m ~<126>= mperipheral.TermPeripheral then~<10>			_m.p.setTextScale(self.textScale) ~<10>			end~<10>		end~<10>end~<10|10>function TMonitor:Change() -- one block of a physical monitor~<10>	-- On physical Change to one Monitor !~<10|10>	-- Override if Conf is posible ~<10>	local done = self:LoadfromConfig()~<10>	if self.m ~<126>= mperipheral.TermPeripheral then ~<10>		self.m.p.setTextScale(self.textScale) ~<10>		end~<10>	local x2,y2 = self.m.p.getSize()~<10>	self.pos:SetPos({1,1,x2,y2})~<10>	if not done then~<10>		local x,y = PhysicSize( x2,y2 , self.textScale)~<10>		self.ppos:SetPos({1,1,x,y})~<10>		local b = WahrscheinlichePos(self,x,y)~<10>		self.m.pos = b~<10>		self.m.size = {x,y,1}~<10>		end~<10>	~<10>	~<10>	-- Create blocks~<10>	local x,y = 1,1~<10>	local _s = self.ppos:Size()~<10>	local tx,ty = 1,1 -- bottomright of the current block !! term ~<10>	--print(~<34>Physical Size      ~<34> .. tostring(_s[1]) .. ~<34>  ~<34> .. tostring(_s[2]) )~<10>	local new = nil~<10>	local t = {0,0}~<10>	self.blocks = {}~<10>	for y = 1,_s[2] do~<10>		tx = 1~<10>		self.blocks[y] = {}~<10>		for x = 1,_s[1] do~<10>			new = TMonitorBlock(self)~<10>			new.lpos = {x,y}~<10>			new.border[1] = (x == 1)~<10>			new.border[2] = (y == 1)~<10>			new.border[3] = (x == _s[1])~<10>			new.border[4] = (y == _s[2])~<10>			t = new:GenerateSize()~<10>			new.pos:SetPos({math.floor(tx),math.floor(ty),math.floor(tx + t[1]-1),math.floor(ty + t[2]-1)})~<10>			self.blocks[y][x] = new~<10>			tx = tx + t[1]~<10>			end~<10>		ty = ty + t[2] -- t[2] stays the same :)~<10>		end~<10>--print(~<34>Calculated TermSize      ~<34> .. tostring(tx-1) .. ~<34>  ~<34> .. tostring(ty-1))~<10>end~<10|10>function TMonitor:GetGPos()~<10>local x,y = 1,1~<10>self.gpos:SetPos({10000,10000,-10000,-10000}) --maximal size for MONITOR SETUP !!! ~<10>local x2,y2 = self.lpos[1],self.lpos[2]~<10>local donex,doney = false,false~<10>-- top get x~<10>if self.parent.blocks[y2-1] then~<10>	local obj = self.parent.blocks[y2-1][x2]~<10>	if obj then~<10>		local gx,gy = obj.parent:LocaltoGlobal(obj.pos[1],obj.pos[2])~<10>		x = gx~<10>		donex = true~<10>		end	~<10>	end~<10>-- left get y~<10>local obj = self.parent.blocks[y2][x2-1]~<10>if obj then~<10>	local gx,gy = obj.parent:LocaltoGlobal(obj.pos[1],obj.pos[2])~<10>	y = gy~<10>	doney = true~<10>	end	~<10>-- top left get x,y~<10>if self.parent.blocks[y2-1] then~<10>	local obj = self.parent.blocks[y2-1][x2-1]~<10>	if obj then~<10>		if not donex then~<10>			local gx,gy = obj.parent:LocaltoGlobal(obj.pos[3],obj.pos[4])~<10>			x = gx+1~<10>			donex = true~<10>			end~<10>		if not doney then~<10>			local gx,gy = obj.parent:LocaltoGlobal(obj.pos[3],obj.pos[4])~<10>			y = gy+1~<10>			doney = true~<10>			end~<10>		end	~<10>	end~<10>-- top get y~<10>if self.parent.blocks[y2-1] then~<10>	local obj = self.parent.blocks[y2-1][x2]~<10>	if obj and (not doney) then~<10>		local gx,gy = obj.parent:LocaltoGlobal(obj.pos[3],obj.pos[4])~<10>		y = gy+1~<10>		doney = true~<10>		end	~<10>	end~<10>-- left get x~<10>local obj = self.parent.blocks[y2][x2-1]~<10>if obj and (not donex) then~<10>	local gx,gy = obj.parent:LocaltoGlobal(obj.pos[3],obj.pos[4])~<10>	x = gx+1~<10>	donex = true~<10>	end	~<10>if (x2 == 1) and (y2 == 1) then~<10>	--ok~<10>	donex = true~<10>	doney = true~<10>	end~<10>if (not (donex and doney)) then~<10>	term.setTextColor(colors.red)~<10>	print(~<34>HELP i think a monitor is not correct installed... ~<34>)~<10>	term.setTextColor(colors.white)~<10>	end~<10>	~<10>local t = self.pos:Size()~<10>self.gpos[1] = x~<10>self.gpos[2] = y~<10>self.gpos[3] = x + t[1] - 1~<10>self.gpos[4] = y + t[2] - 1~<10>end~<10|10>function TMonitor:BlockatPos(_x,_y) -- one block of a physical monitor~<10>local x,y = 1,1~<10>local _s = self.ppos:Size()~<10>for y = 1,_s[2] do~<10>	for x = 1,_s[1] do~<10>		local obj = self.blocks[y][x] ~<10>		if obj.pos:Inside(_x,_y) then~<10>			return obj, x, y 	~<10>			end~<10>		end~<10>	end~<10>end~<10|10>function TMonitor:LoadfromConfig()~<10>local p,o,o2 = nil~<10>local astr = tostring(self.m.side)~<10>p = config:FindAboutC(~<34>Monitor~<34>)~<10>if p then~<10>	p = p:FindAboutC(astr)~<10>	if p then~<10>		-- hey conf is available~<10>		--print(~<34>CONFIG AVAILABLE for ~<34> .. astr)~<10>		o = p:FindAboutC(~<34>ppos~<34>)~<10>		if o then~<10>			self.ppos:SetPos({o:SValuesI(1),o:SValuesI(2),o:SValuesI(3),o:SValuesI(4)})~<10>			end~<10>		o = p:FindAboutC(~<34>textscale~<34>)~<10>		if o then~<10>			self.textScale = o:SValuesI(1)~<10>			end~<10>		return true~<10>		end~<10>	end~<10>return false~<10>end~<10|10>function TMonitor:LocaltoGlobal(_x,_y)~<10>local x,y = 1,1~<10>x = self.gpos[1] + _x - 1~<10>y = self.gpos[2] + _y - 1 ~<10>return x,y~<10>end~<10|10>function TMonitor:GlobaltoLocal(_x,_y)~<10>local x,y = 1,1~<10>x = _x - self.gpos[1] + 1~<10>y = _y - self.gpos[2] + 1 ~<10>return x,y~<10>end~<10|10|10>function TScreen:__init(_name)~<10>	self.mon = vec3.TList(2) -- physikal monitors -- higher id means this monitor is in front !!!~<10>	self.name = _name~<10>	self.blocks = {} -- e.g. 4x5 cluster if you have a max size of 4x5 monitors all in all. Saved are pointers to TMonitor~<10>	self.textScale = 0.5~<10>	self.ppos = vec3.TBox() -- physical pos~<10>	self.pos = vec3.TBox() -- term pos~<10>	self.lpos = vec3.TBox() -- Physical POS where the Screen is at 1 ~<124> 1~<10>	self.info = {}~<10>	self.needredraw = {} -- die linien die ein Neuzeichnen brauchen !~<10>	self.l = Tvwindow()~<10>	self.l:clear()~<10>end~<10|10>function TScreen:valid(x,y)~<10>return (y ~<62> 0) and (y ~<60>= #self.info) and (x ~<62> 0) and (x ~<60>= #self.info[y])~<10>end~<10|10>function TScreen:clear()~<10>self.l:clear()~<10>self.needredraw = {}~<10>for i,obj in ipairs(self.mon) do~<10>	if (obj.side) and (obj.m) then obj.m.clear() end~<10>	end~<10>end~<10|10>function TScreen:SetTextScale(_x)~<10>self.textScale = _x~<10>self:Change()~<10>end~<10|10>function TScreen:GenerateSize()~<10>-- goes trough all MonitorBlocks and test the size of col / row,~<10>local x,y = 1,1~<10>local mx,my = 1,1~<10>local lmx,lmy = 1,1~<10>local obj = nil~<10>for y = 1,#self.blocks do~<10>	lmx =0~<10>	for x = 1,#self.blocks[y] do~<10>		obj = self.blocks[y][x]~<10>		if obj then~<10>			lmx = lmx + obj.pos[3] - obj.pos[1]+1~<10>			end~<10>		end~<10>	if lmx ~<62> mx then ~<10>		mx = lmx~<10>		end~<10>	end~<10>for x = 1,#self.blocks[1] do~<10>	lmy =0~<10>	for y = 1,#self.blocks do~<10>		obj = self.blocks[y][x]~<10>		if obj then~<10>			lmy = lmy + obj.pos[4] - obj.pos[2] +1~<10>			end~<10>		end~<10>	if lmy ~<62> my then ~<10>		my = lmy~<10>		end~<10>	end~<10>self.pos:SetPos({1,1,mx,my})~<10>--print(~<34>SCREEN SIZE ~<34> .. self.pos:InString())~<10>local i,obj = 1,nil~<10>for i,obj in ipairs(self.mon) do~<10>	obj:GetGPos()~<10>	end~<10>return mx,my~<10>end~<10|10>function PhysicSizeRaw( termWidth, termHeight ,textScale)~<10>if textScale == nil then textScale = 0.5 end~<10>local _x = (termWidth*textScale+5)/20~<10>local _y = ((termHeight*textScale-10)/13.34)+1~<10>return _x , _y~<10>end~<10|10|10>function PhysicSize( termWidth, termHeight ,textScale)~<10>local _x,_y = PhysicSizeRaw( termWidth, termHeight ,textScale*2) -- don't ask why ther is a *2. i don't even know either...~<10>return math.floor(_x) , math.floor(_y)~<10>end~<10|10>function DrawSizeRaw( termWidth, termHeight ,textScale)~<10>if textScale == nil then textScale = 0.5 end~<10>local _x = ((termWidth * 20) - 5) / textScale~<10>local _y = ((13.34 * (termHeight - 1)) + 10) / textScale~<10>return  _x , _y~<10>end~<10|10|10>function DrawSize( termWidth, termHeight ,textScale)~<10>local _x,_y = DrawSizeRaw(termWidth, termHeight ,textScale)~<10>if _x ~<60> 0 then _x = 0 end~<10>if _y ~<60> 0 then _y = 0 end~<10>return  math.floor(_x) , math.floor(_y)~<10>end~<10|10>function TScreen:CheckTerm()~<10>local need = true~<10>local termid = -1~<10>for i,obj in ipairs(self.mon) do~<10>	if obj.m:conToSide(~<34>term~<34>) then~<10>		termid = i~<10>		else~<10>		need = false~<10>		end~<10>	end~<10>if need and (termid ~<60> 0) then~<10>	-- add~<10>	boot.BootMsg(~<34>addTerm~<34>)~<10>	local ax,ay = term.getSize() ~<10>	local new = TMonitor(~<34>term~<34>,mperipheral.TermPeripheral,self)~<10>	new.ppos:Clear()~<10>	new.pos:SetPos({1,1,ax,ay})~<10>	new:Change()~<10>	self.mon:Add(new)~<10>	end~<10>if (termid ~<62> -1) and (not need) then~<10>	-- del~<10>	boot.BootMsg(~<34>delTerm~<34>)~<10>	self.mon:Del(termid)~<10>	end~<10>return need~<10>end~<10|10>function TScreen:HasPeripheral(_Peripheral)~<10>local i,obj = 0~<10>for i,obj in ipairs(self.mon) do~<10>	if  obj.m == _Peripheral then~<10>		return true , i~<10>		end~<10>	end~<10>return false , -1~<10>end~<10|10>function TScreen:mPeripheralAdd( _MPeripheral )~<10>if self:HasPeripheral(_MPeripheral) then~<10>	return false~<10>	end~<10>	~<10>local new = TMonitor(~<34|34>,_MPeripheral,self)~<10>new.textScale = self.textScale ~<10>_MPeripheral.p.setTextScale(self.textScale)~<10>-- Fals psize unbekannt !!!	~<10>new:Change()~<10>self.mon:Add(new)~<10>self:CheckTerm()~<10>end~<10|10>function TScreen:mPeripheralDel( _MPeripheral )~<10>local i,obj = 0~<10>for i,obj in ipairs(self.mon) do~<10>	if  obj.m == _MPeripheral then~<10>		self.mon:Del(i)~<10>		self:CheckTerm()~<10>		return true~<10>		end~<10>	end~<10>end~<10|10>function TScreen:PreRender()~<10>local t = self.pos:Size()~<10>self.l.width = t[1] ~<10>self.l.height = t[2]~<10>self.l:clear()for y = 1,t[2] do~<10>	self.info[y] = {}~<10>	for x = 1,t[1] do~<10>		self.info[y][x] = {}~<10>		local a,b,c = self:MonAtPos(x,y)~<10>		if a then~<10>			self.info[y][x] = {a.parent,b,c}			~<10>			end~<10>		~<10>		end	~<10>	end~<10>end~<10|10|10>function TScreen:Change()~<10>-- CALLED ON PHYSICAL CHANGE !!!!~<10>self.ppos:SetPos({10000,10000,-10000,-10000}) --maximal size for MONITOR SETUP !!! ~<10>-- total size~<10>local i,obj = 0,nil~<10>local i2 = 1~<10>for i,obj in ipairs(self.mon) do~<10>	if obj.ppos[1] ~<60> self.ppos[1] then ~<10>		self.ppos[1] = obj.ppos[1]  ~<10>		end~<10>	if obj.ppos[2] ~<60> self.ppos[2] then ~<10>		self.ppos[2] = obj.ppos[2]  ~<10>		end~<10>	if obj.ppos[3] ~<62> self.ppos[3] then ~<10>		self.ppos[3] = obj.ppos[3]  ~<10>		end~<10>	if obj.ppos[4] ~<62> self.ppos[4] then ~<10>		self.ppos[4] = obj.ppos[4]  ~<10>		end~<10>	end~<10>	~<10>-- size of the monitors...~<10>for i,obj in ipairs(self.mon) do~<10>	local x1 = obj.ppos[1]-self.ppos[1]+1~<10>	local y1 = obj.ppos[2]-self.ppos[2]+1~<10>	local x2 = obj.ppos[3]-self.ppos[1]+1~<10>	local y2 = obj.ppos[4]-self.ppos[2]+1~<10>	obj.lpos:SetPos({x1,y1,x2,y2})~<10>	end~<10|10>-- monitor Blocks~<10>local _s = self.ppos:Size()~<10>for y = 1,_s[2] do~<10>	self.blocks[y] = {}~<10>	for x = 1,_s[1] do~<10>		self.blocks[y][x] = self:MonAtPPos(x,y)~<10>		end	~<10>	end~<10>	~<10>-- Display size~<10>self:GenerateSize()~<10>end~<10|10>function TScreen:MonAtPPos(_px , _py) --physical~<10>local i = #self.mon~<10>for i = #self.mon,1,-1 do~<10>	obj = self.mon[i]~<10>	if obj.lpos:Inside(_px,_py) then~<10>		local lx,ly = 1,1~<10>		lx = _px-obj.lpos[1]+1~<10>		ly = _py-obj.lpos[2]+1~<10>		return obj.blocks[ly][lx]~<10>		end~<10>	end~<10>return nil~<10>end~<10|10>function TScreen:MonAtPos(_px , _py) -- term~<10>local i = #self.mon~<10>for i = #self.mon,1,-1 do~<10>	obj = self.mon[i]~<10>	if obj.gpos:Inside(_px,_py) then~<10>		local lx,ly = obj:GlobaltoLocal(_px,_py)~<10>		local p = obj:BlockatPos(lx,ly)~<10>		if p then~<10>			return p , lx,ly	~<10>			end~<10>		end~<10>	end~<10>return nil , 0 , 0~<10>end~<10|10>function TScreen:WritePos(_x, _y ,text , color , bgcolor)~<10>self.l:writePos(_x,_y,text , color , bgcolor)~<10>self.needredraw[_y] = true~<10>end~<10|10>function TScreen:Flush()~<10>local a,b,c = nil~<10>local la,lx = nil~<10>local atext = ~<34> ~<34|10>local astr = ~<34|34|10>local color,lcolor = nil~<10>local bcolor,lbcolor = nil~<10>local apuf = {}~<10>local p = nil~<10>for _y = 1,#self.info do~<10>	if self.needredraw[_y] then ~<10>		la = nil~<10>		astr = self.l:GetLine(_y)~<10>		if #self.info[_y] ~<62> 0 then~<10>			-- initial~<10>			la = self.info[_y][1][1]~<10>			b = self.info[_y][1][2]~<10>			c = self.info[_y][1][3]~<10>			lcolor = self.l.colors[_y][1]~<10>			lbcolor = self.l.bcolors[_y][1]~<10>			lx = 1~<10>			end~<10>		for _x = 1,#self.info[_y] do~<10>			apuf = self.info[_y][_x]~<10>			a = apuf[1]~<10>			color = self.l.colors[_y][_x]~<10>			bcolor = self.l.bcolors[_y][_x]~<10>			--[[~<10>			-- UNCOMMENT if you want to know the bounds of your monitor...~<10>			-- or test the mView Render. This is 100% correct but very slow !!!~<10>			if a then~<10>				atext = string.char(string.byte(astr,_x))~<10>				a.m.p.setCursorPos(apuf[2],apuf[3])~<10>				a.m.p.setTextColor(color)~<10>				a.m.p.write(atext)~<10>				end]]~<10|10>			if ((a ~<126>= la) or (lcolor ~<126>= color)  or (lbcolor ~<126>= bcolor)) and (la ~<126>= nil) then~<10>				atext = string.sub(astr,lx,_x-1)~<10>				p = la.m.p ~<10>				p.setCursorPos(b,c) -- ERROR HERE IF MONITOR DEATACHED !!!~<10>				if p.isColor() then~<10>					p.setBackgroundColor(lbcolor)~<10>					p.setTextColor(lcolor)~<10>					end~<10>				p.write(atext)~<10>				la = a~<10>				b = apuf[2]~<10>				c = apuf[3]~<10>				lcolor = color~<10>				lbcolor = bcolor~<10>				lx = _x~<10>				end~<10>			end~<10>		if (la ~<126>= nil) then~<10>			atext = string.sub(astr,lx)~<10>			p = la.m.p ~<10>			p.setCursorPos(b,c)~<10>			if p.isColor() then~<10>				p.setTextColor(lcolor)~<10>				p.setBackgroundColor(lbcolor)~<10>				end~<10>			p.write(atext)~<10>			end~<10>		self.needredraw[_y] = false~<10>		end~<10>	end~<10>end~<10|10>function Reset()~<10>--main:detect( driver.driver_sides, _psize)~<10>main:Change()~<10>main:PreRender()~<10>main:clear()~<10>end~<10|10>function WahrscheinlichePos(mon,sizex,sizey)~<10>if mon.m:conToSide(~<34>left~<34>) then~<10>	return {-sizex , 0 , 0}~<10>elseif mon.m:conToSide(~<34>right~<34>) then~<10>	return {1 , 0 , 0}~<10>elseif mon.m:conToSide(~<34>top~<34>) then~<10>	return {0 , -sizey , 0}~<10>elseif mon.m:conToSide(~<34>bottom~<34>) then~<10>	return {0 , 1 , 0}~<10>elseif mon.m:conToSide(~<34>front~<34>) then~<10>	return {0 , 0 , 1}~<10>else~<10>	return {0 , 0 , -1}~<10>	end~<10>end~<10|10>config:LoadfromFile(path.C(path.DATA(),~<34>/mView/screen~<34>))~<10>main = TScreen(~<34>main~<34>)~<10>main.textScale = 0.5~<10>second = TScreen(~<34>main~<34>)~<10>second.textScale = 0.5~<10|10|10>function API_Initial()~<10>new = events.CreateEvent(~<34>Initialised~<34>,~<34>mView~<34>, ~<34>mView~<34>)~<10>mTask.RawRaiseEvent(new)~<10>if main:CheckTerm() then~<10>	main:Change()~<10>	main:PreRender()~<10>	main:clear()~<10>	main:Flush()~<10>	end~<10>if second:CheckTerm() then~<10>	second:Change()~<10>	second:PreRender()~<10>	second:clear()~<10>	second:Flush()~<10>	end~<10>end>>file<0||name<0|path>path<0|marcelOS/apis/path>data<0|boot.BootMsg(~<34>starting path~<34>)~<10>local osPath = ~<34>marcelOS~<34|10>local apisPath = ~<34>apis~<34|10>local dataPath = ~<34>data~<34|10>local autorunPath = ~<34>autorun~<34|10>local tempPath = ~<34>temp~<34|10>local userPath = ~<34>user~<34|10>local userautostartPath = ~<34>autostart~<34|10>local driverPath = ~<34>drivers~<34|10>local programsPath = ~<34>programs~<34|10|10>function FOLDER(apath)~<10>apath = tostring(apath)~<10>if string.char(string.byte(apath,apath:len())) ~<126>= '/' then~<10>	return apath..~<34>/~<34|10>	else~<10>	return apath~<10>	end~<10>end~<10|10>function ROOT(apath)~<10>apath = tostring(apath)~<10>if string.char(string.byte(apath)) ~<126>= '/' then~<10>	return ~<34>/~<34>..apath~<10>	else~<10>	return apath~<10>	end~<10>end~<10|10>function UNROOT(apath)~<10>apath = tostring(apath)~<10>if string.char(string.byte(apath)) ~<126>= '/' then~<10>	return apath~<10>	else~<10>	return apath:sub(2)~<10>	end~<10>end~<10|10>function C(astr,bstr,...) -- Combined Both to a Valid Path with nether / at beginning nor at End~<10>astr = UNROOT(astr)~<10>astr = FOLDER(astr)~<10>local result = ~<34|34|10>if string.char(string.byte(bstr)) == '/' then~<10>	bstr = string.sub(bstr,2,string.len(bstr))~<10>	end~<10>if string.char(string.byte(bstr,bstr:len())) == '/' then~<10>	bstr = string.sub(bstr,1,string.len(bstr)-1)~<10>	end~<10>result = astr .. bstr~<10>local add = {...}~<10>local i,obj = 0,nil~<10>for i,obj in ipairs(add) do~<10>	result = C(result,obj)~<10>	end~<10>if (result ~<126>= ~<34>/~<34>) and (string.char(string.byte(result,result:len())) == '/') then -- be sure that it doesnt end with / . except ~<34>/~<34|10>	result = string.sub(result,1,string.len(result)-1)~<10>	end~<10>return result~<10>end~<10|10>function CR(astr,bstr,...) -- Combined Both to a Valid Path with / at beginning but none at End~<10>return ROOT(C(astr,bstr,...))~<10>end~<10|10>function OS()~<10>return ROOT(osPath)~<10>end~<10|10>function APIS()~<10>return ROOT(fs.combine(osPath,apisPath))~<10>end~<10|10>function DATA()~<10>return ROOT(fs.combine(osPath,dataPath))~<10>end~<10|10>function AUTORUN()~<10>return ROOT(fs.combine(osPath,autorunPath))~<10>end~<10|10>function USER()~<10>return ROOT(userPath)~<10>end~<10|10>function DRIVERS()~<10>return ROOT(fs.combine(osPath,driverPath))~<10>end~<10|10>function TEMP()~<10>return ROOT(fs.combine(osPath,tempPath))~<10>end~<10|10>function PROGRAMS()~<10>return ROOT(fs.combine(osPath,programsPath))~<10>end~<10|10>function USERAUTOSTART()~<10>return ROOT(fs.combine(userPath,userautostartPath))~<10>end>>file<0||name<0|programs>path<0|marcelOS/apis/programs>data<0|local data = ehtf.THTNode()~<10>boot.BootMsg(~<34>starting programs~<34>)~<10|10>function GetFileExt(_ext)~<10>local i,obj~<10>local p = data:FindAboutC(~<34>fileext~<34>)~<10>if p then~<10>	for i,obj in ipairs(p.nodes) do~<10>		local o = obj:FindAboutC(~<34>ext~<34>)~<10>		if o and (o:SValuesS(1) == _ext) then~<10>			local p2 = obj:FindAboutC(~<34>dll~<34>)~<10>			if p2 then~<10>				return p2:SValuesS(1)~<10>				end~<10>			end~<10>		end~<10>	end~<10>return nil~<10>end~<10|10>function OpenFile(file,arg,name)~<10>local _ext = mStrings.FileEnding(file)~<10>local prg = GetFileExt(_ext)~<10>if prg then~<10>	local co = mTask.CreateTask( name or prg )~<10>	co.file = prg~<10>	co.args:Insert(file,1)~<10>	local i,obj = 1,nil~<10>	for i,obj in ipairs(arg or {}) do~<10>		co.args:Add(obj)~<10>		end~<10>	co:run()~<10>	return true~<10>	end~<10>return false~<10>end~<10|10>function API_Initial()~<10>data:LoadfromFile(path.C(path.DATA() , ~<34>programs~<34>,~<34>settings.ehtf~<34>))~<10>end>>file<0||name<0|sha1>path<0|marcelOS/apis/sha1>data<0|-------------------------------------------------------------------------------~<10>-- SHA-1 secure hash computation, and HMAC-SHA1 signature computation,~<10>-- in pure Lua (tested on Lua 5.1)~<10>-- License: MIT~<10>--~<10>-- Usage:~<10>--   local hash_as_hex   = sha1(message)            -- returns a hex string~<10>--   local hash_as_data  = sha1_binary(message)     -- returns raw bytes~<10>--~<10>--   local hmac_as_hex   = hmac_sha1(key, message)        -- hex string~<10>--   local hmac_as_data  = hmac_sha1_binary(key, message) -- raw bytes~<10>--~<10>--~<10>-- Pass sha1() a string, and it returns a hash as a 40-character hex string.~<10>-- For example, the call~<10>--~<10>--   local hash = sha1 ~<34>http://regex.info/blog/~<34|10>--~<10>-- puts the 40-character string~<10>--~<10>--   ~<34>7f103bf600de51dfe91062300c14738b32725db5~<34|10>--~<10>-- into the variable 'hash'~<10>--~<10>-- Pass sha1_hmac() a key and a message, and it returns the signature as a~<10>-- 40-byte hex string.~<10>--~<10>--~<10>-- The two ~<34>_binary~<34> versions do the same, but return the 20-byte string of raw~<10>-- data that the 40-byte hex strings represent.~<10>--~<10>-------------------------------------------------------------------------------~<10>--~<10>-- based on Jeffrey Friedl's implementation (which I found a bit too slow)~<10>-- ~<62> jfriedl@yahoo.com~<10>-- ~<62> http://regex.info/blog/~<10>-- ~<62> Version 1 [May 28, 2009]~<10>-- The original implementation is about 10 times slower, so you might prefer~<10>-- this one.~<10>--~<10>-- Description~<10>-- Due to the lack of bitwise operations in 5.1, this version uses numbers to~<10>-- represents the 32bit words that we combine with binary operations. The basic~<10>-- operations of byte based ~<34>xor~<34>, ~<34>or~<34>, ~<34>and~<34> are all cached in a combination~<10>-- table (several 64k large tables are built on startup, which~<10>-- consumes some memory and time). The caching can be switched off through~<10>-- setting the local cfg_caching variable to false.~<10>-- For all binary operations, the 32 bit numbers are split into 8 bit values~<10>-- that are are then combined and then merged again.~<10>--~<10>-- Algorithm: http://www.itl.nist.gov/fipspubs/fip180-1.htm~<10>--~<10>--~<10>-------------------------------------------------------------------------------~<10>--~<10>-- modded by Marcel Märtens ,xMAC94x ~<10>-- for using in Minecraft. Added adler32~<10>-- no generating on startup !~<10>--~<10>-------------------------------------------------------------------------------~<10>-------------------------------------------------------------------------------~<10|10>-- set this to false if you don't want to build several 64k sized tables when~<10>-- loading this file (takes a while but grants a boost of factor 13)~<10>local cfg_caching = true~<10>local initialised_cache = false~<10>local xor_with_0x5c = {}~<10>local xor_with_0x36 = {}~<10>boot.BootMsg(~<34>starting sha1~<34>)~<10|10>-- local storing of global functions (minor speedup)~<10>local floor,modf = math.floor,math.modf~<10>local char,format,rep = string.char,string.format,string.rep~<10|10>-- merge 4 bytes to an 32 bit word~<10>local function bytes_to_w32 (a,b,c,d) return a*0x1000000+b*0x10000+c*0x100+d end~<10>-- split a 32 bit word into four 8 bit numbers~<10>local function w32_to_bytes (i)~<10>	return floor(i/0x1000000)%0x100,floor(i/0x10000)%0x100,floor(i/0x100)%0x100,i%0x100~<10>end~<10|10>-- shift the bits of a 32 bit word. Don't use negative values for ~<34>bits~<34|10>local function w32_rot (bits,a)~<10>	local b2 = 2^(32-bits)~<10>	local a,b = modf(a/b2)~<10>	return a+b*b2*(2^(bits))~<10>end~<10|10>-- caching function for functions that accept 2 arguments, both of values between~<10>-- 0 and 255. The function to be cached is passed, all values are calculated~<10>-- during loading and a function is returned that returns the cached values (only)~<10>local function cache2arg (fn)~<10>	if not cfg_caching then return fn end~<10>	local lut = {}~<10>	for i=0,0xffff do~<10>		local a,b = floor(i/0x100),i%0x100~<10>		lut[i] = fn(a,b)~<10>	end~<10>	return function (a,b)~<10>		return lut[a*0x100+b]~<10>	end~<10>end~<10|10>-- splits an 8-bit number into 8 bits, returning all 8 bits as booleans~<10>local function byte_to_bits (b)~<10>	local b = function (n)~<10>		local b = floor(b/n)~<10>		return b%2==1~<10>	end~<10>	return b(1),b(2),b(4),b(8),b(16),b(32),b(64),b(128)~<10>end~<10|10>-- builds an 8bit number from 8 booleans~<10>local function bits_to_byte (a,b,c,d,e,f,g,h)~<10>	local function n(b,x) return b and x or 0 end~<10>	return n(a,1)+n(b,2)+n(c,4)+n(d,8)+n(e,16)+n(f,32)+n(g,64)+n(h,128)~<10>end~<10|10>-- debug function for visualizing bits in a string~<10>local function bits_to_string (a,b,c,d,e,f,g,h)~<10>	local function x(b) return b and ~<34>1~<34> or ~<34>0~<34> end~<10>	return (~<34>%s%s%s%s %s%s%s%s~<34>):format(x(a),x(b),x(c),x(d),x(e),x(f),x(g),x(h))~<10>end~<10|10>-- debug function for converting a 8-bit number as bit string~<10>local function byte_to_bit_string (b)~<10>	return bits_to_string(byte_to_bits(b))~<10>end~<10|10>-- debug function for converting a 32 bit number as bit string~<10>local function w32_to_bit_string(a)~<10>	if type(a) == ~<34>string~<34> then return a end~<10>	local aa,ab,ac,ad = w32_to_bytes(a)~<10>	local s = byte_to_bit_string~<10>	return (~<34>%s %s %s %s~<34>):format(s(aa):reverse(),s(ab):reverse(),s(ac):reverse(),s(ad):reverse()):reverse()~<10>end~<10|10>boot.BootYield()	~<10>function Initialise()~<10>if initialised_cache then ~<10>	return~<10>	end~<10>initialised_cache = true~<10>-- bitwise ~<34>and~<34> function for 2 8bit number~<10>local band = cache2arg (function(a,b)~<10>	local A,B,C,D,E,F,G,H = byte_to_bits(b)~<10>	local a,b,c,d,e,f,g,h = byte_to_bits(a)~<10>	return bits_to_byte(~<10>		A and a, B and b, C and c, D and d,~<10>		E and e, F and f, G and g, H and h)~<10>end)~<10|10>-- bitwise ~<34>or~<34> function for 2 8bit numbers~<10>local bor = cache2arg(function(a,b)~<10>	local A,B,C,D,E,F,G,H = byte_to_bits(b)~<10>	local a,b,c,d,e,f,g,h = byte_to_bits(a)~<10>	return bits_to_byte(~<10>		A or a, B or b, C or c, D or d,~<10>		E or e, F or f, G or g, H or h)~<10>end)~<10>	~<10>-- bitwise ~<34>xor~<34> function for 2 8bit numbers~<10>local bxor = cache2arg(function(a,b)~<10>	local A,B,C,D,E,F,G,H = byte_to_bits(b)~<10>	local a,b,c,d,e,f,g,h = byte_to_bits(a)~<10>	return bits_to_byte(~<10>		A ~<126>= a, B ~<126>= b, C ~<126>= c, D ~<126>= d,~<10>		E ~<126>= e, F ~<126>= f, G ~<126>= g, H ~<126>= h)~<10>end)~<10>-- building the lookuptables ahead of time (instead of littering the source code~<10>-- with precalculated values)~<10>for i=0,0xff do~<10>	xor_with_0x5c[char(i)] = char(bxor(i,0x5c))~<10>	xor_with_0x36[char(i)] = char(bxor(i,0x36))~<10>end~<10|10>end~<10|10>-- bitwise complement for one 8bit number~<10>local function bnot (x)~<10>	return 255-(x % 256)~<10>end~<10|10>-- creates a function to combine to 32bit numbers using an 8bit combination function~<10>local function w32_comb(fn)~<10>	return function (a,b)~<10>		local aa,ab,ac,ad = w32_to_bytes(a)~<10>		local ba,bb,bc,bd = w32_to_bytes(b)~<10>		return bytes_to_w32(fn(aa,ba),fn(ab,bb),fn(ac,bc),fn(ad,bd))~<10>	end~<10>end~<10|10>boot.BootYield()	~<10>-- create functions for and, xor and or, all for 2 32bit numbers~<10>local w32_and = w32_comb(band)~<10>local w32_xor = w32_comb(bxor)~<10>local w32_or = w32_comb(bor)~<10|10>-- xor function that may receive a variable number of arguments~<10>local function w32_xor_n (a,...)~<10>	local aa,ab,ac,ad = w32_to_bytes(a)~<10>	for i=1,select('#',...) do~<10>		local ba,bb,bc,bd = w32_to_bytes(select(i,...))~<10>		aa,ab,ac,ad = bxor(aa,ba),bxor(ab,bb),bxor(ac,bc),bxor(ad,bd)~<10>	end~<10>	return bytes_to_w32(aa,ab,ac,ad)~<10>end~<10|10>-- combining 3 32bit numbers through binary ~<34>or~<34> operation~<10>local function w32_or3 (a,b,c)~<10>	local aa,ab,ac,ad = w32_to_bytes(a)~<10>	local ba,bb,bc,bd = w32_to_bytes(b)~<10>	local ca,cb,cc,cd = w32_to_bytes(c)~<10>	return bytes_to_w32(~<10>		bor(aa,bor(ba,ca)), bor(ab,bor(bb,cb)), bor(ac,bor(bc,cc)), bor(ad,bor(bd,cd))~<10>	)~<10>end~<10|10>-- binary complement for 32bit numbers~<10>local function w32_not (a)~<10>	return 4294967295-(a % 4294967296)~<10>end~<10|10>-- adding 2 32bit numbers, cutting off the remainder on 33th bit~<10>local function w32_add (a,b) return (a+b) % 4294967296 end~<10|10>-- adding n 32bit numbers, cutting off the remainder (again)~<10>local function w32_add_n (a,...)~<10>	for i=1,select('#',...) do~<10>		a = (a+select(i,...)) % 4294967296~<10>	end~<10>	return a~<10>end~<10>-- converting the number to a hexadecimal string~<10>local function w32_to_hexstring (w) return format(~<34>%08x~<34>,w) end~<10|10>-- calculating the SHA1 for some text~<10>function sha1(msg)~<10>	Initialise()~<10>	local H0,H1,H2,H3,H4 = 0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0~<10>	local msg_len_in_bits = #msg * 8~<10|10>	local first_append = char(0x80) -- append a '1' bit plus seven '0' bits~<10|10>	local non_zero_message_bytes = #msg +1 +8 -- the +1 is the appended bit 1, the +8 are for the final appended length~<10>	local current_mod = non_zero_message_bytes % 64~<10>	local second_append = current_mod~<62>0 and rep(char(0), 64 - current_mod) or ~<34|34|10|10>	-- now to append the length as a 64-bit number.~<10>	local B1, R1 = modf(msg_len_in_bits  / 0x01000000)~<10>	local B2, R2 = modf( 0x01000000 * R1 / 0x00010000)~<10>	local B3, R3 = modf( 0x00010000 * R2 / 0x00000100)~<10>	local B4	  =	0x00000100 * R3~<10|10>	local L64 = char( 0) .. char( 0) .. char( 0) .. char( 0) -- high 32 bits~<10>				.. char(B1) .. char(B2) .. char(B3) .. char(B4) --  low 32 bits~<10|10>	msg = msg .. first_append .. second_append .. L64~<10|10>	assert(#msg % 64 == 0,~<34>ff~<34>)~<10|10>	local chunks = #msg / 64~<10|10>	local W = { }~<10>	local start, A, B, C, D, E, f, K, TEMP~<10>	local chunk = 0~<10|10>	while chunk ~<60> chunks do~<10>		--~<10>		-- break chunk up into W[0] through W[15]~<10>		--~<10>		start,chunk = chunk * 64 + 1,chunk + 1~<10|10>		for t = 0, 15 do~<10>			W[t] = bytes_to_w32(msg:byte(start, start + 3))~<10>			start = start + 4~<10>		end~<10|10>		--~<10>		-- build W[16] through W[79]~<10>		--~<10>		for t = 16, 79 do~<10>			-- For t = 16 to 79 let Wt = S1(Wt-3 XOR Wt-8 XOR Wt-14 XOR Wt-16).~<10>			W[t] = w32_rot(1, w32_xor_n(W[t-3], W[t-8], W[t-14], W[t-16]))~<10>		end~<10|10>		A,B,C,D,E = H0,H1,H2,H3,H4~<10|10>		for t = 0, 79 do~<10>			if t ~<60>= 19 then~<10>				-- (B AND C) OR ((NOT B) AND D)~<10>				f = w32_or(w32_and(B, C), w32_and(w32_not(B), D))~<10>				K = 0x5A827999~<10>			elseif t ~<60>= 39 then~<10>				-- B XOR C XOR D~<10>				f = w32_xor_n(B, C, D)~<10>				K = 0x6ED9EBA1~<10>			elseif t ~<60>= 59 then~<10>				-- (B AND C) OR (B AND D) OR (C AND D~<10>				f = w32_or3(w32_and(B, C), w32_and(B, D), w32_and(C, D))~<10>				K = 0x8F1BBCDC~<10>			else~<10>				-- B XOR C XOR D~<10>				f = w32_xor_n(B, C, D)~<10>				K = 0xCA62C1D6~<10>			end~<10|10>			-- TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt;~<10>			A,B,C,D,E = w32_add_n(w32_rot(5, A), f, E, W[t], K),~<10>				A, w32_rot(30, B), C, D~<10>		end~<10>		-- Let H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.~<10>		H0,H1,H2,H3,H4 = w32_add(H0, A),w32_add(H1, B),w32_add(H2, C),w32_add(H3, D),w32_add(H4, E)~<10>	end~<10>	local f = w32_to_hexstring~<10>	return f(H0) .. f(H1) .. f(H2) .. f(H3) .. f(H4)~<10>end~<10|10>local function hex_to_binary(hex)~<10>	return hex:gsub('..', function(hexval)~<10>		return string.char(tonumber(hexval, 16))~<10>	end)~<10>end~<10|10>function sha1_binary(msg)~<10>	return hex_to_binary(sha1(msg))~<10>end~<10|10>boot.BootYield()	~<10>local blocksize = 64 -- 512 bits~<10|10>function hmac_sha1(key, text)~<10>	assert(type(key)  == 'string', ~<34>key passed to hmac_sha1 should be a string~<34>)~<10>	assert(type(text) == 'string', ~<34>text passed to hmac_sha1 should be a string~<34>)~<10|10>	if #key ~<62> blocksize then~<10>		key = sha1_binary(key)~<10>	end~<10|10>	local key_xord_with_0x36 = key:gsub('.', xor_with_0x36) .. string.rep(string.char(0x36), blocksize - #key)~<10>	local key_xord_with_0x5c = key:gsub('.', xor_with_0x5c) .. string.rep(string.char(0x5c), blocksize - #key)~<10|10>	return sha1(key_xord_with_0x5c .. sha1_binary(key_xord_with_0x36 .. text))~<10>end~<10|10>function hmac_sha1_binary(key, text)~<10>	return hex_to_binary(hmac_sha1(key, text))~<10>end>>file<0||name<0|vec3>path<0|marcelOS/apis/vec3>data<0|-- marcelOS functions~<10>-- Table functions~<10|10>boot.BootMsg(~<34>starting vec3~<34>)~<10|10>TList = classapi.class(nil,~<34>TList~<34>) ~<10|10>function TList:__init(_mode)~<10>	self.mode = _mode or 1 -- ~<34>1/data~<34> = only Data Matters, order is not important ~<34>2/stack~<34> don't change order ! , ~<34>3/queue~<34> = data in at lowest pos~<10>end~<10|10>function TList:Add(_obj)~<10>if (self.mode == 1) or (self.mode == 2) then~<10>	self[#self+1] = _obj~<10>	elseif self.mode == 3 then~<10>		self:Insert(_obj,1)~<10>		end~<10>return _obj,#self~<10>end~<10|10>function TList:AddOnce(_obj) -- Adds a Item if it doesn't exitst in List ! otherwhise return current~<10>local pos = self:IndexOf(_obj)~<10>if pos ~<62> -1 then~<10>	return self[pos], pos~<10>	else~<10>	self:Add(_obj)~<10>	end~<10>end~<10|10>function TList:Del(_i)~<10>if (self.mode == 1) then~<10>	self[_i] = self[#self]~<10>	self[#self] = nil~<10>	elseif (self.mode == 2) or (self.mode == 3) then~<10>		self:MoveDown(_i)~<10>		end~<10>end~<10|10>function TList:MoveUp(_from)~<10>local i = 0~<10>for i = #self,_from,-1 do~<10>	self[i+1] = self[i]~<10>	end~<10>end~<10|10>function TList:MoveDown(_from)~<10>local i = 0~<10>for i = _from,#self do~<10>	self[i] = self[i+1]~<10>	end~<10>end~<10|10>function TList:Insert(_obj,_pos)~<10>self:MoveUp(_pos)~<10>self[_pos] = _obj~<10>return _obj~<10>end~<10|10>function TList:IndexOf(_obj)~<10>local i = 0~<10>for i = 1,#self do~<10>	if self[i] == _obj then~<10>		return i~<10>		end~<10>	end~<10>return -1~<10>end~<10|10>function TList:Inc(_obj)~<10>local x = _obj~<10>if type(_obj) ~<126>= ~<34>number~<34> then~<10>	x = self:IndexOf(_obj)~<10>	end~<10>if x ~<60> 1 then~<10>	if (self.mode == 1) or (self.mode == 2) then~<10>		x = 1~<10>		elseif (self.mode == 3) then~<10>			x = #self~<10>			end~<10>	return self[x]	~<10>	end~<10>x = x + 1~<10>if x ~<62> #self then x = 1 end~<10>return self[x] , x~<10>end~<10|10>function TList:Dec(_obj)~<10>local x = _obj~<10>if type(_obj) ~<126>= ~<34>number~<34> then~<10>	x = self:IndexOf(_obj)~<10>	end~<10>if x ~<60> 1 then~<10>	if (self.mode == 1) or (self.mode == 2) then~<10>		x = 1~<10>		elseif (self.mode == 3) then~<10>			x = #self~<10>			end~<10>	return self[x]~<10>	end~<10>x = x - 1~<10>if x ~<60> 1 then x = #self end~<10>return self[x] ,x ~<10>end~<10|10>TBox = classapi.class(nil,~<34>TBox~<34>)~<10|10>function TBox:__init(_pos)~<10>	if _pos then~<10>		self[1] = _pos[1] or 0 --left~<10>		self[2] = _pos[2] or 0 --top~<10>		self[3] = _pos[3] or 0 --right~<10>		self[4] = _pos[4] or 0 --bottom~<10>		else~<10>		self[1] = 0 --left~<10>		self[2] = 0 --top~<10>		self[3] = 0 --right~<10>		self[4] = 0 --bottom~<10>		end~<10>end~<10> ~<10>function TBox:TopLeft(_pos)~<10>if _pos then~<10>	self[1] = _pos[1] or self[1] --left~<10>	self[2] = _pos[2] or self[1] --top~<10>	end~<10>return {self[1],self[2]}~<10>end~<10|10>function TBox:BottomRight(_pos)~<10>if _pos then~<10>	self[3] = _pos[1] or self[3] --left~<10>	self[4] = _pos[2] or self[4] --top~<10>	end~<10>return {self[3],self[4]}~<10>end~<10|10>function TBox:Size()~<10>	return {self[3]-self[1]+1,self[4]-self[2]+1}~<10>end~<10|10>function TBox:Clear()~<10>self[1] = 0~<10>self[2] = 0~<10>self[3] = 0~<10>self[4] = 0~<10>end~<10|10>function TBox:SetPos(_pos)~<10>self[1] = _pos[1] or 0 --left~<10>self[2] = _pos[2] or 0 --top~<10>self[3] = _pos[3] or 0 --right~<10>self[4] = _pos[4] or 0 --bottom~<10>end~<10|10>function TBox:Inside(_x,_y)~<10>return (_x ~<62>= self[1]) and (_x ~<60>= self[3]) and (_y ~<62>= self[2]) and (_y ~<60>= self[4])~<10>end~<10|10>function TBox:InString()~<10>local result = ~<34>( ~<34> .. tostring(self[1]) .. ~<34> ~<34> .. tostring(self[2]) .. ~<34> ~<34> .. tostring(self[3]) .. ~<34> ~<34> .. tostring(self[4]) .. ~<34> )~<34> ~<10>return result~<10>end~<10|10>function round(num, idp)~<10>  local mult = 10^(idp or 0)~<10>  return math.floor(num * mult + 0.5) / mult~<10>end~<10|10>function PrintVec(_a)~<10>local result = ~<34|34|10>local i = 0~<10>for i in ipairs(_a) do ~<10>	result = result .. tostring(i) .. ~<34>: ~<34> .. tostring( _a[i] ) .. ~<34>   ~<34|10>	end~<10>return result~<10>end~<10|10>function contains(_a , _b)~<10>local i,obj = 0,nil~<10>for i,obj in ipairs(_a) do~<10>	if obj == _b then~<10>		return true , i~<10>		end~<10>	end~<10>return false, -1~<10>end~<10|10>function AddCon(_a , _b)~<10>local a,b = contains(_a , _b)~<10>if not a then~<10>	_a[#_a+1] = _b~<10>	end~<10>end~<10|10>function insertPos(_a, _b, _c)~<10>local i,obj = 0,nil~<10>for i = #_a,_c,-1 do~<10>	_a[i+1] = _a[i]~<10>	end~<10>_a[_c] = _b~<10>end~<10|10>function insertVec(_a , _b)~<10>local result = _a~<10>local i,obj = 0,nil~<10>for i,obj in ipairs(_b) do~<10>	local a = contains(result,obj)~<10>	if not a then~<10>		result[#result+1] = obj~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function Nil( _a )~<10>local result = {}~<10>for i in ipairs(_a) do result[i] = 0 end~<10>return result~<10>end ~<10|10>function Copy( _a )~<10>local result = {}~<10>local i,obj = 0,nil~<10>for i,obj in pairs(_a) do~<10>	result[i] = obj~<10>	end~<10>return result~<10>end~<10|10>function Add( _a , _b)~<10>local result = {}~<10>local i = 0~<10>for i in ipairs(_a) do  result[i] = _a[i] + _b[i] end~<10>return result~<10>end~<10|10>function Dec( _a , _b)~<10>local result = {}~<10>local i = 0~<10>for i in ipairs(_a) do result[i] = _a[i] - _b[i] end~<10>return result~<10>end~<10|10>function Mult( _a , _b)~<10>local result = 0~<10>local i = 0~<10>for i in ipairs(_a) do result = result + _a[i] * _b[i] end~<10>return result~<10>end~<10|10>function MultInt( _a , _b)~<10>local result = {}~<10>local i = 0~<10>for i in ipairs(_a) do result[i] = _a[i] * _b end~<10>return result~<10>end~<10|10>function MultVec( _a , _b)~<10>local result = {}~<10>local i = 0~<10>for i in ipairs(_a) do result[i] = _a[i] * _b[i] end~<10>return result~<10>end~<10|10>function Div( _a , _b)~<10>local result = {}~<10>local i = 0~<10>for i in ipairs(_a) do result[i] = _a[i] / _b[i] end~<10>return result~<10>end>>file<0||name<0|windows>path<0|marcelOS/apis/windows>data<0|-- marcelOS windows functions~<10>boot.BootMsg(~<34>starting windows~<34>)~<10|10>local window = vec3.TList()~<10>TWindow = classapi.class(winobj.TWinObj,~<34>TWindow~<34>) ~<10>local needreDraw = false~<10>local active = nil~<10|10>-- DONT USE THIS~<10|10>function TWindow_Selected(self,strict)~<10>return (GetActive() == self) and ((not strict) or (self.selobj == nil))~<10>end~<10|10|10>function TWindow:__init(_name, _task)~<10>    self.name = _name or ~<34|34|10>	self.task = (_task or mTask.RunningTask())~<10>	self.obj = vec3.TList() -- WinObjs in a Window !~<10>	self.margin = 2~<10> 	self.l = mView.Tvwindow()~<10>	self.width = 49~<10>	self.height = 17~<10>	self.l:SetSize(self.width,self.height)~<10>	window[#window+1] = self~<10>	self.Selected = TWindow_Selected~<10>	self.Monitor = mView.main -- THIS is the virtuall Monitor where to Render :D~<10>end~<10|10>function TWindow:contains(x,y)~<10>return (x ~<62>= self.left) and (x ~<60>= self:right()) and (y ~<62>= self.top) and (y ~<60>= self:bottom())~<10>end~<10|10>function TWindow:SetPos(x,y)~<10>self:DrawClear()~<10>self.left = x~<10>self.top = y~<10>Invalidate()~<10>end~<10|10>function TWindow:SetSize(x,y)~<10>self.width = x~<10>self.height = y~<10>self.l:SetSize(x,y)~<10>Invalidate()~<10>end~<10|10>function TWindow:hide()~<10>self.visible = false~<10>self:DrawClear()~<10>Invalidate()~<10>end~<10|10>function TWindow:show()~<10>self.visible = true~<10>Invalidate()~<10>end~<10|10>function TWindow:FullScreen(raiseevent) -- using the PHYSICAL Monitor, not the Virtual Screen here !~<10>local a,b,c = self.Monitor:MonAtPos(self.left,self.top)~<10>if not a then~<10>	a,b,c = self.Monitor:MonAtPos(self.left+self.width,self.top+self.height)~<10>	end~<10>if a then~<10>	local obj = a.parent~<10>	self.left = obj.gpos[1]~<10>	self.top = obj.gpos[2]~<10>	self.width = obj.gpos[3]- obj.gpos[1] -1 ~<10>	self.height = obj.gpos[4]- obj.gpos[2] - 2~<10>	Invalidate()	~<10>	if raiseevent and (self.task) then~<10>		new = events.CreateEvent(~<34>window_fullscreen~<34>,~<34>windows~<34>,obj,self)~<10>		mTask.RaiseHandleEvent(self.task,new)~<10>		end~<10>	end~<10|10>end~<10|10>function TWindow:ChangeMonitor(_new,raiseevent) ~<10>if _new ~<126>= self.Monitor then~<10>	self:DrawClear()~<10>	local old = self.Monitor~<10>	self.Monitor = _new~<10>	self.left = 1~<10>	self.top = 1~<10>	Invalidate()~<10>	if raiseevent and (self.task) then~<10>		new = events.CreateEvent(~<34>window_monitor~<34>,~<34>windows~<34>,old,self)~<10>		mTask.RaiseHandleEvent(self.task,new)~<10>		end~<10>	return true~<10>	end~<10>return false~<10>end~<10|10>function TWindow:DrawClear()~<10>local line = ~<34|34|10>local tx,ty = 0,0~<10>for tx=0,(self.width+self:borderwidth()) do~<10>	line=line..~<34> ~<34|10>	end~<10>for ty=0,(self.height+self:borderwidth()) do~<10>	self.Monitor:WritePos(self.left,self.top+ty,line , colors.white , colors.black)~<10>	end~<10>end~<10|10>function TWindow:DrawClearBox(new)~<10>-- new if a vec3:TBox~<10>local line = ~<34|34|10>local tx,ty = 0,0~<10>for tx=0,(self.width+self:borderwidth()) do~<10>	line=line..~<34> ~<34|10>	end~<10>for ty=0,(self.height+self:borderwidth()) do~<10>	self.Monitor:WritePos(self.left,self.top+ty,line , colors.white , colors.black)~<10>	end~<10>end~<10|10|10>function TWindow:Draw()~<10>if not self.visible then~<10>	return false~<10>	end~<10|10>local h=self.height+self:borderwidth()~<10>local w=self.width+self:borderwidth()~<10>local curline = ~<34|34|10>local symbols = ~<34>[# X]~<34|10>local maxTitle = self.width - self.margin - string.len(symbols) + 1~<10>local a = 0~<10>local i = 0~<10>local obj,obj2 = nil~<10>local bobj,bobj2 = nil ~<10>local acolor = colors.white~<10|10>if self.border then~<10>	if string.len(self.name) ~<62> maxTitle then~<10>		sText=string.sub(self.name,1,maxTitle-3)..~<34>...~<34|10>		else~<10>		sText=self.name~<10>		end~<10>   a = self.width - self.margin - string.len(sText) - string.len(symbols) + 1~<10>   if (GetActive() == self) then~<10>		acolor = colors.blue~<10>		if a ~<62> 0 then ~<10>			curline = ~<34>+~<34> .. string.rep(~<34>=~<34>,self.margin) .. sText .. string.rep(~<34>=~<34>,a) .. symbols~<10>			else~<10>			curline = ~<34>+~<34> .. string.rep(~<34>=~<34>,self.margin) .. sText  .. symbols~<10>			end~<10>		else~<10>		acolor = colors.lightBlue~<10>		if a ~<62> 0 then ~<10>			curline = ~<34>+~<34> .. string.rep(~<34>-~<34>,self.margin) .. sText .. string.rep(~<34>-~<34>,a) .. symbols~<10>			else~<10>			curline = ~<34>+~<34> .. string.rep(~<34>-~<34>,self.margin) .. sText  .. symbols~<10>			end~<10>		end~<10>	self.Monitor:WritePos(self.left,self.top,curline , colors.white , acolor)~<10>	if self.width ~<62> 0 then curline = ~<34>+~<34> .. string.rep(~<34>-~<34>,self.width) .. ~<34>+~<34> end~<10>	self.Monitor:WritePos(self.left,self.top+h,curline , colors.white , colors.black)~<10>	end~<10>	~<10>for ty=1,h-1 do~<10>	curline = self.l:GetLine(ty)~<10>	a = self.width-string.len(curline)~<10>	if a ~<62> 0 then ~<10>	   curline = curline .. string.rep(~<34> ~<34>,self.width-string.len(curline)) ~<10>	   end~<10>	if a ~<60> 0 then~<10>	   curline = string.sub(curline,1,self.width)~<10>	   end~<10>	if self.border then~<10>		curline = ~<34|124|34> .. curline .. ~<34|124|34|10>		end~<10>	-- audjust color manually because i'm to lazy to rewrite it, also this is more effective :)~<10>	obj = self.Monitor.l.colors[self.top+ty]~<10>	obj2 = self.l.colors[ty]~<10>	bobj = self.Monitor.l.bcolors[self.top+ty]~<10>	bobj2 = self.l.bcolors[ty]~<10>	if obj and bobj then~<10>		if self.border then~<10>			if obj2 and bobj2 then		~<10>				for i = 1,string.len(curline)-1 do~<10>					obj[self.left+i] = (obj2[i] or colors.white)~<10>					bobj[self.left+i] = (bobj2[i] or colors.black)~<10>					end~<10>				end~<10>			obj[self.left] = colors.white~<10>			obj[self.left+string.len(curline)-1] = colors.white~<10>			bobj[self.left] = colors.black~<10>			bobj[self.left+string.len(curline)-1] = colors.black~<10>			else~<10>			if obj2  and bobj2 then		~<10>				for i = 1,string.len(curline) do~<10>					obj[self.left+i] = (obj2[i] or colors.white)~<10>					bobj[self.left+i] = (bobj2[i] or colors.black)~<10>					end~<10>				end~<10>			end~<10>		end~<10>	self.Monitor:WritePos(self.left,self.top+ty,curline)~<10>	end~<10>return sText,true~<10>end~<10|10>function TWindow:FindSpace()~<10>local Poss = {}~<10>local space = {}~<10>local i,obj = nil~<10>local anr = 1~<10>if not self.Monitor then ~<10>	return false~<10>	end~<10>local t = self.Monitor.pos:Size()~<10>--[[~<10|10>local rx = t[1]-self.width-2-self:borderwidth()~<10>local ry = t[2]-self.height-2-self:borderwidth()~<10>if (rx ~<60>=1 ) or (ry ~<60>= 1) then~<10>	return false~<10>	end--]]~<10>	~<10>	local function Test(aposx,aposy)~<10>	Poss[anr] = {aposx,aposy}~<10>	space[anr] = 0~<10>	local x,y = 0,0~<10>	for x = Poss[anr][1],Poss[anr][1]+self.width do~<10>		for y = Poss[anr][2],Poss[anr][2]+self.height do~<10>			local a = GetWindowatPos(x,y,self)~<10>			if (#a ~<62> 0) or ((x ~<62> t[1]) or (y ~<62> t[2])) then~<10>				space[anr] = space[anr] + 1~<10>				end~<10>			end	~<10>		end~<10>	anr = anr + 1~<10>	end~<10>	~<10>Test(1,1)~<10>for i,obj in ipairs(window) do~<10>	if obj ~<126>= self then~<10>		Test(obj.left+obj.width+obj:borderwidth() , obj.top)~<10>		Test(obj.left+obj.width+obj:borderwidth() , obj.top+obj.height+obj:borderwidth())~<10>		Test(obj.left , obj.top+obj.height+obj:borderwidth())~<10>		end~<10>	end~<10>local mini = 1~<10>for i = 1,anr-1 do~<10>	if space[i] ~<60> space[mini] then~<10>		mini = i~<10>		end~<10>	end~<10>self:SetPos(Poss[mini][1],Poss[mini][2])~<10>end~<10|10>function TWindow:ClearChars( acount )~<10>self.l:ClearChars( acount )~<10>Invalidate()~<10>end~<10|10>function TWindow:write( text , color , bgcolor )~<10>if color then self.l.FontColor = color end~<10>if bgcolor then self.l.BackColor = bgcolor end~<10>self.l:write(text , color , bgcolor)~<10>Invalidate()~<10>end~<10|10>function TWindow:print( text , color , bgcolor)~<10>if color then self.l.FontColor = color end~<10>if bgcolor then self.l.BackColor = bgcolor end~<10>self.l:print(text , color , bgcolor)~<10>Invalidate()~<10>end~<10|10>function TWindow:writePos( x,y,text , color , bgcolor)~<10>self.l:writePos(x,y,text , color , bgcolor)~<10>Invalidate()~<10>end~<10|10>function TWindow:move(deltax,deltay)~<10>self:SetPos(self.left + deltax , self.top + deltay)~<10>Invalidate()~<10>end~<10|10>function TWindow:PressKey(akey)~<10>if (akey == 205) then ~<10>	self:move(1,0)~<10>elseif (akey == 203) then ~<10>	self:move(-1,0)~<10>elseif (akey == 200) then ~<10>	self:move(0,-1)~<10>elseif (akey == 208) then ~<10>	self:move(0,1)~<10>	end~<10>end~<10|10>-- Zum erstellen eines Fensters~<10>function CreateWindow(name , _task , makeactive)~<10>local new = TWindow(name or ~<34|34>, _task)~<10>if (makeactive) or (active == nil) then active = new end --ERROR active wird ned richtig gesetzt,...~<10>return new,x~<10>end~<10|10>function DestroyWindow(_w)~<10>local x = Pos(_w)~<10>if x ~<60> 0 then~<10>	return false~<10>	end~<10>_w:DrawClear()~<10>window:Del(x)~<10>if #window ~<62> 0 then~<10>	active = window[1]~<10>	end~<10>Invalidate()~<10>return true~<10>end~<10|10>function DestroyTaskWindow(_task)~<10>local i = 0~<10>for i = #window,1,-1 do~<10>	if window[i].task == _task then~<10>		DestroyWindow(window[i])~<10>		end~<10>	end~<10>end~<10|10>function WindowsofTask(_task)~<10>local result = 0~<10>local i,w = 0~<10>for i,w in ipairs(window) do~<10>	if w.task == _task then~<10>		result = result + 1~<10>		end~<10>	end~<10>return result~<10>end~<10|10>-- Zum Zeichnen !!! Aller Fenster !!!~<10>function DrawWindow()~<10>local i,w = 1~<10>local usedVMonitors = vec3.TList() -- should be only {mView.main}~<10>for i,w in ipairs(window) do~<10>	w:Draw()~<10>	if (usedVMonitors:IndexOf(w.Monitor) == -1) then~<10>	    usedVMonitors:Add(w.Monitor)~<10>		end~<10>	end~<10>for i,w in ipairs(usedVMonitors) do~<10>	w:Flush()~<10>	end~<10>needreDraw = false~<10>end~<10|10>function mayDraw()~<10>if needreDraw then DrawWindow() end~<10>end~<10|10>function Invalidate()~<10>needreDraw = true~<10>end~<10|10>function SetActive(x)~<10>active = x~<10>Invalidate()~<10>end~<10|10>function GetActive()~<10>return active~<10>end~<10|10>function GetWindow( _w)~<10>if (_w ~<62>0) and (_w ~<60>= #window) then~<10>	return window[_w]~<10>	else~<10>	return nil~<10>	end~<10>end~<10|10>function GetWindowCount()~<10>return #window~<10>end~<10|10>function GetWindowatPos(x,y,ausnahme,_Monitor)~<10>local result = {}~<10>for i,obj in ipairs(window) do~<10>	if (obj ~<126>= ausnahme) and (obj:contains(x,y) and (obj.visible) and ((obj.Monitor == _Monitor) or (_Monitor == nil))) then~<10>		result[#result+1] = obj~<10>		end~<10>	end~<10>return result~<10>end~<10|10>-- zum rausfinden der Position~<10>function Pos( _w)~<10>return window:IndexOf(_w)~<10>end~<10|10>-- Zum fenster 1 nach oben setzten~<10>function up( _w )~<10>local z = Pos( _w)~<10>local result = (z ~<62> -1) and (z ~<60> #window)~<10>if result then~<10>	local _w2 = window[z+1]~<10>	window[z] = _w2~<10>	window[z+1] = _w~<10>	end~<10>Invalidate()~<10>return result~<10>end~<10|10>-- Zum fenster 1 nach unten setzten~<10>function down( _w )~<10>local z = Pos( _w)~<10>local result = (z ~<62> 0)~<10>if result then~<10>	local _w2 = window[z-1]~<10>	window[z] = _w2~<10>	window[z-1] = _w~<10>	end~<10>Invalidate()~<10>return result~<10>end~<10|10>-- Zum fenster ganz nach oben setzten~<10>function uptop( _w )~<10>while up( _w) do end~<10>Invalidate()~<10>end~<10|10>-- Zum fenster ganz nach unten setzten~<10>function updown( _w )~<10>while down( _w) do end~<10>Invalidate()~<10>end~<10|10>function ChangeWindow( _makeup)~<10>local a = Pos(GetActive())~<10>a = a+1~<10>if a ~<62> #window then~<10>	a = 1~<10>	end~<10>local b = GetWindow(a)~<10>SetActive(b) ~<10>if (b ~<126>= nil) and _makeup then ~<10>	uptop(b)~<10>	end~<10>Invalidate()~<10>return b~<10>end~<10|10>function API_Initial()~<10>new = events.CreateEvent(~<34>Initialised~<34>,~<34>windows~<34>, ~<34>windows~<34>)~<10>mTask.RawRaiseEvent(new)~<10>end>>file<0||name<0|winobj>path<0|marcelOS/apis/winobj>data<0|-- marcelOS windows functions~<10>-- Handles for your Window !!!~<10>boot.BootMsg(~<34>starting winobj~<34>)~<10|10>TWinObj = classapi.class(nil,~<34>TWinObj~<34>) ~<10|10>function TWinObj_Selected(self,strict)~<10>local ok = (not self.parent) or ((self.parent.selobj == self) and ((not strict) or (self.selobj == nil)))~<10>return ok~<10>end~<10|10>function TWinObj_ChangeTabOrder(self)~<10>local a = self.obj:IndexOf(self.selobj)~<10>if a == #self.obj then~<10>	self.selobj = nil -- Wieder auf Nil!~<10>	else~<10>	local b,c = self.obj:Inc(a)~<10>	self.selobj = b ~<10>	end~<10>end~<10|10>function TWinObj_Event(self,_event)~<10>if self:Selected() then~<10>	if (_event.name == ~<34>key~<34>) then~<10>		if (_event.params[1] == 15) and (#self.obj ~<62> 0) then	~<10>			TWinObj_ChangeTabOrder(self)~<10>			while (self.selobj) and ((not self.selobj.canselect) or (not self.selobj.visible)) do~<10>				TWinObj_ChangeTabOrder(self)~<10>				end~<10>			end~<10>		end~<10>	if (_event.name == ~<34>mouse_click~<34>) then~<10>		for i,obj in ipairs(self.obj) do~<10>			if obj.canselect and obj.visible and obj:Inbox(_event.params[2],_event.params[3]) then ~<10>				self.selobj = obj ~<10>				end~<10>			end~<10>		end~<10>		~<10>	local i,obj = 0,nil~<10>	for i,obj in ipairs(self.obj) do~<10>		if obj:Selected() then ~<10>			obj:Event(_event)~<10>			end~<10>		end~<10>	end~<10>end~<10|10>function TWinObj_Paint(self)~<10>if self.visible then~<10>	for i,obj in ipairs(self.obj) do~<10>		obj:Paint()~<10>		end	~<10>	end~<10>end~<10|10>function TWinObj_RegisterEvents(self,_task)~<10>_task.eventfilter:AddOnce(~<34>key~<34>)~<10>_task.eventfilter:AddOnce(~<34>mouse_click~<34>)~<10>for i,obj in ipairs(self.obj) do~<10>	obj:RegisterEvents(_task)~<10>	end~<10>end~<10|10>function TWinObj_borderwidth(self)~<10>if self.border then ~<10>	return 2~<10>	else~<10>	return 0~<10>	end~<10>end~<10|10>function TWinObj_right(self)~<10>return self.left+self.width+self:borderwidth()-1~<10>end~<10|10>function TWinObj_bottom(self)~<10>return self.top+self.height+self:borderwidth()-1~<10>end~<10|10>function TWinObj_Inbox(self,ax,ay)~<10>return (self.left ~<60>= ax) and (self.top ~<60>= ay) and (self:bottom() ~<62>= ay) and (self:right() ~<62>= ax)~<10>end~<10|10>function TWinObj:__init(_name,_parent,_window)~<10>	self.name = _name or ~<34|34|10>	self.visible = true~<10>	self.left = 1~<10>	self.width = 0~<10>	self.top = 1~<10>	self.height = 0~<10>	self.parent = _parent~<10>	self.window = _window~<10>	self.border = true~<10>	self.canselect = true~<10>	self.readonly = false~<10>	self.obj = vec3.TList() -- WinObjs in a Window !~<10>	if _parent then _parent.obj:Add(self) end~<10>	self.selobj = nil -- selected obj~<10>	-- USE COMPLECT INHERITENCE SYTEM BECAUSE I'M TO STUPID~<10>	-- Currently self.Event if a variable to a function with the current Event function. That function may call self.TEditEvent and that function may call self.TWinObjEvent...~<10>	self.Event = TWinObj_Event~<10>	self.Paint = TWinObj_Paint~<10>	self.RegisterEvents = TWinObj_RegisterEvents~<10>	self.Selected = TWinObj_Selected~<10>	self.TWinObjEvent = TWinObj_Event --for inherited :)~<10>	self.TWinObjPaint = TWinObj_Paint~<10>	self.TWinObjRegisterEvents = TWinObj_RegisterEvents~<10>	self.borderwidth = TWinObj_borderwidth~<10>	self.right = TWinObj_right~<10>	self.bottom = TWinObj_bottom~<10>	self.Inbox = TWinObj_Inbox~<10>end~<10|10>-- TEdit~<10>TEdit = classapi.class(TWinObj,~<34>TEdit~<34>) ~<10|10>function TEdit_Paint(self)~<10>if not self.visible then~<10>	return~<10>	end~<10>if self.TWinObjPaint then self:TWinObjPaint() end~<10>if self.window and (self.width ~<62> 2) then~<10>	local border = string.rep(~<34>-~<34>,self.width)~<10>	if (self:Selected()) then~<10>		self.text:Blink()~<10>		else~<10>		self.text.caretvis = false~<10>		end~<10>	local middle = self.text:GetCutText(self.width-2)~<10>	local a = self.width-2-string.len(middle)	~<10>	if a ~<62> 0 then~<10>		middle = ~<34>[~<34> .. middle .. string.rep(~<34> ~<34>,a) .. ~<34>]~<34|10>		else~<10>		middle = ~<34>[~<34> .. middle .. ~<34>]~<34|10>		end~<10>	if self.border then~<10>		self.window:writePos(self.left,self.top,border)~<10>		self.window:writePos(self.left,self.top+1,middle)~<10>		self.window:writePos(self.left,self.top+2,border)~<10>		else~<10>		self.window:writePos(self.left,self.top,middle)~<10>		end	~<10>	end~<10>end~<10|10|10>function TEdit_Event(self,_event)~<10>if self.TWinObjEvent then self:TWinObjEvent(_event) end~<10>if self:Selected() then~<10>	if (_event.name == ~<34>char~<34>) then~<10>		self.text:Add(_event.params[1])~<10>		if self.onChange then self:onChange() end~<10>		elseif (_event.name == ~<34>key~<34>) then~<10>			if (_event.params[1] == 14) then -- del~<10>				self.text:Del()~<10>				if self.onChange then self:onChange() end~<10>				end~<10>			if (_event.params[1] == 203) then -- left arrow~<10>				self.text:Left()~<10>				end~<10>			if (_event.params[1] == 205) then -- right arrow~<10>				self.text:Right()~<10>				end~<10>			if (_event.params[1] == 28) then~<10>				if self.onClick then self:onClick() end~<10>				end~<10>			end~<10>	end~<10>end~<10|10>function TEdit_RegisterEvents(self,_task)~<10>if self.TWinObjRegisterEvents then self:TWinObjRegisterEvents(_task) end~<10>_task.eventfilter:AddOnce(~<34>char~<34>)~<10>end~<10|10>function TEdit:__init(_name,_parent,_window)~<10>	self.name = _name or ~<34|34|10>	self.parent = _parent~<10>	self.window = _window~<10>	if _parent then _parent.obj:Add(self) end~<10>	self.obj = vec3.TList() -- WinObjs in a Window !~<10>	self.width = 5~<10>	self.text = mStrings.TTextChar()~<10>	self.Paint = TEdit_Paint --for inherited :)~<10>	self.Event = TEdit_Event~<10>	self.RegisterEvents = TEdit_RegisterEvents~<10>	self.TEditPaint = TEdit_Paint~<10>	self.TEditEvent = TEdit_Event~<10>	self.TEditRegisterEvents = TEdit_RegisterEvents~<10>end~<10|10>-- TCheckbox~<10>TCheckbox = classapi.class(TWinObj,~<34>TCheckbox~<34>) ~<10|10>function TCheckbox_Paint(self)~<10>if not self.visible then~<10>	return~<10>	end~<10>if self.TWinObjPaint then self:TWinObjPaint() end~<10>if self.window and (self.width ~<62> 2) then~<10>	local middle = ~<34|34|10>	if self.checked then~<10>		middle = ~<34>[X]~<34|10>		else~<10>		if self:Selected() then~<10>			middle = ~<34>[_]~<34|10>			else~<10>			middle = ~<34>[ ]~<34|10>			end~<10>		end~<10>	middle = middle .. ~<34> ~<34> .. self.caption~<10>	self.window:writePos(self.left,self.top,middle)~<10>	end~<10>end~<10|10|10>function TCheckbox_Event(self,_event)~<10>if self.TWinObjEvent then self:TWinObjEvent(_event) end~<10>if self:Selected() then~<10>	if (_event.name == ~<34>key~<34>) and (_event.params[1] == 28) then~<10>		self.checked = not self.checked~<10>		if self.onChange then self:onChange() end~<10>		end~<10>	end~<10>end~<10|10|10|10>function TCheckbox:__init(_name,_parent,_window)~<10>	self.name = _name or ~<34|34|10>	self.parent = _parent~<10>	self.window = _window~<10>	if _parent then _parent.obj:Add(self) end~<10>	self.obj = vec3.TList() -- WinObjs in a Window !~<10>	self.width = 5~<10>	self.caption = ~<34|34|10>	self.checked = false~<10>	self.Paint = TCheckbox_Paint --for inherited :)~<10>	self.Event = TCheckbox_Event~<10>	self.TCheckboxPaint = TCheckbox_Paint~<10>	self.TCheckboxEvent = TCheckbox_Event~<10>end~<10|10>-- TLabel~<10>TLabel = classapi.class(TWinObj,~<34>TLabel~<34>) ~<10|10>function TLabel_Paint(self)~<10>if not self.visible then~<10>	return~<10>	end~<10>if self.TWinObjPaint then self:TWinObjPaint() end~<10>if self.window and (self.width ~<62> 2) then~<10>	self.window:writePos(self.left,self.top,self.caption)~<10>	end~<10>end~<10|10>function TLabel:__init(_name,_parent,_window)~<10>	self.name = _name or ~<34|34|10>	self.parent = _parent~<10>	self.window = _window~<10>	self.canselect = false~<10>	if _parent then _parent.obj:Add(self) end~<10>	self.obj = vec3.TList() -- WinObjs in a Window !~<10>	self.width = 5~<10>	self.caption = ~<34|34|10>	self.Paint = TLabel_Paint --for inherited :)~<10>	self.TLabelPaint = TLabel_Paint~<10>end~<10|10>-- TMultiLabel~<10>TMultiLabel = classapi.class(TWinObj,~<34>TMultiLabel~<34>) ~<10|10>function TMultiLabel_Paint(self)~<10>if not self.visible then~<10>	return~<10>	end~<10>if self.TWinObjPaint then self:TWinObjPaint() end~<10>if self.window and (self.width ~<62> 2) then~<10>	--self.window:writePos(self.left,self.top,self.caption)~<10>	local h = self.height~<10>	local w = self.width~<10>	local ty = 1~<10>	local curline = ~<34|34|10>	if self.border then~<10>		curline = ~<34>+~<34> .. string.rep(~<34>-~<34>,self.width) .. ~<34>+~<34|10>		self.window:writePos(self.left,self.top,curline , colors.white , colors.black)~<10>		self.window:writePos(self.left,self.top+h,curline , colors.white , colors.black)~<10>		end~<10>		~<10>	for ty=1,h-1 do~<10>		curline = self.data:GetLine(ty)~<10>		a = self.width-string.len(curline)~<10>		if a ~<62> 0 then ~<10>		   curline = curline .. string.rep(~<34> ~<34>,self.width-string.len(curline)) ~<10>		   end~<10>		if a ~<60> 0 then~<10>		   curline = string.sub(curline,1,self.width)~<10>		   end~<10>		if self.border then~<10>			curline = ~<34|124|34> .. curline .. ~<34|124|34|10>			end~<10>		-- audjust color manually because i'm to lazy to rewrite it, also this is more effective :)~<10>		obj = self.window.l.colors[self.top+ty]~<10>		obj2 = self.data.colors[ty]~<10>		bobj = self.window.l.bcolors[self.top+ty]~<10>		bobj2 = self.data.bcolors[ty]~<10>		if obj and bobj then~<10>			if self.border then~<10>				if obj2 and bobj2 then		~<10>					for i = 2,string.len(curline)-1 do~<10>						obj[self.left+i-1] = (obj2[i] or colors.white)~<10>						bobj[self.left+i-1] = (bobj2[i] or colors.black)~<10>						end~<10>					end~<10>				obj[self.left] = colors.white~<10>				obj[self.left+string.len(curline)-1] = colors.white~<10>				bobj[self.left] = colors.black~<10>				bobj[self.left+string.len(curline)-1] = colors.black~<10>				else~<10>				if obj2  and bobj2 then		~<10>					for i = 1,string.len(curline) do~<10>						obj[self.left+i-1] = (obj2[i] or colors.white)~<10>						bobj[self.left+i-1] = (bobj2[i] or colors.black)~<10>						end~<10>					end~<10>				end~<10>			end~<10>		self.window:writePos(self.left,self.top+ty,curline)~<10>		end~<10>	end~<10>end~<10|10>function TMultiLabel:__init(_name,_parent,_window)~<10>	self.name = _name or ~<34|34|10>	self.parent = _parent~<10>	self.window = _window~<10>	self.canselect = false~<10>	if _parent then _parent.obj:Add(self) end~<10>	self.obj = vec3.TList() -- WinObjs in a Window !~<10>	self.width = 5~<10>	self.height = 3~<10>	self.data = mView.Tvwindow()~<10>	self.data:SetSize(self.width,self.height)~<10>	self.Paint = TMultiLabel_Paint --for inherited :)~<10>	self.TMultiLabelPaint = TLabel_Paint~<10>end~<10|10>function TMultiLabel:SetSize(_width,_height)~<10>	self.width = _width~<10>	self.height = _height~<10>	self.data:SetSize(self.width,self.height)~<10>end~<10|10|10>-- TButton~<10>TButton = classapi.class(TWinObj,~<34>TButton~<34>) ~<10|10>function TButton_Paint(self)~<10>if not self.visible then~<10>	return~<10>	end~<10>if self.TWinObjPaint then self:TWinObjPaint() end~<10>if self.window and (self.width ~<62> 2) then~<10>	local border = string.rep(~<34>-~<34>,self.width)~<10>	local middle = self.caption~<10>	if (self:Selected()) then~<10>		middle = string.upper(self.caption)~<10>		end~<10>	if (self.width-2) ~<60> string.len(self.caption) then~<10>		middle = string.sub(middle,1,(self.width-2))~<10>		end~<10>	local a = self.width-2-string.len(middle)	~<10>	if a ~<62> 0 then~<10>		middle = ~<34>[~<34> .. middle .. string.rep(~<34> ~<34>,a) .. ~<34>]~<34|10>		else~<10>		middle = ~<34>[~<34> .. middle .. ~<34>]~<34|10>		end~<10>	if self.border then~<10>		self.window:writePos(self.left,self.top,border)~<10>		self.window:writePos(self.left,self.top+1,middle)~<10>		self.window:writePos(self.left,self.top+2,border)~<10>		else~<10>		self.window:writePos(self.left,self.top,middle)~<10>		end	~<10>	end~<10>end~<10|10|10>function TButton_Event(self,_event)~<10>if self.TWinObjEvent then self:TWinObjEvent(_event) end~<10>if self:Selected() then~<10>	if (_event.name == ~<34>key~<34>) and (_event.params[1] == 28) then~<10>		if self.onClick then self:onClick() end~<10>		end~<10>	end~<10>end~<10|10>function TButton:__init(_name,_parent,_window)~<10>	self.name = _name or ~<34|34|10>	self.parent = _parent~<10>	self.window = _window~<10>	if _parent then _parent.obj:Add(self) end~<10>	self.obj = vec3.TList() -- WinObjs in a Window !~<10>	self.width = 5~<10>	self.caption = ~<34|34|10>	self.Paint = TButton_Paint --for inherited :)~<10>	self.Event = TButton_Event~<10>	self.TButtonPaint = TButton_Paint~<10>	self.TButtonEvent = TButton_Event~<10>end~<10|10>-- TScrollbar~<10>TScrollbar = classapi.class(TWinObj,~<34>TScrollbar~<34>) ~<10|10>function TScrollbar_Paint(self)~<10>if not self.visible then~<10>	return~<10>	end~<10>if self.TWinObjPaint then self:TWinObjPaint() end~<10>local awidth = self.width~<10>if not self.horizontal then~<10>	awidth = self.height~<10>	end~<10>if self.window and (awidth ~<62> 2+self.size) then~<10>	~<10>	local fak = (awidth-2-self.size)/(self.max-self.min+1)~<10>	local bar = string.rep(~<34>#~<34>,self.size or 1)~<10>	local a = vec3.round(fak*self.pos)~<10>	local b = awidth-2-a-self.size~<10>	local sa = ~<34|34|10>	local sb = ~<34|34|10>	if a ~<62> 0 then sa = string.rep(~<34> ~<34>,a) end~<10>	if b ~<62> 0 then sb = string.rep(~<34> ~<34>,b) end~<10>	local middle = ~<34|60|34> .. sa .. bar .. sb .. ~<34|62|34|10>	if self.horizontal then~<10>		self.window:writePos(self.left,self.top,middle)~<10>		else~<10>		local i = 0~<10>		for i = 1,string.len(middle) do~<10>			self.window:writePos(self.left,self.top+i-1,string.sub(middle,i,i))~<10>			end~<10>		end~<10>	~<10>	end~<10>end~<10|10|10>function TScrollbar_Event(self,_event)~<10>if self.TWinObjEvent then self:TWinObjEvent(_event) end~<10>if self:Selected() then~<10>	if (_event.name == ~<34>key~<34>) then~<10>		if (_event.params[1] == 203) or (_event.params[1] == 200) then~<10>			self:Dec()~<10>			end~<10>		if (_event.params[1] == 205) or (_event.params[1] == 208) then~<10>			self:Inc()~<10>			end~<10>		end~<10>	if (_event.name == ~<34>mouse_click~<34>) then~<10>		local x,y = _event.params[2],_event.params[3]~<10>		if (x == self.left) and (y == self.top) then~<10>			self:Dec()~<10>			else~<10>			if self.horizontal then~<10>				if (x == self:right()) and (y == self.top) then~<10>					self:Inc()~<10>					else~<10>					if (x ~<62> self.left) and (x ~<60> self:right()) and (y == self.top) then~<10>						local fak = (x-self.left-self.size)/(self.width-2-self.size)~<10>						self.pos = vec3.round(fak * (self.max-self.min+1) + self.min)~<10>						if self.onChange then self:onChange() end~<10>						end~<10>					end~<10>				else~<10>				if (y == self:bottom()) and (x == self.left) then~<10>					self:Inc()~<10>					else~<10>					if (y ~<62> self.top) and (y ~<60> self:bottom()) and (x == self.left) then~<10>						local fak = (y-self.top-self.size)/(self.height-2-self.size)~<10>						self.pos = vec3.round(fak * (self.max-self.min+1) + self.min)~<10>						if self.onChange then self:onChange() end~<10>						end~<10>					end~<10>				end~<10>			end~<10>		end~<10>	end~<10>end~<10|10>function TScrollbar_Inc(self,_event)~<10>if self.pos ~<60> self.max then ~<10>	self.pos = self.pos + self.increase~<10>	if self.pos ~<62> self.max then~<10>		self.pos = self.max~<10>		end~<10>	if self.onChange then self:onChange() end~<10>	end~<10>end~<10|10>function TScrollbar_Dec(self,_event)~<10>if self.pos ~<62> self.min then ~<10>	self.pos = self.pos -self.increase~<10>	if self.pos ~<60> self.min then~<10>		self.pos = self.min~<10>		end~<10>	if self.onChange then self:onChange() end~<10>	end~<10>end~<10|10|10>function TScrollbar:__init(_name,_parent,_window)~<10>	self.name = _name or ~<34|34|10>	self.parent = _parent~<10>	self.window = _window~<10>	self.border = false~<10>	if _parent then _parent.obj:Add(self) end~<10>	self.obj = vec3.TList() -- WinObjs in a Window !~<10>	self.width = 5~<10>	self.min = 1~<10>	self.max = 100~<10>	self.pos = 1~<10>	self.increase = 1~<10>	self.size = 1~<10>	self.horizontal = true~<10>	self.Paint = TScrollbar_Paint --for inherited :)~<10>	self.Event = TScrollbar_Event~<10>	self.Inc = TScrollbar_Inc~<10>	self.Dec = TScrollbar_Dec~<10>	self.TScrollbarPaint = TScrollbar_Paint~<10>	self.TScrollbarEvent = TScrollbar_Event~<10>end~<10|10>-- TListbox~<10>TListbox = classapi.class(TWinObj,~<34>TListbox~<34>) ~<10|10>function TListbox_Paint(self)~<10>if not self.visible then~<10>	return~<10>	end~<10|10>self.Scrollbar.max = #self.data-self.height+self:borderwidth()~<10>if self.Scrollbar.max ~<60> self.Scrollbar.min then~<10>	self.Scrollbar.max = self.Scrollbar.min~<10>	end~<10>if self.Scrollbar.pos ~<62> self.Scrollbar.max then~<10>	self.Scrollbar.pos = self.Scrollbar.max~<10>	end~<10|10>local astr = ~<34|34|10>if self.TWinObjPaint then self:TWinObjPaint() end~<10>if self.window and (self.width ~<62> 2) then~<10>	if self.border then~<10>		astr = string.rep(~<34>-~<34>,self.width-1)~<10>		self.window:writePos(self.left,self.top,astr)~<10>		self.window:writePos(self.left,self.top+self.height,astr)~<10>		end~<10>	local i,obj = 1,nil~<10>	local i2 = 1~<10>	for i = self.Scrollbar.pos,self.height-2+self.Scrollbar.pos do~<10>		astr = ~<34|34|10>		if i ~<60>= #self.data then~<10>			astr = self.data[i]~<10>			if string.len(astr) ~<62> self.width-self:borderwidth() then~<10>				astr = string.sub(astr,1,self.width-self:borderwidth())~<10>				end~<10>			end~<10>		if string.len(astr) ~<60> self.width-self:borderwidth() then~<10>			astr = astr .. string.rep(~<34> ~<34>,self.width-self:borderwidth()-string.len(astr))~<10>			end~<10>		if self.border then~<10>			astr = ~<34|124|34> .. astr~<10>			end~<10>		if self.selected == i then~<10>			self.window:writePos(self.left,self.top+i2,astr,colors.blue)~<10>			else~<10>			self.window:writePos(self.left,self.top+i2,astr,colors.white)~<10>			end~<10>		~<10>		i2 = i2 + 1~<10>		end~<10>	end~<10>end~<10|10|10>function TListbox_Event(self,_event)~<10>if self.TWinObjEvent then self:TWinObjEvent(_event) end~<10>if self:Selected() then~<10>	if _event.name == ~<34>mouse_click~<34> then~<10>		local y = _event.params[3]-self.top + self.Scrollbar.pos - 1~<10>		if (y ~<62> 0) and (#self.data ~<62>= y) then	~<10>			local x = _event.params[2]-self.left~<10>			local l = string.len(self.data[y])~<10>			if (x ~<62> 0) and (x ~<60> l) and (y ~<126>= self.selected) then~<10>				local old = self.selected~<10>				self.selected = y~<10>				if self.onSelectionChange then self.onSelectionChange(old) end	~<10>				end~<10>			end~<10>		end~<10>	end~<10>end~<10|10|10>function TListbox_Resize(self,_event)~<10>self.Scrollbar.left = self:right()-self:borderwidth()~<10>self.Scrollbar.top = self.top~<10>self.Scrollbar.height = self.height+1~<10>end~<10|10>function TListbox:__init(_name,_parent,_window)~<10>	self.name = _name or ~<34|34|10>	self.parent = _parent~<10>	self.window = _window~<10>	if _parent then _parent.obj:Add(self) end~<10>	self.obj = vec3.TList() -- WinObjs in a Window !~<10>	self.width = 5~<10>	self.selected = -1~<10>	self.onSelectionChange = nil~<10>	self.data = vec3.TList() ~<10>	self.Paint = TListbox_Paint --for inherited :)~<10>	self.Event = TListbox_Event~<10>	self.TListboxPaint = TListbox_Paint~<10>	self.TListboxEvent = TListbox_Event~<10>	self.Resize = TListbox_Resize~<10>	~<10>	self.Scrollbar = winobj.TScrollbar(~<34>TScrollbar~<34>,self,self.window)~<10>	self.Scrollbar.horizontal = false~<10>	self.Scrollbar.width = 1~<10>	self:Resize()~<10>end>>>>folder<0||name<0|autorun>path<0|marcelOS/autorun>sub<0||file<0||name<0|debugger>path<0|marcelOS/autorun/debugger>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>explorer~<62>version~<60>1~<124>0.2~<62>changePrint~<60>2~<124>false~<62>eventfilter~<60>0~<124>mouse_click~<124>window_resize~<124>window_fullscreen~<62>EventManager~<60>3~<124>true~<62|62>code~<60>0~<124>print(~<34>Hello, debugger run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>explorer~<62>version~<60>2~<124>0.2~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>-- Print Debug Info in this Window instead of term... !~<10>Application.window = windows.CreateWindow( Application.name , Application , true)~<10>Application.window:SetSize(40,20)~<10>Application.window:FindSpace()~<10>local i,obj = 0~<10>local trennX = 15~<10>local offset = 2 ~<10>local selected = nil~<10|10>local Eintrag = {}~<10>local TEintrag_debugger = classapi.class(nil,~<34>TEintrag_debugger~<34>)~<10|10>function TEintrag_debugger:__init(owner , title , msg , color)~<10>	self.owner = owner~<10>	self.title = title or ~<34|34|10>	self.msg = msg or ~<34|34|10>	self.color = color or colors.white~<10>	self.time = os.clock()~<10>	Eintrag[#Eintrag+1] = self~<10>end~<10|10>local function Show()~<10>local i,obj = 0~<10>local pos = 1+offset~<10>local astr = ~<34|34|10>Application.window.l:clear()~<10>local low = #Eintrag - Application.window.height + 2~<10>if low ~<60> 1 then ~<10>	low = 1~<10>	end~<10>for i =  low,#Eintrag do~<10>	obj = Eintrag[i]~<10>	astr = obj.title .. ~<34>:   ~<34> .. obj.msg~<10>	if obj == selected then~<10>		astr = ~<34>-- ~<34> .. astr~<10>		end	~<10>	Application.window:writePos(1,pos,astr , obj.color)~<10>	pos = pos + 1~<10>	end~<10>if selected then~<10>	astr = ~<34|34|10>	if selected.owner then~<10>		astr = astr .. selected.owner.name .. ~<34>  ~<34|10>		end~<10>	astr = astr .. tostring(selected.time)~<10>	Application.window:writePos(1,1,astr , colors.red)~<10>	end~<10>Application.window:Paint()~<10>end~<10|10>function ThrowDebug(owner,title,msg,color)~<10>local new = TEintrag_debugger(owner,tostring(title or ~<34|34>),tostring(msg or ~<34|34>) ,color)~<10>Show()	~<10>return new~<10>end~<10|10|10>local function getEvent(_event)~<10>if (_event.name == ~<34>mouse_click~<34>) then~<10>	local posy = _event.params[3]~<10>	local cnt = posy-offset~<10>	selected = nil~<10>	if (cnt ~<62> 0) and (cnt ~<60>= #Eintrag) then~<10>		selected = Eintrag[cnt]~<10>		end~<10>	Show()	~<10>	end~<10>if (_event.name == ~<34>window_resize~<34>) or (_event.name == ~<34>window_fullscreen~<34>) then~<10>	Show()~<10>	end~<10>end~<10|10>local function EventHandle()~<10>local i,obj = 0,nil~<10>for i, obj in ipairs(Application.events) do~<10>	Application.window:Event(obj)~<10>	getEvent(obj)~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>while true do~<10>	EventHandle()~<10>	mTask.sleepEvent(Application,10)~<10>	Show()~<10>	end>>file<0||name<0|DHCPregister>path<0|marcelOS/autorun/DHCPregister>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>DHCPregister~<62>version~<60>1~<124>0.1~<62>changePrint~<60>2~<124>false~<62>eventfilter~<60>0~<124>internet~<62|62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>DHCPregister~<62>version~<60>2~<124>0.1~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>local windowmode = false~<10>local kickTimeout = 30~<10>local mainInterval = 4~<10>local intervals = 0.5~<10|10>local function aprint( _text )~<10>if windowmode then ~<10>	Application.window:print(_text) ~<10>	end~<10>end~<10|10>local function aclear( )~<10>if windowmode then Application.window.l:clear() end~<10>end~<10|10>local function Event(_event)~<10>local a,b,c = nil,nil,0~<10>local new = nil~<10>if (_event.name == ~<34>internet~<34>) and (tostring(_event.params[4]) == ~<34>67~<34>) and (tostring(_event.params[5]) == ~<34>DHCP~<34>) then	~<10>	a,b,c = ip.OwnIP:GetDHCP(tonumber(_event.params[1]))~<10>	if a == nil then~<10>		new = ip.OwnIP:Add(tonumber(_event.params[1]))~<10>		aprint(~<34>NEW ~<34> .. new.lastping .. ~<34> ~<34> .. tostring(_event.params[1])..~<34> ~<34>..tostring(_event.params[2])..~<34> ~<34>..tostring(_event.params[3]) .. ~<34> ~<34> .. tostring(_event.params[4]) .. ~<34> ~<34> .. tostring(_event.params[5]) .. ~<34> ~<34> ..tostring(_event.params[6]) .. ~<34> ~<34>.. tostring(_event.params[7])  .. ~<34> ~<34>.. tostring(_event.params[8]))~<10>		else~<10>		aprint(~<34>OLD ~<34> .. b.lastping .. ~<34> ~<34> .. b.ip)	~<10>		local a2,b2,c2 = ip.OwnIP:GetDHCP_C(tonumber(_event.params[1]))~<10>		-- check if a Connected PC is also connected DIRECTY, if not, fix it !!!~<10>		if a2 == nil then~<10>			~<10>			ip.OwnIP.con[#ip.OwnIP.con+1] = b~<10>			a.con:Del(c)~<10>			aprint(~<34>Change Order... ~<34> .. b.ip .. ~<34> is now in direct range :D ~<34>)~<10>			end				~<10>		end~<10>	~<10>	new = ip.OwnIP:LoadfromString(_event.params[6] , true)~<10>	if new then ~<10>		new.lastping = os.clock()		~<10>		end~<10>	~<10>	end~<10>end~<10|10>local function EventHandle()~<10>local i,obj = 0~<10>for i, obj in ipairs(Application.events) do~<10>	Event(obj)~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>local function TimeKick( _obj )~<10>local i,obj = 0~<10>for i,obj in ipairs(_obj.con) do~<10>	if obj.lastping + kickTimeout ~<60> os.clock() then~<10>		aprint(_obj.con[i].ip .. ~<34> kicked from the server , timeout~<34> )~<10>		_obj.con:Del(i)~<10>		end~<10>	end~<10>end~<10|10>local function SendCurrent()~<10>local i,obj = 0~<10>local astr = ~<34|34|10>astr = ip.OwnIP:tostring()~<10|10>ip.SendMessage(nil,nil,nil,67,~<34>DHCP~<34>,astr)~<10>end~<10|10>local function ShowCur( _obj , acnt)~<10>local i,obj = 0,nil~<10>local i2,obj2 = 0,nil~<10>local astr = ~<34|34|10>for i,obj in ipairs(_obj.con) do~<10>	astr = ~<34|34|10>	for i2,obj2 in ipairs(obj.parents) do~<10>		astr = astr .. ~<34> ~<34> .. tostring(obj2.ip)~<10>		end~<10>	aprint(~<34>CON~<34> .. string.rep(~<34>  ~<34> , (acnt or 0)+1) .. tostring(obj.ip) .. ~<34>/~<34> .. tostring(#obj.parents) ..  ~<34> ~<34> .. astr .. tostring(obj.meta_own) .. ~<34>#~<34> .. vec3.PrintVec(obj.pos))~<10>	ShowCur( obj , (acnt or 0)+1)~<10>	end~<10>end~<10|10|10>local Args = {...}~<10>if (Args[1] == ~<34>windowmode~<34>) then windowmode = true end~<10|10>local p = ehtf.THTNode()~<10>local o = nil~<10>p:LoadfromFile(path.C(path.DATA(),~<34>DHCPregister/settings~<34>))~<10>o = p:FindAboutC(~<34>windowmode~<34>)~<10>if o then windowmode = o:SValuesB(1) end~<10>o = p:FindAboutC(~<34>kickTimeout~<34>)~<10>if o then kickTimeout = o:SValuesI(1) end~<10>o = p:FindAboutC(~<34>mainInterval~<34>)~<10>if o then mainInterval = o:SValuesI(1) end~<10>o = p:FindAboutC(~<34>intervals~<34>)~<10>if o then intervals = o:SValuesI(1) end~<10|10>if windowmode then~<10>	Application.window = windows.CreateWindow( Application.name , Application , true)~<10>	Application.window:SetSize(40,25)~<10>	end~<10|10>-- Initial ... More Pings and receiving... no sending...~<10>aclear()~<10>aprint(~<34>Initial...~<34>)~<10>while not ip.HasModem() do~<10>	sleep(2)~<10>    aprint(~<34> NO MODEM ATTACHED~<34>)~<10>	end~<10|10>sleep(mainInterval*2)~<10>EventHandle()~<10|10>aprint(~<34>Initial... done~<34>)~<10>mgps.ComputePos()~<10>local a = vec3.PrintVec(mgps.GetPos() or {})~<10>aprint(a)~<10>ShowCur(ip.OwnIP,0)~<10>sleep(2)~<10|10>while true do~<10>	aclear()~<10>	while not ip.HasModem() do~<10>		sleep(2)~<10>		aprint(~<34> NO MODEM ATTACHED~<34>)~<10>		end~<10|10>	aprint(~<34>start DHCP Server~<34>)~<10>	aprint(~<34>Timeout:  ~<34> .. tostring(kickTimeout) .. ~<34> Interval:  ~<34> .. tostring(intervals))~<10>	ShowCur(ip.OwnIP,0)~<10>	~<10>	sleep(mainInterval)~<10>	EventHandle()~<10>	~<10>	TimeKick(ip.OwnIP)~<10>	mgps.ComputePos()~<10>	local a = vec3.PrintVec(mgps.GetPos() or {})~<10>	aprint(a)~<10>	SendCurrent()~<10>	end>>file<0||name<0|explorer>path<0|marcelOS/autorun/explorer>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>explorer~<62>version~<60>1~<124>0.2~<62>changePrint~<60>2~<124>false~<62>eventfilter~<60>0~<124>mouse_click~<124>window_resize~<124>window_fullscreen~<62>EventManager~<60>3~<124>true~<62>Debug~<60>3~<124>true~<62|62>code~<60>0~<124>print(~<34>Hello, explorer run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>explorer~<62>version~<60>2~<124>0.2~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>Application.window = windows.CreateWindow( Application.name , Application , true)~<10>Application.window:SetSize(40,20)~<10>Application.window:FindSpace(111)~<10>local i,obj = 0~<10>local curPath = ~<34>/marcelOS~<34|10>local trennX = 15~<10>local offset = 1 ~<10>local blocknextevent = false~<10>local popupObj = nil~<10|10>local Edit1 = winobj.TEdit(~<34>Edit1~<34>,Application.window,Application.window)~<10>Edit1.left = 8~<10>Edit1.width = Application.window.width - 7~<10>Edit1.border = false~<10>Edit1.text.text = ~<34>explorer~<34|10|10>local Checkbox1 = winobj.TCheckbox(~<34>Checkbox1~<34>,Application.window,Application.window)~<10>Checkbox1.width = 6~<10>Checkbox1.border = false~<10>Checkbox1.caption = ~<34>su~<34|10|10>local Listbox1 = winobj.TListbox(~<34>Listbox1~<34>,Application.window,Application.window)~<10>Listbox1.visible = false~<10>Listbox1.height = 3~<10>Listbox1.border = true~<10>Listbox1.width = 20~<10>Listbox1.data:Add(~<34>SUDO~<34>)~<10>Listbox1.data:Add(~<34>RUN~<34>)~<10>Listbox1:Resize()~<10|10>Application.window:RegisterEvents(Application)~<10|10>local Eintrag = {}~<10>local  TEintrag_Explorer = classapi.class(nil,~<34>TEintrag_ExplorerEX~<34>)~<10|10>function TEintrag_Explorer:__init(_pfad , _tabelle , _pos , _selected,_tiefe)~<10>	self.name = fs.getName(_pfad)~<10>	self.pfad = _pfad~<10>	if _tiefe then~<10>		self.tiefe = _tiefe~<10>		else~<10>		self.tiefe = 0~<10>		--Berechnen~<10>		end~<10>	self.tabelle = _tabelle~<10>	self.pos = _pos + offset~<10>	self.selected = _selected~<10>	Eintrag[#Eintrag+1] = self~<10>end~<10|10>local function NewEintrag(_pfad , _tabelle , _pos , _selected,_tiefe)~<10>local new = TEintrag_Explorer(_pfad , _tabelle , _pos , _selected,_tiefe)~<10>return new~<10>end~<10|10>local function PathChanged()~<10>local tData = {}~<10>local astr = ~<34|34|10>local cury = 1~<10>local i,obj = 0~<10>local n,sFile = 0~<10|10>for i,obj in ipairs(Eintrag) do~<10>	Eintrag[i] = nil~<10>	end~<10|10>local curfolders =  mStrings.split(curPath,~<34>/~<34>)~<10>for i = #curfolders,1,-1 do ~<10>	curfolders[i+1] = curfolders[i]~<10>	end~<10>curfolders[1] = ~<34>/~<34|10|10>-- Neben~<10>for i,obj in ipairs(curfolders) do~<10>	sFile = mStrings.merge(curfolders,~<34>/~<34>,i,true)~<10>	NewEintrag(sFile,1,cury,true,i)~<10>	cury = cury + 1~<10>	end~<10>for i = #curfolders,1,-1 do~<10>    obj = mStrings.merge(curfolders,~<34>/~<34>,i,true)~<10>	if fs.isDir( path.FOLDER(obj) ) then	~<10>		tData = fs.list( obj )~<10>		for n,sFile in ipairs( tData ) do~<10>			if fs.isDir(path.C(obj,sFile)) and (sFile ~<126>= curfolders[i+1]) then ~<10>				NewEintrag(path.C(obj,sFile),1,cury,false,i+1)~<10>				cury = cury + 1~<10>				end~<10>			end~<10>		end~<10>	end~<10>-- MAIN~<10>tData = fs.list( curPath )~<10>local cury = 1~<10>for n,sFile in ipairs( tData ) do~<10>	if fs.isDir(path.C(curPath,sFile)) then ~<10>		NewEintrag(path.C(curPath,sFile),2,cury,false,1)~<10>		cury = cury + 1~<10>		end~<10>	end~<10>for n,sFile in ipairs( tData ) do~<10>	if not fs.isDir( path.C(curPath,sFile)) then ~<10>		NewEintrag(path.C(curPath,sFile),2,cury,false,1)~<10>		cury = cury + 1~<10>		end~<10>	end~<10>end~<10|10|10|10|10>local function ShowPath()~<10>local astr = ~<34|34|10>local i,obj = 0~<10>local last1 = 0~<10>local last2 = 0~<10>local maxtiefe = 0~<10>local acolor = colors.white~<10>Application.window.l:clear()~<10>for i,obj in ipairs(Eintrag) do~<10>	acolor = colors.white~<10>	if obj.tabelle == 1 then~<10>		astr = obj.name~<10>		maxtiefe = 0~<10>		if obj.selected then~<10>			astr = ~<34|62|34> .. astr~<10>			maxtiefe = 1~<10>			acolor = colors.yellow~<10>			end~<10>		Application.window:writePos(obj.tiefe-maxtiefe,obj.pos,astr , acolor)~<10>		last1 = obj.pos~<10>		end~<10>	if obj.tabelle == 2 then~<10>		astr = obj.name~<10>		acolor = colors.white~<10>		if fs.isDir( obj.pfad ) then~<10>			astr = ~<34>[~<34> .. astr .. ~<34>]~<34|10>			acolor = colors.yellow~<10>			end~<10>		Application.window:writePos(trennX+1,obj.pos,astr , acolor)~<10>		last2 = obj.pos~<10>		end~<10>	end~<10>	~<10>Application.window.name = ~<34>explorer~<34> .. ~<34>  '~<34> .. curPath .. ~<34>'~<34|10>for i = offset+1,Application.window.height do~<10>	Application.window:writePos(trennX,i,~<34>.~<34> , colors.gray , colors.black)~<10>	end~<10>Application.window:Paint()~<10>end~<10|10>local function StartPrg(obj,_sudo)~<10>local co,co2 = mTask.CreateTask( obj.name or ~<34|34> , true )~<10>co.file = obj.pfad or ~<34|34>  ~<10>local Arg = mStrings.split(Edit1.text.text,~<34> ~<34>)~<10>for i = 1,#Arg do~<10>	co.args:Add(Arg[i])~<10>	end~<10>if _sudo then ~<10>	co2:sudoRun()~<10>	else~<10>	co:run()~<10>	end~<10>end~<10|10|10>local function EintragOfPos(_x,_y,mouse)~<10>local i,obj = 0~<10>local tabel = 1~<10>if (_x ~<62> trennX) then~<10>	tabel = 2~<10>	end~<10>	~<10|10|10>if Listbox1:Inbox(_x,_y) and Listbox1.visible then ~<10>	-- YEAH~<10>	else~<10>	if (mouse ~<126>= 2) then ~<10>		Listbox1.visible = false~<10>		ShowPath()~<10>		end~<10>	for i,obj in ipairs(Eintrag) do~<10>		if ((obj.tabelle == tabel) and (obj.pos == _y)) then~<10>			if fs.isDir(obj.pfad) then~<10>				curPath = obj.pfad~<10>				PathChanged()~<10>				Listbox1.visible = false~<10>				ShowPath()	~<10>				return -- !!!~<10>				else~<10>				if mouse == 2 then~<10>					Listbox1.left = _x~<10>					Listbox1.top = _y~<10>					Listbox1.selobj = nil~<10>					Listbox1:Resize()~<10>					ShowPath()~<10>					popupObj = obj~<10>					Listbox1.visible = true~<10>					else~<10>					if Checkbox1.checked then~<10>						StartPrg(obj,true)~<10>						return -- !!!~<10>						else~<10>						if not programs.OpenFile(obj.pfad or ~<34|34> ,  mStrings.split(Edit1.text.text,~<34> ~<34>) , obj.name) then~<10>							Debug(~<34>ERROR~<34>,~<34>sry, i have no idea how to open a ~<34> .. mStrings.FileEnding(obj.pfad) .. ~<34> file~<34>)~<10>							end~<10>						return -- !!!~<10>						end~<10>					end~<10>				end	~<10>			end~<10>		end~<10>	end~<10>end~<10|10>local function Listbox1onSelectionChange(old)~<10>if not popupObj then return end~<10>if Listbox1.selected == 1 then~<10>	StartPrg(popupObj,true)~<10>	end~<10>if Listbox1.selected == 2 then~<10>	StartPrg(popupObj,false)~<10>	end~<10>Listbox1.visible = false~<10>Listbox1.selected =nil~<10>blocknextevent = true~<10>ShowPath()~<10>end~<10|10>Listbox1.onSelectionChange = Listbox1onSelectionChange~<10|10>local function getEvent(_event)~<10>if (_event.name == ~<34>mouse_click~<34>) then~<10>	local posx = _event.params[2]~<10>	local posy = _event.params[3]~<10>	EintragOfPos(posx,posy,_event.params[1])~<10>	end~<10>if (_event.name == ~<34>window_resize~<34>) or (_event.name == ~<34>window_fullscreen~<34>) then~<10>	Edit1.width = Application.window.width - 7~<10>	end~<10|10>end~<10|10>local function EventHandle()~<10>local i,obj = 0,nil~<10>for i, obj in ipairs(Application.events) do~<10>	Application.window:Event(obj)~<10>	if not blocknextevent then~<10>		getEvent(obj)~<10>		end~<10>	blocknextevent = false~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>PathChanged()~<10>ShowPath()~<10>while true do~<10>	EventHandle()~<10>	Application.window:Paint()~<10>	mTask.sleepEvent(Application,6)~<10>	end>>>>folder<0||name<0|data>path<0|marcelOS/data>sub<0||folder<0||name<0|DHCPregister>path<0|marcelOS/data/DHCPregister>sub<0||file<0||name<0|settings>path<0|marcelOS/data/DHCPregister/settings>data<0|~<60|126>t~<60>true~<62>windowmode~<60>3~<124>true~<62>kickTimeout~<60>1~<124>30~<62>mainInterval~<60>1~<124>4~<62>intervals~<60>0~<124>0.5~<62|62>>>>>folder<0||name<0|ip>path<0|marcelOS/data/ip>sub<0||file<0||name<0|settings>path<0|marcelOS/data/ip/settings>data<0|~<60|126>t~<60>true~<62>DHCP~<60>0~<124>0~<62>DNS~<60>google.de~<60>0~<124>0~<62>gott.de~<60>0~<124>0~<62>marcel.gott~<60>0~<124>0~<62>weltherr.scher~<60>0~<124>0~<62>world.ruler~<60>0~<124>0~<62>imac.g8~<60>0~<124>0~<62>mac.g8~<60>0~<124>0~<62>mac.1~<60>0~<124>0~<62>iflo.g8~<60>0~<124>0~<62>flo.g8~<60>0~<124>0~<62|62|62>>>>>folder<0||name<0|lps>path<0|marcelOS/data/lps>sub<0||file<0||name<0|pos>path<0|marcelOS/data/lps/pos>data<0|0 64 0~<10>1 0 0>>>>folder<0||name<0|mgps>path<0|marcelOS/data/mgps>sub<0||file<0||name<0|pos>path<0|marcelOS/data/mgps/pos>data<0|~<60|126>t~<60>true~<62>pos~<60>1~<124>1164~<124>48~<124>-2139~<62>orientation~<60>1~<124>1~<62|62>>>file<0||name<0|settings>path<0|marcelOS/data/mgps/settings>data<0|~<60|126>t~<60>true~<62>lastmovetimeout~<60>1~<124>15~<62>lastmovemaxdif~<60>2~<124>1.5~<62>normalmovedif~<60>1~<124>5~<62>maxmapheight~<60>1~<124>260~<62>digmode~<60>3~<124>false~<62>notmoving~<60>3~<124>true~<62>realtimebackup~<60>3~<124>false~<62|62>>>>>folder<0||name<0|mView>path<0|marcelOS/data/mView>sub<0||file<0||name<0|screen1>path<0|marcelOS/data/mView/screen1>data<0|~<60|126>t~<60>true~<62>Monitor~<60>left~<60>0~<124|124>name~<60>0~<124>left monitor~<62>ppos~<60>1~<124>-3~<124>-3~<124>3~<124>0~<62>textScale~<60>2~<124>0.5~<62>Zpos~<60>1~<124>2~<62|62>top~<60>0~<124|124>name~<60>0~<124>top monitor~<62>ppos~<60>1~<124>0~<124>-2~<124>2~<124>-1~<62>textScale~<60>2~<124>0.5~<62>Zpos~<60>1~<124>2~<62|62>back~<60>0~<124|124>name~<60>0~<124>Middle monitor~<62>ppos~<60>1~<124>3~<124>0~<124>9~<124>3~<62>textScale~<60>2~<124>0.5~<62>Zpos~<60>1~<124>3~<62|62>bottom:blue~<60>0~<124|124>name~<60>0~<124>Right monitor~<62>ppos~<60>1~<124>10~<124>0~<124>12~<124>3~<62>textScale~<60>2~<124>0.5~<62>Zpos~<60>1~<124>3~<62|62>bottom:red~<60>0~<124|124>name~<60>0~<124>Left monitor~<62>ppos~<60>1~<124>0~<124>0~<124>2~<124>3~<62>textScale~<60>2~<124>0.5~<62>Zpos~<60>1~<124>3~<62|62>term~<60>0~<124|124>name~<60>0~<124>internal term~<62>ppos~<60>1~<124>0~<124>0~<124>0~<124>0~<62>textScale~<60>2~<124>0.5~<62>Zpos~<60>1~<124>1~<62|62|62|62>>>>>folder<0||name<0|programs>path<0|marcelOS/data/programs>sub<0||file<0||name<0|settings.ehtf>path<0|marcelOS/data/programs/settings.ehtf>data<0|~<60|126>t~<60>true~<62>fileext~<60>1~<60>ext~<60>0~<124|124|62>dll~<60>0~<124|126>i~<60>39~<62>/marcelOS/programs/programs-dll/execute~<62|62>2~<60>ext~<60>0~<124>.exe~<62>dll~<60>0~<124|126>i~<60>39~<62>/marcelOS/programs/programs-dll/execute~<62|62>3~<60>ext~<60>0~<124>.lnk~<62>dll~<60>0~<124|126>i~<60>35~<62>/marcelOS/programs/programs-dll/lnk~<62|62>4~<60>ext~<60>0~<124>.avi~<62>dll~<60>0~<124|126>i~<60>35~<62>/marcelOS/programs/programs-dll/avi~<62|62>5~<60>ext~<60>0~<124>.img~<62>dll~<60>0~<124>/user/MSPaint~<62|62>6~<60>ext~<60>0~<124>.txt~<62>dll~<60>0~<124>/rom/programs/edit~<62|62|62|62>>>>>folder<0||name<0|SoftwareUpdater>path<0|marcelOS/data/SoftwareUpdater>sub<0||folder<0||name<0|programs>path<0|marcelOS/data/SoftwareUpdater/programs>sub<0||folder<0||name<0|marcelOS_base_apis>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_base_apis>sub<0||file<0||name<0|config.ehtf>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_base_apis/config.ehtf>data<0|~<60|126>t~<60>true~<62>about~<60>0~<124>Softwareupdate~<62>name~<60>0~<124>marcelOS Base Apis~<62>path~<60>0~<124>/~<62>ver~<60>0~<124>1.0~<62>sha1~<60>3~<124>true~<62>data~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124|124|62>path~<60>0~<124|124|62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>marcelOS~<62>path~<60>0~<124>/marcelOS~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>apis~<62>path~<60>0~<124>marcelOS/apis~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>classapi~<62>path~<60>0~<124|126>i~<60>22~<62>marcelOS/apis/classapi~<62>data~<60>0~<124|126>i~<60>27~<62>data/marcelOS/apis/classapi~<62>sha1~<60>0~<124|126>i~<60>32~<62>a51fb05d9e2a2f16810910eac0cd912f~<62|62>file~<60>0~<124|124>name~<60>0~<124>driver~<62>path~<60>0~<124>marcelOS/apis/driver~<62>data~<60>0~<124|126>i~<60>25~<62>data/marcelOS/apis/driver~<62>sha1~<60>0~<124|126>i~<60>32~<62>ce2845ce01b93b18b39ac86f4321cacf~<62|62>file~<60>0~<124|124>name~<60>0~<124>ehtf~<62>path~<60>0~<124>marcelOS/apis/ehtf~<62>data~<60>0~<124|126>i~<60>23~<62>data/marcelOS/apis/ehtf~<62>sha1~<60>0~<124|126>i~<60>32~<62>a7ca66c9881c49749c5abf042bbae32f~<62|62>file~<60>0~<124|124>name~<60>0~<124>ehtfutils~<62>path~<60>0~<124|126>i~<60>23~<62>marcelOS/apis/ehtfutils~<62>data~<60>0~<124|126>i~<60>28~<62>data/marcelOS/apis/ehtfutils~<62>sha1~<60>0~<124|126>i~<60>32~<62>fc4d35b263998424095e35bfa7f81474~<62|62>file~<60>0~<124|124>name~<60>0~<124>events~<62>path~<60>0~<124>marcelOS/apis/events~<62>data~<60>0~<124|126>i~<60>25~<62>data/marcelOS/apis/events~<62>sha1~<60>0~<124|126>i~<60>32~<62>4a584a0eefa6f502e8b60444f66d9f06~<62|62>file~<60>0~<124|124>name~<60>0~<124>ip~<62>path~<60>0~<124>marcelOS/apis/ip~<62>data~<60>0~<124|126>i~<60>21~<62>data/marcelOS/apis/ip~<62>sha1~<60>0~<124|126>i~<60>32~<62>be061b95c5e1d3740ffab9fb1832bde8~<62|62>file~<60>0~<124|124>name~<60>0~<124>lps~<62>path~<60>0~<124>marcelOS/apis/lps~<62>data~<60>0~<124|126>i~<60>22~<62>data/marcelOS/apis/lps~<62>sha1~<60>0~<124|126>i~<60>32~<62>10a0b81daf0db3cc8aebf630d4cc2212~<62|62>file~<60>0~<124|124>name~<60>0~<124>md5~<62>path~<60>0~<124>marcelOS/apis/md5~<62>data~<60>0~<124|126>i~<60>22~<62>data/marcelOS/apis/md5~<62>sha1~<60>0~<124|126>i~<60>32~<62>e5a4882a2cd69d7025bb11969c6fc4bd~<62|62>file~<60>0~<124|124>name~<60>0~<124>mgps~<62>path~<60>0~<124>marcelOS/apis/mgps~<62>data~<60>0~<124|126>i~<60>23~<62>data/marcelOS/apis/mgps~<62>sha1~<60>0~<124|126>i~<60>32~<62>b0bb5b55c6cf299ea1b1243a11dcaf06~<62|62>file~<60>0~<124|124>name~<60>0~<124>mperipheral~<62>path~<60>0~<124|126>i~<60>25~<62>marcelOS/apis/mperipheral~<62>data~<60>0~<124|126>i~<60>30~<62>data/marcelOS/apis/mperipheral~<62>sha1~<60>0~<124|126>i~<60>32~<62>9a40eb3382de455aa5c7d7c6c99e9486~<62|62>file~<60>0~<124|124>name~<60>0~<124>mStrings~<62>path~<60>0~<124|126>i~<60>22~<62>marcelOS/apis/mStrings~<62>data~<60>0~<124|126>i~<60>27~<62>data/marcelOS/apis/mStrings~<62>sha1~<60>0~<124|126>i~<60>32~<62>435a24150640e7407282e037d5cc303f~<62|62>file~<60>0~<124|124>name~<60>0~<124>mTask~<62>path~<60>0~<124>marcelOS/apis/mTask~<62>data~<60>0~<124|126>i~<60>24~<62>data/marcelOS/apis/mTask~<62>sha1~<60>0~<124|126>i~<60>32~<62>4cf1eb3b4fdbab781539f195c0b6caa0~<62|62>file~<60>0~<124|124>name~<60>0~<124>mTaskModify~<62>path~<60>0~<124|126>i~<60>25~<62>marcelOS/apis/mTaskModify~<62>data~<60>0~<124|126>i~<60>30~<62>data/marcelOS/apis/mTaskModify~<62>sha1~<60>0~<124|126>i~<60>32~<62>4e4b5987626b4ef4237d91dce4cda562~<62|62>file~<60>0~<124|124>name~<60>0~<124>mView~<62>path~<60>0~<124>marcelOS/apis/mView~<62>data~<60>0~<124|126>i~<60>24~<62>data/marcelOS/apis/mView~<62>sha1~<60>0~<124|126>i~<60>32~<62>56adc4d5269c28573ae7f1af57a0ccd5~<62|62>file~<60>0~<124|124>name~<60>0~<124>path~<62>path~<60>0~<124>marcelOS/apis/path~<62>data~<60>0~<124|126>i~<60>23~<62>data/marcelOS/apis/path~<62>sha1~<60>0~<124|126>i~<60>32~<62>78f34872bc23e31ca0a84f137050ab7c~<62|62>file~<60>0~<124|124>name~<60>0~<124>programs~<62>path~<60>0~<124|126>i~<60>22~<62>marcelOS/apis/programs~<62>data~<60>0~<124|126>i~<60>27~<62>data/marcelOS/apis/programs~<62>sha1~<60>0~<124|126>i~<60>32~<62>bca718f920ccf11e09e4718f153d3ddd~<62|62>file~<60>0~<124|124>name~<60>0~<124>sha1~<62>path~<60>0~<124>marcelOS/apis/sha1~<62>data~<60>0~<124|126>i~<60>23~<62>data/marcelOS/apis/sha1~<62>sha1~<60>0~<124|126>i~<60>32~<62>52d1c7d797a9fdcc71d6b80e31b694b2~<62|62>file~<60>0~<124|124>name~<60>0~<124>vec3~<62>path~<60>0~<124>marcelOS/apis/vec3~<62>data~<60>0~<124|126>i~<60>23~<62>data/marcelOS/apis/vec3~<62>sha1~<60>0~<124|126>i~<60>32~<62>7408867c3d6638a629a6148db8e62b8c~<62|62>file~<60>0~<124|124>name~<60>0~<124>windows~<62>path~<60>0~<124|126>i~<60>21~<62>marcelOS/apis/windows~<62>data~<60>0~<124|126>i~<60>26~<62>data/marcelOS/apis/windows~<62>sha1~<60>0~<124|126>i~<60>32~<62>b2a1baa9ca48c2d84a19f851b7aa7edd~<62|62>file~<60>0~<124|124>name~<60>0~<124>winobj~<62>path~<60>0~<124>marcelOS/apis/winobj~<62>data~<60>0~<124|126>i~<60>25~<62>data/marcelOS/apis/winobj~<62>sha1~<60>0~<124|126>i~<60>32~<62>65b059976f4c91c6c3e13d81e54be30e~<62|62|62|62>folder~<60>0~<124|124>name~<60>0~<124>data~<62>path~<60>0~<124>marcelOS/data~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>ip~<62>path~<60>0~<124>marcelOS/data/ip~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>settings~<62>path~<60>0~<124|126>i~<60>25~<62>marcelOS/data/ip/settings~<62>data~<60>0~<124|126>i~<60>30~<62>data/marcelOS/data/ip/settings~<62>sha1~<60>0~<124|126>i~<60>32~<62>61b912637b7317c5bcb6c6cd3cabdc57~<62|62|62|62>folder~<60>0~<124|124>name~<60>0~<124>lps~<62>path~<60>0~<124>marcelOS/data/lps~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>pos~<62>path~<60>0~<124|126>i~<60>21~<62>marcelOS/data/lps/pos~<62>data~<60>0~<124|126>i~<60>26~<62>data/marcelOS/data/lps/pos~<62>sha1~<60>0~<124|126>i~<60>32~<62>3fbede0e25493eba81c63163f10c29f1~<62|62|62|62>folder~<60>0~<124|124>name~<60>0~<124>mgps~<62>path~<60>0~<124>marcelOS/data/mgps~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>pos~<62>path~<60>0~<124|126>i~<60>22~<62>marcelOS/data/mgps/pos~<62>data~<60>0~<124|126>i~<60>27~<62>data/marcelOS/data/mgps/pos~<62>sha1~<60>0~<124|126>i~<60>32~<62>c06ee206d6d08908054f90ad89bd2359~<62|62>file~<60>0~<124|124>name~<60>0~<124>settings~<62>path~<60>0~<124|126>i~<60>27~<62>marcelOS/data/mgps/settings~<62>data~<60>0~<124|126>i~<60>32~<62>data/marcelOS/data/mgps/settings~<62>sha1~<60>0~<124|126>i~<60>32~<62>12837ece5bafca30fef8e15318d1ee08~<62|62|62|62>folder~<60>0~<124|124>name~<60>0~<124>mView~<62>path~<60>0~<124>marcelOS/data/mView~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>screen1~<62>path~<60>0~<124|126>i~<60>27~<62>marcelOS/data/mView/screen1~<62>data~<60>0~<124|126>i~<60>32~<62>data/marcelOS/data/mView/screen1~<62>sha1~<60>0~<124|126>i~<60>32~<62>8550fef3d79e44eed82943a59b4b6a5e~<62|62|62|62>folder~<60>0~<124|124>name~<60>0~<124>programs~<62>path~<60>0~<124|126>i~<60>22~<62>marcelOS/data/programs~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>settings.ehtf~<62>path~<60>0~<124|126>i~<60>36~<62>marcelOS/data/programs/settings.ehtf~<62>data~<60>0~<124|126>i~<60>41~<62>data/marcelOS/data/programs/settings.ehtf~<62>sha1~<60>0~<124|126>i~<60>32~<62>02ebaa4d538a3fe1dd5c2c4e7aac5906~<62|62|62|62|62|62|62|62|62|62|62|62>>>>>folder<0||name<0|marcelOS_base_autostart>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_base_autostart>sub<0||file<0||name<0|config.ehtf>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_base_autostart/config.ehtf>data<0|~<60|126>t~<60>true~<62>about~<60>0~<124>Softwareupdate~<62>name~<60>0~<124|126>i~<60>23~<62>marcelOS Base Autostart~<62>path~<60>0~<124>/~<62>ver~<60>0~<124>1.0~<62>sha1~<60>3~<124>true~<62>data~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124|124|62>path~<60>0~<124|124|62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>marcelOS~<62>path~<60>0~<124>/marcelOS~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>autorun~<62>path~<60>0~<124>marcelOS/autorun~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>debugger~<62>path~<60>0~<124|126>i~<60>25~<62>marcelOS/autorun/debugger~<62>data~<60>0~<124|126>i~<60>30~<62>data/marcelOS/autorun/debugger~<62>sha1~<60>0~<124|126>i~<60>32~<62>ee5db2f1daab35ba69cd683b577d783c~<62|62>file~<60>0~<124|124>name~<60>0~<124>DHCPregister~<62>path~<60>0~<124|126>i~<60>29~<62>marcelOS/autorun/DHCPregister~<62>data~<60>0~<124|126>i~<60>34~<62>data/marcelOS/autorun/DHCPregister~<62>sha1~<60>0~<124|126>i~<60>32~<62>5141ca781c67a03bea529cf322c5736f~<62|62>file~<60>0~<124|124>name~<60>0~<124>explorer~<62>path~<60>0~<124|126>i~<60>25~<62>marcelOS/autorun/explorer~<62>data~<60>0~<124|126>i~<60>30~<62>data/marcelOS/autorun/explorer~<62>sha1~<60>0~<124|126>i~<60>32~<62>7637528d421f9f37afff29035064021e~<62|62|62|62>folder~<60>0~<124|124>name~<60>0~<124>data~<62>path~<60>0~<124>marcelOS/data~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>DHCPregister~<62>path~<60>0~<124|126>i~<60>26~<62>marcelOS/data/DHCPregister~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>settings~<62>path~<60>0~<124|126>i~<60>35~<62>marcelOS/data/DHCPregister/settings~<62>data~<60>0~<124|126>i~<60>40~<62>data/marcelOS/data/DHCPregister/settings~<62>sha1~<60>0~<124|126>i~<60>32~<62>546f0471f73d2b270879a9b806092130~<62|62|62|62|62|62|62|62|62|62|62|62>>>>>folder<0||name<0|marcelOS_base_drivers>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_base_drivers>sub<0||file<0||name<0|config.ehtf>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_base_drivers/config.ehtf>data<0|~<60|126>t~<60>true~<62>about~<60>0~<124>Softwareupdate~<62>name~<60>0~<124|126>i~<60>21~<62>marcelOS Base Drivers~<62>path~<60>0~<124>/marcelOS/drivers~<62>ver~<60>0~<124>1.0~<62>sha1~<60>3~<124>true~<62>data~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124|124|62>path~<60>0~<124|124|62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124|126>i~<60>24~<62>driver_01windowconverter~<62>path~<60>0~<124|126>i~<60>25~<62>/driver_01windowconverter~<62>data~<60>0~<124|126>i~<60>29~<62>data/driver_01windowconverter~<62>sha1~<60>0~<124|126>i~<60>32~<62>c628164da1c27d4dec1ea307075eefd1~<62|62>file~<60>0~<124|124>name~<60>0~<124>driver_IP~<62>path~<60>0~<124>/driver_IP~<62>data~<60>0~<124>data/driver_IP~<62>sha1~<60>0~<124|126>i~<60>32~<62>1820b4b3cdbf63f859d6c765dd3c3470~<62|62>file~<60>0~<124|124>name~<60>0~<124>driver_mView~<62>path~<60>0~<124>/driver_mView~<62>data~<60>0~<124>data/driver_mView~<62>sha1~<60>0~<124|126>i~<60>32~<62>c5d1a7e4fe02df8799b9714102ee5b26~<62|62>file~<60>0~<124|124>name~<60>0~<124>driver_peripheral~<62>path~<60>0~<124>/driver_peripheral~<62>data~<60>0~<124|126>i~<60>22~<62>data/driver_peripheral~<62>sha1~<60>0~<124|126>i~<60>32~<62>8276bd2da29a1d091d4d0432a62366da~<62|62>file~<60>0~<124|124>name~<60>0~<124|126>i~<60>22~<62>driver_peripheralcable~<62>path~<60>0~<124|126>i~<60>23~<62>/driver_peripheralcable~<62>data~<60>0~<124|126>i~<60>27~<62>data/driver_peripheralcable~<62>sha1~<60>0~<124|126>i~<60>32~<62>dafa302ae9b71c566bc433ddcc28e85f~<62|62>file~<60>0~<124|124>name~<60>0~<124>driver_turtle~<62>path~<60>0~<124>/driver_turtle~<62>data~<60>0~<124>data/driver_turtle~<62>sha1~<60>0~<124|126>i~<60>32~<62>16e82be467077baccf714f11f263cd39~<62|62>file~<60>0~<124|124>name~<60>0~<124>driver_windows~<62>path~<60>0~<124>/driver_windows~<62>data~<60>0~<124>data/driver_windows~<62>sha1~<60>0~<124|126>i~<60>32~<62>0a6fd810ac8d99dccf7119e8a3a54bd0~<62|62|62|62|62|62>>>>>folder<0||name<0|marcelOS_base_startup>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_base_startup>sub<0||file<0||name<0|config.ehtf>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_base_startup/config.ehtf>data<0|~<60|126>t~<60>true~<62>about~<60>0~<124>Softwareupdate~<62>name~<60>0~<124|126>i~<60>21~<62>marcelOS Base Startup~<62>path~<60>0~<124>/marcelOS/startup~<62>ver~<60>0~<124>1.0~<62>sha1~<60>3~<124>true~<62>data~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124|124|62>path~<60>0~<124|124|62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>01-apis~<62>path~<60>0~<124>/01-apis~<62>data~<60>0~<124>data/01-apis~<62>sha1~<60>0~<124|126>i~<60>32~<62>f0ac497f55477af4a54ea4c38ced3a5b~<62|62>file~<60>0~<124|124>name~<60>0~<124>02-autostart~<62>path~<60>0~<124>/02-autostart~<62>data~<60>0~<124>data/02-autostart~<62>sha1~<60>0~<124|126>i~<60>32~<62>5c4af0d20ef7f104b928d92dd043e12f~<62|62>file~<60>0~<124|124>name~<60>0~<124>03-login~<62>path~<60>0~<124>/03-login~<62>data~<60>0~<124>data/03-login~<62>sha1~<60>0~<124|126>i~<60>32~<62>a432a99eee16e4fe0e7a1994f286e2d3~<62|62>file~<60>0~<124|124>name~<60>0~<124>04-userautostart~<62>path~<60>0~<124>/04-userautostart~<62>data~<60>0~<124|126>i~<60>21~<62>data/04-userautostart~<62>sha1~<60>0~<124|126>i~<60>32~<62>a8a4a3d850b5bb6bc8dcb514ecba2e7e~<62|62>file~<60>0~<124|124>name~<60>0~<124>05-debug~<62>path~<60>0~<124>/05-debug~<62>data~<60>0~<124>data/05-debug~<62>sha1~<60>0~<124|126>i~<60>32~<62>fa3b7a8cc75c542d245cf09e9a4c77c3~<62|62>file~<60>0~<124|124>name~<60>0~<124>06-task~<62>path~<60>0~<124>/06-task~<62>data~<60>0~<124>data/06-task~<62>sha1~<60>0~<124|126>i~<60>32~<62>eaf0dcde9cd4ba3e8bd1bde74baed2b3~<62|62|62|62|62|62>>>>>folder<0||name<0|marcelOS_license>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_license>sub<0||file<0||name<0|config.ehtf>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_license/config.ehtf>data<0|~<60|126>t~<60>true~<62>about~<60>0~<124>Softwareupdate~<62>name~<60>0~<124>marcelOS License~<62>path~<60>0~<124>/~<62>ver~<60>0~<124>1.0~<62>sha1~<60>3~<124>true~<62>data~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124|124|62>path~<60>0~<124|124|62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>COPYING.GPL.txt~<62>path~<60>0~<124>/COPYING.GPL.txt~<62>data~<60>0~<124>data/COPYING.GPL.txt~<62>sha1~<60>0~<124|126>i~<60>32~<62>b3b99a4ab26ac5e0c76b3bebdec80020~<62|62>file~<60>0~<124|124>name~<60>0~<124|126>i~<60>23~<62>COPYING.modifiedGPL.txt~<62>path~<60>0~<124|126>i~<60>24~<62>/COPYING.modifiedGPL.txt~<62>data~<60>0~<124|126>i~<60>28~<62>data/COPYING.modifiedGPL.txt~<62>sha1~<60>0~<124|126>i~<60>32~<62>b2c3034aec33afe5e9bf658ed3bb04ed~<62|62|62|62|62|62>>>>>folder<0||name<0|marcelOS_programs_basic_programs>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_programs_basic_programs>sub<0||file<0||name<0|config.ehtf>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_programs_basic_programs/config.ehtf>data<0|~<60|126>t~<60>true~<62>about~<60>0~<124>Softwareupdate~<62>name~<60>0~<124|126>i~<60>23~<62>marcelOS Basic Programs~<62>path~<60>0~<124>/~<62>ver~<60>0~<124>1.0~<62>sha1~<60>3~<124>true~<62>data~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124|124|62>path~<60>0~<124|124|62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>marcelOS~<62>path~<60>0~<124>/marcelOS~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>programs~<62>path~<60>0~<124>marcelOS/programs~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>cmd~<62>path~<60>0~<124|126>i~<60>21~<62>marcelOS/programs/cmd~<62>data~<60>0~<124|126>i~<60>26~<62>data/marcelOS/programs/cmd~<62>sha1~<60>0~<124|126>i~<60>32~<62>415ef50a613e982ad45b46ae49dff3c2~<62|62>folder~<60>0~<124|124>name~<60>0~<124>dll~<62>path~<60>0~<124|126>i~<60>21~<62>marcelOS/programs/dll~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>info.txt~<62>path~<60>0~<124|126>i~<60>30~<62>marcelOS/programs/dll/info.txt~<62>data~<60>0~<124|126>i~<60>35~<62>data/marcelOS/programs/dll/info.txt~<62>sha1~<60>0~<124|126>i~<60>32~<62>b2c560ffa06906de8f45b3f54ac31772~<62|62|62|62>file~<60>0~<124|124>name~<60>0~<124>mview-settings~<62>path~<60>0~<124|126>i~<60>32~<62>marcelOS/programs/mview-settings~<62>data~<60>0~<124|126>i~<60>37~<62>data/marcelOS/programs/mview-settings~<62>sha1~<60>0~<124|126>i~<60>32~<62>5b6813ce8700848455ab659282a4c4e5~<62|62>folder~<60>0~<124|124>name~<60>0~<124>programs-dll~<62>path~<60>0~<124|126>i~<60>30~<62>marcelOS/programs/programs-dll~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>avi~<62>path~<60>0~<124|126>i~<60>34~<62>marcelOS/programs/programs-dll/avi~<62>data~<60>0~<124|126>i~<60>39~<62>data/marcelOS/programs/programs-dll/avi~<62>sha1~<60>0~<124|126>i~<60>32~<62>acfad626ac4f710cc7683c1ceffdb393~<62|62>file~<60>0~<124|124>name~<60>0~<124>execute~<62>path~<60>0~<124|126>i~<60>38~<62>marcelOS/programs/programs-dll/execute~<62>data~<60>0~<124|126>i~<60>43~<62>data/marcelOS/programs/programs-dll/execute~<62>sha1~<60>0~<124|126>i~<60>32~<62>0c712705823ceb094a332293ab701517~<62|62>file~<60>0~<124|124>name~<60>0~<124>lnk~<62>path~<60>0~<124|126>i~<60>34~<62>marcelOS/programs/programs-dll/lnk~<62>data~<60>0~<124|126>i~<60>39~<62>data/marcelOS/programs/programs-dll/lnk~<62>sha1~<60>0~<124|126>i~<60>32~<62>acfad626ac4f710cc7683c1ceffdb393~<62|62|62|62>file~<60>0~<124|124>name~<60>0~<124>taskmanager~<62>path~<60>0~<124|126>i~<60>29~<62>marcelOS/programs/taskmanager~<62>data~<60>0~<124|126>i~<60>34~<62>data/marcelOS/programs/taskmanager~<62>sha1~<60>0~<124|126>i~<60>32~<62>8beb1d873ee61ff99d306135be188609~<62|62|62|62|62|62|62|62|62|62>>>>>folder<0||name<0|marcelOS_programs_software_installers>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_programs_software_installers>sub<0||file<0||name<0|config.ehtf>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_programs_software_installers/config.ehtf>data<0|~<60|126>t~<60>true~<62>about~<60>0~<124>Softwareupdate~<62>name~<60>0~<124|126>i~<60>28~<62>marcelOS Software Installers~<62>path~<60>0~<124>/~<62>ver~<60>0~<124>1.0~<62>sha1~<60>3~<124>true~<62>data~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124|124|62>path~<60>0~<124|124|62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>marcelOS~<62>path~<60>0~<124>/marcelOS~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>data~<62>path~<60>0~<124>marcelOS/data~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>SoftwareUpdater~<62>path~<60>0~<124|126>i~<60>29~<62>marcelOS/data/SoftwareUpdater~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>programs~<62>path~<60>0~<124|126>i~<60>38~<62>marcelOS/data/SoftwareUpdater/programs~<62>sub~<60>0~<124|124|62|62>file~<60>0~<124|124>name~<60>0~<124>settings.ehtf~<62>path~<60>0~<124|126>i~<60>43~<62>marcelOS/data/SoftwareUpdater/settings.ehtf~<62>data~<60>0~<124|126>i~<60>48~<62>data/marcelOS/data/SoftwareUpdater/settings.ehtf~<62>sha1~<60>0~<124|126>i~<60>32~<62>8c507f40cd1805c927d9f471f5806ce9~<62|62|62|62>folder~<60>0~<124|124>name~<60>0~<124>Startdisk~<62>path~<60>0~<124|126>i~<60>23~<62>marcelOS/data/Startdisk~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124|126>i~<60>24~<62>installfinished_template~<62>path~<60>0~<124|126>i~<60>48~<62>marcelOS/data/Startdisk/installfinished_template~<62>data~<60>0~<124|126>i~<60>53~<62>data/marcelOS/data/Startdisk/installfinished_template~<62>sha1~<60>0~<124|126>i~<60>32~<62>383675d4918cf673c7971b9fbd7e60bc~<62|62>file~<60>0~<124|124>name~<60>0~<124>install_template~<62>path~<60>0~<124|126>i~<60>40~<62>marcelOS/data/Startdisk/install_template~<62>data~<60>0~<124|126>i~<60>45~<62>data/marcelOS/data/Startdisk/install_template~<62>sha1~<60>0~<124|126>i~<60>32~<62>81e12aba2294683de5314293023c1208~<62|62>file~<60>0~<124|124>name~<60>0~<124>selfextract_template~<62>path~<60>0~<124|126>i~<60>44~<62>marcelOS/data/Startdisk/selfextract_template~<62>data~<60>0~<124|126>i~<60>49~<62>data/marcelOS/data/Startdisk/selfextract_template~<62>sha1~<60>0~<124|126>i~<60>32~<62>c390117d26ffeb9535b5f81716d194e4~<62|62|62|62|62|62>folder~<60>0~<124|124>name~<60>0~<124>programs~<62>path~<60>0~<124>marcelOS/programs~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>dll~<62>path~<60>0~<124|126>i~<60>21~<62>marcelOS/programs/dll~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>info.txt~<62>path~<60>0~<124|126>i~<60>30~<62>marcelOS/programs/dll/info.txt~<62>data~<60>0~<124|126>i~<60>35~<62>data/marcelOS/programs/dll/info.txt~<62>sha1~<60>0~<124|126>i~<60>32~<62>b2c560ffa06906de8f45b3f54ac31772~<62|62>file~<60>0~<124|124>name~<60>0~<124>mprojectmeta~<62>path~<60>0~<124|126>i~<60>34~<62>marcelOS/programs/dll/mprojectmeta~<62>data~<60>0~<124|126>i~<60>39~<62>data/marcelOS/programs/dll/mprojectmeta~<62>sha1~<60>0~<124|126>i~<60>32~<62>65450556cd4b478f108ecac2ccf5aa1d~<62|62>file~<60>0~<124|124>name~<60>0~<124>mzip~<62>path~<60>0~<124|126>i~<60>26~<62>marcelOS/programs/dll/mzip~<62>data~<60>0~<124|126>i~<60>31~<62>data/marcelOS/programs/dll/mzip~<62>sha1~<60>0~<124|126>i~<60>32~<62>e8d11a4860a4bed6223f08578dd472da~<62|62|62|62>file~<60>0~<124|124>name~<60>0~<124>Project_create~<62>path~<60>0~<124|126>i~<60>32~<62>marcelOS/programs/Project_create~<62>data~<60>0~<124|126>i~<60>37~<62>data/marcelOS/programs/Project_create~<62>sha1~<60>0~<124|126>i~<60>32~<62>3dd398d53e36d76289c096413060852a~<62|62>file~<60>0~<124|124>name~<60>0~<124>SoftwareUpdater~<62>path~<60>0~<124|126>i~<60>33~<62>marcelOS/programs/SoftwareUpdater~<62>data~<60>0~<124|126>i~<60>38~<62>data/marcelOS/programs/SoftwareUpdater~<62>sha1~<60>0~<124|126>i~<60>32~<62>c1648ea3379a328c90230ef8ae5aca32~<62|62>file~<60>0~<124|124>name~<60>0~<124>Startdisk~<62>path~<60>0~<124|126>i~<60>27~<62>marcelOS/programs/Startdisk~<62>data~<60>0~<124|126>i~<60>32~<62>data/marcelOS/programs/Startdisk~<62>sha1~<60>0~<124|126>i~<60>32~<62>51d65328abc19136b1c31a877a0af136~<62|62|62|62|62|62|62|62|62|62>>>>>folder<0||name<0|marcelOS_programs_ssh>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_programs_ssh>sub<0||file<0||name<0|config.ehtf>path<0|marcelOS/data/SoftwareUpdater/programs/marcelOS_programs_ssh/config.ehtf>data<0|~<60|126>t~<60>true~<62>about~<60>0~<124>Softwareupdate~<62>name~<60>0~<124|126>i~<60>21~<62>marcelOS SSH Programs~<62>path~<60>0~<124>/~<62>ver~<60>0~<124>1.0~<62>sha1~<60>3~<124>true~<62>data~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124|124|62>path~<60>0~<124|124|62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>marcelOS~<62>path~<60>0~<124>/marcelOS~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>data~<62>path~<60>0~<124>marcelOS/data~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>ssh_service~<62>path~<60>0~<124|126>i~<60>25~<62>marcelOS/data/ssh_service~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>users.ehtf~<62>path~<60>0~<124|126>i~<60>36~<62>marcelOS/data/ssh_service/users.ehtf~<62>data~<60>0~<124|126>i~<60>41~<62>data/marcelOS/data/ssh_service/users.ehtf~<62>sha1~<60>0~<124|126>i~<60>32~<62>87eacf1f826dd7444c08c8edd0983f65~<62|62|62|62|62|62>folder~<60>0~<124|124>name~<60>0~<124>programs~<62>path~<60>0~<124>marcelOS/programs~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>ssh_Client~<62>path~<60>0~<124|126>i~<60>28~<62>marcelOS/programs/ssh_Client~<62>data~<60>0~<124|126>i~<60>33~<62>data/marcelOS/programs/ssh_Client~<62>sha1~<60>0~<124|126>i~<60>32~<62>f7a11a9be6cb89b762aacede16b72861~<62|62>file~<60>0~<124|124>name~<60>0~<124>ssh_service~<62>path~<60>0~<124|126>i~<60>29~<62>marcelOS/programs/ssh_service~<62>data~<60>0~<124|126>i~<60>34~<62>data/marcelOS/programs/ssh_service~<62>sha1~<60>0~<124|126>i~<60>32~<62>ce94587dafbed7b54f2617e440f2fade~<62|62|62|62|62|62|62|62|62|62>>>>>folder<0||name<0|marcels_programs>path<0|marcelOS/data/SoftwareUpdater/programs/marcels_programs>sub<0||file<0||name<0|config.ehtf>path<0|marcelOS/data/SoftwareUpdater/programs/marcels_programs/config.ehtf>data<0|~<60|126>t~<60>true~<62>about~<60>0~<124>Softwareupdate~<62>name~<60>0~<124>marcels Programs~<62>path~<60>0~<124>/~<62>ver~<60>0~<124>1.0~<62>sha1~<60>3~<124>true~<62>data~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124|124|62>path~<60>0~<124|124|62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>user~<62>path~<60>0~<124>/user~<62>sub~<60>0~<124|124>folder~<60>0~<124|124>name~<60>0~<124>autostart~<62>path~<60>0~<124>user/autostart~<62>sub~<60>0~<124|124|62|62>folder~<60>0~<124|124>name~<60>0~<124>examples~<62>path~<60>0~<124>user/examples~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>evlc~<62>path~<60>0~<124>user/examples/evlc~<62>data~<60>0~<124|126>i~<60>23~<62>data/user/examples/evlc~<62>sha1~<60>0~<124|126>i~<60>32~<62>5b7982009abeb8c190518627a3e73637~<62|62>file~<60>0~<124|124>name~<60>0~<124>evlc2~<62>path~<60>0~<124>user/examples/evlc2~<62>data~<60>0~<124|126>i~<60>24~<62>data/user/examples/evlc2~<62>sha1~<60>0~<124|126>i~<60>32~<62>a76f9aa58c60a16530258fcce035ed7b~<62|62>file~<60>0~<124|124>name~<60>0~<124>logo.img~<62>path~<60>0~<124|126>i~<60>22~<62>user/examples/logo.img~<62>data~<60>0~<124|126>i~<60>27~<62>data/user/examples/logo.img~<62>sha1~<60>0~<124|126>i~<60>32~<62>492c3e85b214e7491428c195eaf5794b~<62|62|62|62>folder~<60>0~<124|124>name~<60>0~<124>programs~<62>path~<60>0~<124>user/programs~<62>sub~<60>0~<124|124>file~<60>0~<124|124>name~<60>0~<124>MSPaint~<62>path~<60>0~<124|126>i~<60>21~<62>user/programs/MSPaint~<62>data~<60>0~<124|126>i~<60>26~<62>data/user/programs/MSPaint~<62>sha1~<60>0~<124|126>i~<60>32~<62>2c0fc1dca3fa8b16e60fbdd5c4e019aa~<62|62>file~<60>0~<124|124>name~<60>0~<124>simple~<62>path~<60>0~<124>user/programs/simple~<62>data~<60>0~<124|126>i~<60>25~<62>data/user/programs/simple~<62>sha1~<60>0~<124|126>i~<60>32~<62>9a2040f6a5e44c0e0f51beaa4f5ccbc1~<62|62|62|62|62|62|62|62|62|62>>>>>>>file<0||name<0|settings.ehtf>path<0|marcelOS/data/SoftwareUpdater/settings.ehtf>data<0|~<60|126>t~<60>true~<62>autoupdate~<60>0~<124>true~<62|62>>>>>folder<0||name<0|ssh_service>path<0|marcelOS/data/ssh_service>sub<0||file<0||name<0|users.ehtf>path<0|marcelOS/data/ssh_service/users.ehtf>data<0|~<60|126>t~<60>true~<62>1~<60>name~<60>0~<124>root~<62>su~<60>3~<124>-1~<62>pw~<60>0~<124>123~<62|62|62>>>>>folder<0||name<0|Startdisk>path<0|marcelOS/data/Startdisk>sub<0||file<0||name<0|installfinished_template>path<0|marcelOS/data/Startdisk/installfinished_template>data<0|local function SelectColor(acolor)~<10>if term.isColor and term.isColor() then~<10>	term.setTextColor(acolor or colors.white)~<10>	end~<10>end~<10|10>term.clear()~<10>term.setCursorPos(1,1)~<10>SelectColor(colors.green)~<10>print(~<34>Your installation is complete~<34>) ~<10>SelectColor(colors.white)~<10>print(~<34>PC will reboot now~<34>) ~<10>if fs.exists(~<34>/marcelOS.install~<34>) then~<10>	fs.delete(~<34>/marcelOS.install~<34>)~<10>	end~<10>sleep(1.5)~<10>os.reboot()>>file<0||name<0|install_template>path<0|marcelOS/data/Startdisk/install_template>data<0|local function SelectColor(acolor)~<10>if term.isColor and term.isColor() then~<10>	term.setTextColor(acolor or colors.white)~<10>	end~<10>end~<10|10>local function PrintMessage(...)~<10>local mx,my = term.getSize()~<10>local x,y = 0,0~<10>term.clear()~<10|10>local args = {...}~<10>local i = 0~<10>for i = 1,#args do~<10>	term.setCursorPos(4, 2+i) ~<10>	term.write(args[i]) ~<10>	end~<10|10>-- border~<10>SelectColor(colors.cyan)~<10>local astr = string.rep(~<34>X~<34>,mx)~<10>local bstr = ~<34|34|10|10>term.setCursorPos(1, 1) ~<10>term.write(astr) ~<10>term.setCursorPos(1, my) ~<10>term.write(astr) ~<10|10>for y = 1,my do ~<10>	term.setCursorPos(1, y)  ~<10>	term.write(~<34>X~<34>) ~<10>	term.setCursorPos(mx, y)  ~<10>	term.write(~<34>X~<34>) ~<10>	end~<10>	~<10>SelectColor(colors.white)~<10>return #args+3~<10>end~<10|10>local free = 1+ PrintMessage(~<34>marcelOS installer~<34>,~<34>------------------~<34>,~<34|34>,~<34|34>,~<34>Thank you for using marcelOS~<34>,~<34>This Program will guide you through~<34>,~<34>the installation.~<34>)~<10|10>SelectColor(colors.red)~<10>term.setCursorPos(4, 7)~<10>term.write(~<34>Thank you for using marcelOS~<34>) ~<10>sleep(3)~<10>term.setCursorPos(4, free)~<10>SelectColor(colors.green)~<10>term.write(~<34>press ENTER...~<34>)~<10>SelectColor(colors.white)~<10>read() ~<10|10>free = 1+ PrintMessage(~<34>Page 1 of 3~<34>,~<34|34>,~<34|34>,~<34>This setup will copy all marcelOS ~<34>,~<34>files to your computer, then the PC will ~<34>,~<34>reboot and you can use your new OS :)~<34>,~<34>Keep in mind, that this installer ~<34>,~<34>MAY overwrite files!~<34>)~<10>sleep(3)~<10>term.setCursorPos(4, free)~<10>SelectColor(colors.green)~<10>print(~<34>press ENTER...~<34>)~<10>SelectColor(colors.white)~<10>read() ~<10|10>free = 1+ PrintMessage(~<34>Page 2 of 3~<34>,~<34|34>,~<34|34>,~<34>all marcelOS files are licenced ~<34>,~<34>under the modified GPL 2.0,~<34>,~<34>read http://www.gnu.org/licenses/gpl-2.0.html!~<34>)~<10>SelectColor(colors.red)~<10>term.setCursorPos(4, 6)~<10>term.write(~<34>all marcelOS files are licenced ~<34>)~<10>term.setCursorPos(4, 7)~<10>term.write(~<34>under the modified GPL 2.0,~<34>)~<10>sleep(3)~<10>term.setCursorPos(4, free)~<10>SelectColor(colors.green)~<10>term.write(~<34>press ENTER...~<34>)~<10>SelectColor(colors.white)~<10>read() ~<10|10|10>free = 1+ PrintMessage(~<34>Page 3 of 3~<34>,~<34|34>,~<34|34>,~<34>for additional information, visite my website:~<34>,~<34>http://marcelmaertens.funpic.de~<34>)~<10>sleep(3)~<10>term.setCursorPos(4, free)~<10>SelectColor(colors.green)~<10>term.write(~<34>press ENTER to start Setup...~<34>)~<10>SelectColor(colors.white)~<10>read() >>file<0||name<0|selfextract_template>path<0|marcelOS/data/Startdisk/selfextract_template>data<0|--[[ ~<10>APIS needed for Decompressing !!!~<10>- classapi~<10>- path~<10>- ehtfutils~<10>- ehtf~<10>]]~<10|10>--[[~<10>classapi~<10>]]~<10|10>--[[~<10>THANKS to Ian~<10>http://www.rtsoft.com/forums/showthread.php?1466-A-cleaner-easier-class-idiom-in-Lua~<10>]]~<10|10>function class(superclass, name)~<10>    local cls = superclass and superclass() or {}~<10>    cls.__name = name or ~<34|34|10>    cls.__super = superclass~<10>	cls.__index = cls~<10>    return setmetatable(cls, ~<10>	  {~<10>	  __call = function (c, ...)~<10>      local instance = setmetatable({__class = cls}, cls)~<10>      if cls.__init then~<10>         cls.__init(instance, ...)~<10>         end~<10>      return instance~<10>      end~<10>	  }~<10>	)~<10>end~<10|10>--[[~<10|10>function class()~<10>    local cls = {}~<10>    cls.__index = cls~<10>    return setmetatable(cls, ~<10>	  {~<10>	  __call = function (c, ...)~<10>      local instance = setmetatable({}, cls)~<10>      if cls.__init then~<10>         cls.__init(instance, ...)~<10>         end~<10>      return instance~<10>      end~<10>	  }~<10>	)~<10>end~<10>]]~<10|10>function issubclass(class1, class2)~<10>if (type(class1) ~<126>= ~<34>table~<34>) or (type(class2) ~<126>= ~<34>table~<34>) then~<10>	return false~<10>	end~<10>while true do~<10>    if class1 == class2 then~<10>        return true~<10>        end~<10>    class2 = class2.__super~<10>    if not class2 then~<10>        break~<10>		end~<10>    end~<10>return false~<10>end~<10|10>function isinstance(inst, cls)~<10>return (type(inst) == ~<34>table~<34>) and issubclass(inst.__class, cls)~<10>end~<10|10|10|10>--[[~<10>path~<10>]]~<10|10>local osPath = ~<34>marcelOS~<34|10>local apisPath = ~<34>apis~<34|10>local dataPath = ~<34>data~<34|10>local autorunPath = ~<34>autorun~<34|10>local tempPath = ~<34>temp~<34|10>local userPath = ~<34>user~<34|10>local userautostartPath = ~<34>autostart~<34|10>local driverPath = ~<34>drivers~<34|10>local programsPath = ~<34>programs~<34|10|10>function FOLDER(apath)~<10>apath = tostring(apath)~<10>if string.char(string.byte(apath,apath:len())) ~<126>= '/' then~<10>	return apath..~<34>/~<34|10>	else~<10>	return apath~<10>	end~<10>end~<10|10>function ROOT(apath)~<10>apath = tostring(apath)~<10>if string.char(string.byte(apath)) ~<126>= '/' then~<10>	return ~<34>/~<34>..apath~<10>	else~<10>	return apath~<10>	end~<10>end~<10|10>function RPath(astr,bstr)~<10>if astr == ~<34>/~<34> then~<10>	return ROOT(bstr)~<10>	else~<10>	return ROOT(fs.combine(astr,bstr))~<10>	end~<10>end~<10|10>function OS()~<10>return ROOT(osPath)~<10>end~<10|10>function APIS()~<10>return ROOT(fs.combine(osPath,apisPath))~<10>end~<10|10>function DATA()~<10>return ROOT(fs.combine(osPath,dataPath))~<10>end~<10|10>function AUTORUN()~<10>return ROOT(fs.combine(osPath,autorunPath))~<10>end~<10|10>function USER()~<10>return ROOT(userPath)~<10>end~<10|10>function DRIVERS()~<10>return ROOT(fs.combine(osPath,driverPath))~<10>end~<10|10>function TEMP()~<10>return ROOT(fs.combine(osPath,tempPath))~<10>end~<10|10>function PROGRAMS()~<10>return ROOT(fs.combine(osPath,programsPath))~<10>end~<10|10>function USERAUTOSTART()~<10>return ROOT(fs.combine(userPath,userautostartPath))~<10>end~<10|10|10>--[[~<10>ehtfutils~<10>]]~<10|10>TEHTFStatus = {~<34>EHTFdone~<34>,~<34>EHTFdonePart~<34>,~<34>EHTFerror~<34>,~<34>EHTFexit~<34>,~<34>EHTFincorrectString~<34>,~<34>EHTFnone~<34>}~<10|10>TVarDec = class(nil,~<34>TVarDec~<34>)~<10|10>function TVarDec:__init()~<10>	self._Begin = ~<34|60|34|10>	self._End = ~<34|62|34|10>	self._Array = ~<34|124|34|10>	self._System = ~<34|126|34|10>	end~<10|10>ToStrPar = {~<34>tsWriteMetaInfo~<34>,~<34>tsWriteTypecast~<34>,~<34>tsUseTypecast~<34>,~<34>tsUseInsert~<34>}~<10>ToStrMode = {[~<34>tsWriteMetaInfo~<34>] = true,[~<34>tsWriteTypecast~<34>] = true,[~<34>tsUseTypecast~<34>] = true,[~<34>tsUseInsert~<34>] = true}~<10>stToStrMode =  {[~<34>tsWriteMetaInfo~<34>] = false,[~<34>tsWriteTypecast~<34>] = true,[~<34>tsUseTypecast~<34>] = true,[~<34>tsUseInsert~<34>] = true}~<10>stToStrModeAll =  {[~<34>tsWriteMetaInfo~<34>] = true,[~<34>tsWriteTypecast~<34>] = true,[~<34>tsUseTypecast~<34>] = true,[~<34>tsUseInsert~<34>] = true}~<10>EHTFversion = ~<34>0.9.8~<34|10|10>function stvardec()~<10>return TVarDec()~<10>end~<10|10>function TVarDec:Assign(vardec)~<10>-- Pflicht da Klasse und kein Record !~<10>self._Begin = vardec._Begin~<10>self._End = vardec._End~<10>self._Array = vardec._Array~<10>self._System = vardec._System~<10>end~<10|10>function FileToString( apath )~<10>local result = ~<34|34|10>local file = fs.open(apath,~<34>r~<34>)~<10>if file then~<10>	result = file.readAll()~<10>	file.close()~<10>	end~<10>return result~<10>end~<10|10>function StringToFile( apath , astring )~<10>local file = fs.open(apath,~<34>w~<34>)~<10>if file then~<10>	file.write(astring)~<10>	file.close()~<10>	end~<10>end~<10|10>function HTStrtoSVar(astr,typecast)~<10>-- Andere funktion...~<10>local result~<10>if typecast == 0 then~<10>	result = tostring(astr)~<10>	elseif (typecast == 1) or (typecast == 2) then~<10>		result = tonumber(astr)~<10>		elseif typecast == 3 then~<10>			result = toboolean(astr)~<10>			else~<10>			result = astr~<10>			end~<10>return result~<10>end~<10|10>function GetArt(SVar)~<10>-- NEW FUNCTION~<10>local result = 0~<10>if type(SVar) == ~<34>number~<34> then ~<10>	result = 1~<10>	elseif type(SVar) == ~<34>string~<34> then~<10>		result = 0~<10>		elseif type(SVar) == ~<34>boolean~<34> then~<10>			result = 3~<10>			else~<10>			result = -1~<10>			end~<10>return result~<10>end~<10|10>function toboolean(avalue)~<10>if type(avalue) == ~<34>number~<34> then~<10>	return (avalue == -1)~<10>	elseif type(avalue) == ~<34>string~<34> then~<10>		return (string.lower(avalue) == ~<34>true~<34>)~<10>		elseif type(avalue) == ~<34>boolean~<34> then~<10>			return avalue~<10>			else~<10>			return (avalue ~<126>= nil)~<10>			end~<10>end~<10|10>function HTVardectoStr(newvardec, oldvardec)~<10>local result = oldvardec._System .. oldvardec._Begin.. ~<34>v~<34>  .. oldvardec._Begin .. EHTFversion .. oldvardec._End~<10>       .. ~<34>_b~<34>   .. oldvardec._Begin .. string.byte(newvardec._Begin)   .. oldvardec._End~<10>       .. ~<34>_e~<34>     .. oldvardec._Begin .. string.byte(newvardec._End)     .. oldvardec._End~<10>       .. ~<34>_a~<34>   .. oldvardec._Begin .. string.byte(newvardec._Array)   .. oldvardec._End~<10>       .. ~<34>_s~<34>  .. oldvardec._Begin .. string.byte(newvardec._System)  .. oldvardec._End~<10>       .. oldvardec._End~<10>return result~<10>end~<10|10>--[[~<10>EHTF~<10>]]~<10|10>--[[~<10>Yeah, this is the Epic EHTF Node system in LUA.~<10>Now easy Save Data of every type in a Simple String !~<10>e.g. if you want to send a huge complex ammount of information over rednet...~<10|10>I RECOMMENT TO TURN tsUseInsert ALWAYS OFF !!! BEACAUSE EITHER ME or LUA is to ****** to find out, that the lenght of a string ~<34>hel/lo Wörld~<34> 13 is...~<10|10>]]~<10|10>THTNode = class(nil,~<34>THTNode~<34>)~<10|10>function StCutOutFunc(Sender , achar)~<10>local result = ((achar == Sender.vardec._Begin)~<10>		or (achar == Sender.vardec._End) ~<10>		or (achar == Sender.vardec._Array) ~<10>		or (achar == Sender.vardec._System) ~<10>		or (achar == string.char(0)))  ~<10>return result~<10>end~<10|10>function THTNode:__init()~<10>	self.parent = nil~<10>	self.vardec = TVarDec()~<10>	self.nodes = {}~<10>	self.Values = {} -- No Type needed, because lua :) ~<10>	self.about = ~<34|34|10>	self.CutOutfunc = StCutOutFunc~<10>	self.CaseSensitive = false~<10>	end~<10|10|10>--[[ ~<10>Missing:~<10|10|10>FindAllAbout~<10>FindAllAboutC~<10>FindAllVar~<10>ValidAbout~<10>GetCount~<10>GetItem~<10>SetItem~<10|10|10>Die FundAbout(about , p ) funktionen.... kein Out Parameter !~<10>]]~<10|10>--[[##################]]~<10>--[[       THTNode    ]]~<10>--[[##################]]   ~<10|10>function THTNode:Assign( from )~<10>local i = 0~<10>self.vardec = from.vardec~<10>self.CutOutfunc = from.CutOutfunc~<10>self.CaseSensitive = from.CaseSensitive~<10>self.about = from.about~<10>self.parent = from.parent~<10|10>self.Values = {}~<10>for i = 1,#from.Values do~<10>	self.Values[i] = from.Values[i]~<10>	end~<10>	~<10>self.nodes = {}~<10>for i = 1,#from.nodes do~<10>	self.nodes[i] = THTNode()~<10>	self.nodes[i]:Assign(from.nodes[i])~<10>	self.nodes[i].parent = self~<10>	end~<10>end~<10|10|10>--[[##################]]~<10>--[[  Add functtions  ]]~<10>--[[##################]]   ~<10|10>function THTNode:AddChild()~<10>local result = THTNode()~<10>self.nodes[#self.nodes+1] = result~<10>result.parent = self~<10>result.vardec = self.vardec~<10>result.CutOutfunc = self.CutOutfunc~<10>result.CaseSensitive = self.CaseSensitive~<10>return result~<10>end~<10|10>function THTNode:AddChildPos( pos )~<10>local result = THTNode()~<10>self:Insert(pos,result)~<10>result.parent = self~<10>result.vardec = self.vardec~<10>result.CutOutfunc = self.CutOutfunc~<10>result.CaseSensitive = self.CaseSensitive~<10>return result~<10>end~<10|10>function THTNode:Add(aabout , SVar)~<10>local result = nil~<10>local i = 0~<10>if type(aabout) == ~<34>table~<34> then~<10>	if isinstance(aabout,THTNode) then~<10>		result = #self.nodes+1~<10>		self.nodes[result] = aabout~<10>		aabout.parent = self~<10>		return result~<10>		end~<10>	end~<10>result = self:AddChild()~<10>result.about = aabout~<10>if type(SVar) == ~<34>table~<34> then~<10>	for i = 1,#SVar do~<10>		result:AddValue(SVar[i])~<10>		end~<10>	else~<10>	result:AddValue( SVar )~<10>	end~<10>return result~<10>end~<10|10>function THTNode:ParentAddBehind()~<10>local result = nil~<10>if self.parent ~<126>= nil then~<10>	local  i = self.parent:FindNode(self)~<10>	if i ~<62> 0 then ~<10>		result = self.parent:AddChildPos(i+1)~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:ParentAddBefore()~<10>local result = nil~<10>if self.parent ~<126>= nil then~<10>	local  i = self.parent:FindNode(self)~<10>	if i ~<62> 0 then ~<10>		result = self.parent:AddChildPos(i-1)~<10>		end~<10>	end~<10>return result~<10>end~<10|10>--[[#####################]]~<10>--[[  useful functtions  ]]~<10>--[[#####################]]   ~<10|10>function THTNode:AddValue( SVar )~<10>local result = #self.Values+1~<10>self.Values[result] = SVar~<10>return result~<10>end~<10|10|10>function THTNode:UnGroup( aindex )~<10>local i = 0~<10>local result = nil~<10>if type(aindex) ~<126>= ~<34>number~<34> then~<10>	result = aindex~<10>	aindex = self:FindNode(aindex)	~<10>	else~<10>	result = self.nodes[aindex]~<10>	end~<10>if (aindex ~<60> 1) or (aindex ~<62> #self.nodes) then ~<10>	return nil~<10>	end~<10>self.nodes[aindex] = nil~<10>for i = aindex,#self.nodes-1 do~<10>	self.nodes[i] = self.nodes [i+1]~<10>	end~<10>result.parent = nil~<10>return result~<10>end~<10|10|10>function THTNode:Delet( aindex )~<10>local i = 0~<10>if type(aindex) ~<126>= ~<34>number~<34> then~<10>	aindex = self:FindNode(aindex)	~<10>	end~<10>if (aindex ~<60> 1) or (aindex ~<62> #self.nodes) then ~<10>	return~<10>	end~<10>self.nodes[aindex] = nil~<10>for i = aindex,#self.nodes-1 do~<10>	self.nodes[i] = self.nodes [i+1]~<10>	end~<10>end~<10|10>function THTNode:Reduceto( aindex)~<10>if type(aindex) == ~<34>number~<34> then ~<10>	self:INTRedureToNumber(aindex)~<10>	else~<10>	self:INTRedureToNode(aindex)~<10>	end~<10>end~<10|10>-- INTERNAL~<10>function THTNode:INTReducetoNumber( aindex )~<10>local i = 0~<10>for i = #self.nodes,aindex+1,-1 do~<10>	self.nodes[i] = nil~<10>	end~<10>end~<10|10>function THTNode:INTReducetoNode( anode )~<10>local i = 0~<10>for i = #self.nodes,1,-1 do~<10>	if self.nodes[i] == anode then~<10>		return~<10>		else~<10>		self.nodes[i] = nil~<10>		end~<10>	end~<10>end~<10>-- Public~<10|10>function THTNode:Insert( aindex, anode)~<10>local i = 0~<10>if aindex ~<62> #self.nodes+1 then ~<10>	return~<10>	end~<10>for i = #self.nodes+1,aindex+1,-1 do~<10>	self.nodes[i] = self.nodes[i-1]~<10>	end~<10>self.nodes[aindex] = anode~<10>anode.parent = self~<10>end~<10|10>function THTNode:Node(x)~<10>local i = 0~<10>local result = self~<10>for i = 1,#x do~<10>	if type(x[i]) == ~<34>number~<34> then~<10>		if (x[i] ~<62> 0) and (x[i] ~<60>= #self.nodes) then~<10>			result = result.nodes[x[i]]~<10>			else~<10>			result = nil~<10>			end~<10>		else~<10>		result = (result.FindAbout(x[i]))~<10>		end~<10>	if result == nil then~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>--[[###################]]~<10>--[[  Find functtions  ]]~<10>--[[###################]]~<10|10|10>function THTNode:FindNode( anode )~<10>local i = 0~<10>local result = -1~<10>for i = 1,#self.nodes do~<10>	if self.nodes[i] == anode then~<10>		result = i~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAbout( astring )~<10>local i = 0~<10>local result = nil~<10>astring = self:CaseFunc(astring)~<10>for i = 1,#self.nodes do~<10>	if self:CaseFunc(self.nodes[i].about) == astring then~<10>		result = self.nodes[i]~<10>		return result~<10>		end~<10>	result = self.nodes[i]:FindAbout(astring)~<10>	if result then~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAboutCi( astring )~<10>local i = 1~<10>local result = -1~<10>astring = self:CaseFunc(astring)~<10>for i = 1,#self.nodes do~<10>	if self:CaseFunc(self.nodes[i].about) == astring then~<10>		result = i~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAboutC( astring )~<10>local i = self:FindAboutCi( astring )~<10>local result = nil~<10>if i ~<62> 0 then~<10>	result = self.nodes[i]~<10>	return result~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAboutN( astring )~<10>local i = 0~<10>local result = nil~<10>astring = self:CaseFunc(astring)~<10>for i = #self.nodes,1,-1 do~<10>	if self:CaseFunc(self.nodes[i].about) == astring then~<10>		result = self.nodes[i]~<10>		return result~<10>		end~<10>	result = self.nodes[i]:FindAboutN(astring)~<10>	if result then~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAboutNC( astring )~<10>local i = self:FindAboutNCi( astring )~<10>local result = nil~<10>if i ~<62> 0 then~<10>	result = self.nodes[i]~<10>	end~<10>return result~<10>end~<10|10>function THTNode:FindAboutNCi( astring )~<10>local i = 1~<10>local result = -1~<10>astring = self:CaseFunc(astring)~<10>for i = #self.nodes,1,-1 do~<10>	if self:CaseFunc(self.nodes[i].about) == astring then~<10>		result = i~<10>		return result ~<10>		end~<10>	end~<10>return result ~<10>end~<10|10>function THTNode:FindVar( SVar )~<10>local i = 1~<10>local i2 = 1~<10>local result = nil~<10>for i = 1,#self.nodes do~<10>	for i2 = 1,#self.Values do~<10>		if self.Values == SVar then~<10>			result = self.nodes[i]~<10>			return result ~<10>			end~<10>		end~<10>	result = self.nodes[i]:FindVar( SVar )~<10>	if result then ~<10>		return result~<10>		end~<10>	end~<10>return result~<10>end~<10|10>function THTNode:SetSValues_Check( acardinal ,writemode )   ~<10>local i = 0~<10>local result = acardinal ~<62> 0~<10>if (acardinal ~<62> #self.Values) and (readmode) then~<10>	i = #self.Values+1~<10>	for i = i,acardinal-1 do~<10>		print(i)~<10>		self.Values[i] = ~<34|34|10>		end~<10>	end~<10>return result~<10>end~<10>	~<10>function THTNode:SValues( acardinal , aValue )~<10>local result = (aValue or nil)~<10>local writemode = aValue ~<126>= nil~<10>if self:SetSValues_Check(acardinal, writemode) then ~<10>	if writemode then ~<10>		self.Values[acardinal] = result~<10>		else~<10>		result = self.Values[acardinal]~<10>		end~<10>	else~<10>	result = ~<34|34|10>	end~<10>return result~<10>end~<10|10>function THTNode:SValuesS( acardinal , aValue )~<10>local result = tostring(aValue or ~<34|34>)~<10>local writemode = (aValue ~<126>= nil)~<10>if self:SetSValues_Check(acardinal, writemode) then ~<10>	if writemode then ~<10>		self.Values[acardinal] = result~<10>		else~<10>		result = tostring(self.Values[acardinal]) or ~<34|34|10>		end~<10>	else~<10>	result = ~<34|34|10>	end~<10>return result~<10>end~<10|10>function THTNode:SValuesI( acardinal , aValue )~<10>local result = tonumber(aValue or 0)~<10>local writemode = aValue ~<126>= nil~<10>if self:SetSValues_Check(acardinal, writemode) then ~<10>	if writemode then ~<10>		self.Values[acardinal] = result~<10>		else~<10>		result = tonumber(self.Values[acardinal]) or 0~<10>		end~<10>	else~<10>	result = 0~<10>	end~<10>return result~<10>end~<10|10>function THTNode:SValuesB( acardinal , aValue )~<10>local result = toboolean(aValue or 0)~<10>local writemode = aValue ~<126>= nil~<10>if self:SetSValues_Check(acardinal, writemode) then ~<10>	if writemode then ~<10>		self.Values[acardinal] = result~<10>		else~<10>		result = toboolean(self.Values[acardinal] or 0)~<10>		end~<10>	else~<10>	result = false~<10>	end~<10>return result~<10>end~<10>	~<10>function THTNode:CaseFunc( astr )~<10>local result = ~<34|34|10>if self.CaseSensitive then result = astr~<10>	else result = string.lower(astr) end~<10>return result~<10>end~<10|10>function THTNode:CutOutChars( astring , IntFunc )~<10>local i = 1~<10>local i2 = 1~<10>local von = 1~<10>local result = ~<34|34|10>local achar = ~<34|34|10>local offen = false~<10|10>for i = 1,string.len(astring) do~<10>	achar = string.char(string.byte(astring,i))~<10>	if (self.CutOutfunc and self:CutOutfunc(achar)) or ((not self.CutOutfunc) and StCutOutFunc(self,achar)) then -- Irgendwie wird CurOutFunc ned gespeichert... deswegen umgehung :)~<10>		if von ~<60> i then~<10>			if offen then ~<10>				result = result .. self.vardec._End~<10>				end~<10>			result = result .. string.sub(astring,von,i-1)~<10>			offen = false~<10>			end~<10>		~<10>		if offen then~<10>			result = result .. self.vardec._Array .. string.byte(achar)~<10>			else~<10>			result = result .. self.vardec._System .. self.vardec._Begin .. string.byte(achar)~<10>			end~<10>			~<10>		offen = true~<10>		von = i +1~<10>		i2 = i2 + 1~<10>		if IntFunc and ((i2 % 10000) == 0) then ~<10>			IntFunc(self)~<10>			end~<10>		end~<10>	end~<10>if offen then ~<10>	result = result .. self.vardec._End~<10>	end~<10>result = result .. string.sub(astring,von)~<10>return result~<10>end~<10|10>function THTNode:ToStr( mode , IntFunc )~<10>local i = 1~<10>local atext = ~<34|34|10>local result = ~<34|34|10>local lmode = vec3.Copy(mode or stToStrMode)~<10|10>if IntFunc then ~<10>	IntFunc(self)~<10>	end~<10|10>if lmode[~<34>tsWriteMetaInfo~<34>] then~<10>	result = HTVardectoStr(self.vardec,stvardec())~<10>	end~<10>	~<10>result = result .. self:CutOutChars(self.about , IntFunc  ) .. self.vardec._Begin~<10>if lmode[~<34>tsWriteTypecast~<34>] then~<10>	result = result .. self.vardec._System .. ~<34>t~<34> .. self.vardec._Begin .. ~<34>true~<34> .. self.vardec._End ~<10>	end~<10>if lmode[~<34>tsUseTypecast~<34>] and (#self.Values ~<62> 0) then~<10>	result = result .. tostring(GetArt(self.Values[1])) .. self.vardec._Array~<10>	end~<10>for i = 1,#self.Values do~<10>	atext = self:SValuesS(i)~<10>	if lmode[~<34>tsUseInsert~<34>] and (string.len(atext) ~<62> 20) then~<10>		atext = self.vardec._System .. 'i' .. self.vardec._Begin .. tostring(string.len(atext)) .. self.vardec._End .. atext~<10>		else~<10>		atext = self:CutOutChars(atext , IntFunc )~<10>		end~<10>	~<10>	if (i == #self.Values) and (#self.nodes == 0) and (string.len(atext) ~<62> 0) then ~<10>		result = result .. atext~<10>		else~<10>		result = result .. atext .. self.vardec._Array~<10>		end~<10>	end~<10>lmode[~<34>tsWriteMetaInfo~<34>] = false~<10>lmode[~<34>tsWriteTypecast~<34>] = false~<10>for i = 1,#self.nodes do~<10>	result = result .. self.nodes[i]:ToStr(lmode, IntFunc)~<10>	end~<10>result = result .. self.vardec._End	~<10>return result~<10>end~<10|10>function THTNode:FromStr( astring , vardec ,IntFunc )~<10>local a,b,c = HTStrtoNode(astring, self, vardec ,IntFunc)~<10>self = a~<10>return b,c~<10>end~<10|10>function THTNode:LoadfromFile( path , vardec )~<10>local b,c = self:FromStr(FileToString(path), vardec)~<10>return b,c~<10>end~<10|10>function THTNode:SavetoFile( path, mode )~<10>local a = self:ToStr( mode )~<10>StringToFile(path , a)~<10>end~<10|10|10>function HTStrtoNode(astring,resultNODE,vardec,IntFunc) -- resultNode - result (TEHTFStatus) - i;~<10>local deep = 0~<10>local sysdeep = 0~<10>local atext = ~<34|34|10>local systext = ~<34|34|10>local charpuffer = ~<34|34|10>local obj = {nil}~<10>local i = 1~<10>local instsys = false~<10>local curtypecast = -1~<10>local typecast = false~<10>local systypecast = false~<10>local syscurtypecast = 0~<10>local sysnode = nil~<10>local newnode = nil~<10>local p,o = nil~<10>local rp = ~<34>EHTFnone~<34|10>local result = ~<34>EHTFerror~<34|10>local lastsystemsymbol = -1~<10|10>function d(b)~<10>if b or (b == nil) then ~<10>	deep = deep + 1~<10>	else~<10>	deep = deep -1~<10>	end~<10>result = (deep ~<62> 0)~<10>return result~<10>end~<10|10>function Insert_Value()~<10>if deep ~<62>= 1 then~<10>	if typecast then~<10>		if (#obj[deep].Values == 0) and (curtypecast == -1) then~<10>			curtypecast = tonumber(atext or 0) or 0~<10>			else~<10>			obj[deep]:AddValue(HTStrtoSVar(atext,curtypecast))~<10>			end~<10>		else~<10>		obj[deep]:AddValue(HTStrtoSVar(atext,-1)) -- he should guesses~<10>		end~<10>	atext = ~<34|34|10>	end~<10>end~<10|10>function InterpretSystemNode(anode)~<10>local result = ~<34>EHTFNone~<34|10>local i2 = 0~<10>local astrpuffer = string.lower(anode.about)~<10|10>if (astrpuffer == ~<34|34>) then~<10>	for i2 = 1,#anode.Values do~<10>		atext = atext.. string.char(anode:SValuesI(i2))~<10>		end~<10>	elseif (astrpuffer == ~<34>_b~<34>) then~<10>		vardec._Begin = string.char(anode:SValuesI(1) or 0)~<10>		elseif (astrpuffer == ~<34>_e~<34>) then~<10>			vardec._End = string.char(anode:SValuesI(1) or 0)~<10>			elseif (astrpuffer == ~<34>_a~<34>) then~<10>				vardec._Array = string.char(anode:SValuesI(1) or 0)~<10>				elseif (astrpuffer == ~<34>_s~<34>) then~<10>					vardec._System = string.char(anode:SValuesI(1) or 0)~<10>					elseif (astrpuffer == ~<34>t~<34>) then~<10>						typecast = anode:SValuesB(1)~<10>						elseif (astrpuffer == ~<34>il~<34>) then~<10>							if (anode:SValuesI(1)+anode:SValuesI(2)-1) ~<62> string.len(astring) then~<10>								result = ~<34>EHTFincorrectString~<34|10>								return result~<10>								end~<10>							atext = atext .. string.sub(astring,anode:SValuesI(1),anode:SValuesI(1)+anode:SValuesI(2))~<10>							elseif (astrpuffer == ~<34>i~<34>) then~<10>								if (i+anode:SValuesI(1)) ~<62> string.len(astring) then~<10>									result = ~<34>EHTFincorrectString~<34|10>									return result~<10>									end~<10>								atext = atext .. string.sub(astring,i+1,i+anode:SValuesI(1))~<10>								i = i + anode:SValuesI(1)~<10>								elseif (astrpuffer == ~<34>g~<34>) then ~<10>									i = anode:SValuesI(1)~<10>									elseif (astrpuffer == ~<34>e~<34>) then ~<10>										result = ~<34>EHTFexit~<34|10>										return result~<10>										end	~<10|10|10>for i2 = 1,#anode.nodes do~<10>	InterpretSystemNode(anode.nodes[i2])					~<10>	end~<10>return result~<10>end~<10|10>if vardec == nil then~<10>	vardec = stvardec()~<10>	end~<10|10>while i ~<60>= string.len(astring) do~<10>	charpuffer = string.char(string.byte(astring,i))~<10>	if charpuffer == vardec._Begin then --[[ BEGIN ]]  ~<10>		if not d() then~<10>			result = ~<34>EHTFincorrectString~<34|10>			return resultNODE , result , i~<10>			end~<10>		newnode = THTNode()~<10>		newnode.vardec = vardec~<10>		obj[deep] = newnode~<10>		if string.len(atext) ~<62> 0 then ~<10>			newnode.about = atext~<10>			end~<10>	~<10>		if (lastsystemsymbol ~<62> 0) then~<10>			instsys = true --[[ SYSTEM ]]~<10>			end~<10>		~<10>		if instsys and (sysnode == nil) then~<10>			--newnode.about = vardec._System~<10>			newnode.about = string.sub(astring,lastsystemsymbol+1,i-1)~<10>			systypecast = typecast~<10>			syscurtypecast = curtypecast~<10>			typecast = false~<10>			sysnode = newnode~<10>			sysdeep = deep~<10>			--systext = string.sub(atext,1,#atext-1)~<10>			systext = string.sub(atext,1,#atext-(i-lastsystemsymbol)+1)~<10>			else~<10>			if deep ~<62> 1 then~<10>				obj[deep-1]:Add(newnode)~<10>				else~<10>				if resultNODE then~<10>					resultNODE:Assign(obj[1]) -- neuer node~<10>					obj[1] = nil~<10>					obj[1] = resultNODE~<10>					else~<10>					resultNODE = obj[1]~<10>					end~<10>				end~<10>			end~<10>		~<10>		curtypecast = -1~<10>		atext = ~<34|34|10>		else~<10>		if charpuffer == vardec._End then --[ END ]]~<10>			if string.len(atext) ~<62> 0 then ~<10>				Insert_Value()~<10>				end~<10>			if (not d(false)) and (i ~<126>= string.len(astring)) then~<10>				result = ~<34>EHTFdonePart~<34> -- Der node ist offiziel vorbei, hier komtm aber noch was dahinter. evt nen zweiter , andere Node !~<10>				return resultNODE , result , i~<10>				end~<10>			curtypecast = -1~<10>			if IntFunc then~<10>				rp = IntFunc(obj[deep],instsys)~<10>				if rp ~<126>= EHTFnone then~<10>					return rp~<10>					end~<10>				end~<10>			if instsys and (deep ~<60> sysdeep) then~<10>				sysdeep = 0~<10>				instsys = false~<10>				atext = atext .. systext -- systext ist das was vot dem systemaufruf da stand~<10>				typecast = systypecast~<10>				curtypecast = syscurtypecast~<10>				rp = InterpretSystemNode(sysnode)~<10>				if rp ~<126>= ~<34>EHTFNone~<34> then~<10>					result = rp~<10>					return resultNODE , result , i~<10>					end~<10>				sysnode = nil~<10>				lastsystemsymbol = -1~<10>				end~<10>			else~<10>			if charpuffer == vardec._Array then ~<10>				Insert_Value() --[[ Array ]]~<10>				else~<10>				if charpuffer == vardec._System then~<10>					lastsystemsymbol = i ~<10>					else~<10>					atext = atext .. charpuffer --[[ Normal ]]~<10>					end~<10>				end~<10>			end~<10>		end~<10>	i = i + 1~<10>	end~<10>if deep ~<60> 1 then ~<10>	result = ~<34>EHTFdone~<34|10>	else~<10>	result = ~<34>EHTFincorrectString~<34> --  Hier fehlt was. Der String bricht ab bevor alles geschlossen werden kann !~<10>	end~<10>	~<10>return resultNODE , result , i~<10>end~<10|10|10|10>--[[~<10>OWN STUFF !!!!~<10|10>Auto Eddet~<10>local dest = ~<34>/~<34|10>local myData = ~<34|34|10>]]~<10|10>local lastsleep = os.time()~<10|10>local function aSleepFunc()~<10>if lastsleep + 1 ~<60> os.clock() then~<10>		lastsleep = os.clock()~<10>		sleep(0.01)~<10>		end~<10>end~<10|10>write(~<34>read data~<34>)~<10>local Data = THTNode()~<10>Data:FromStr(myData,stvardec(),aSleepFunc)~<10>print(~<34> ... done~<34>)~<10|10>local function LoadData(adata,apath)~<10>local i,obj = 1,nil~<10>local p,o,p2,p3 = nil,nil,nil~<10>local ap,bp = ~<34|34|10>local aname = ~<34|34|10>local afile = ~<34|34|10>local filedata = ~<34|34|10>p = adata:FindAboutC(~<34>name~<34>)~<10>if p then ~<10>	aname = p:SValuesS(1)~<10>	ap = RPath(apath,aname)~<10>	if not fs.exists(ap) then~<10>		print(ap)~<10>		fs.makeDir(ap)~<10>		end~<10>	end~<10>o = adata:FindAboutC(~<34>sub~<34>)~<10>for i,obj in ipairs(o.nodes) do~<10>	if obj.about == ~<34>folder~<34> then~<10>		sleep(0.001)~<10>		LoadData(obj,ap)~<10>		else~<10>		p2 = obj:FindAboutC(~<34>name~<34>)~<10>		if p2 then~<10>			afile = p2:SValuesS(1)~<10>			bp = RPath(ap,afile)~<10>			p3 = obj:FindAboutC(~<34>data~<34>)~<10>			if p3 then~<10>				filedata = p3:SValuesS(1)~<10>				sleep(0.001)~<10>				StringToFile(bp,filedata)~<10>				end~<10>			end~<10>		end~<10>	end~<10>end~<10|10>--Data:LoadfromFile(~<34>/Hello.ehtf~<34>)~<10|10>write(~<34>extract data~<34>)~<10>LoadData(Data:FindAboutC(~<34>folder~<34>),dest)~<10>print(~<34> ... done~<34>)~<10|10>>>>>>>folder<0||name<0|drivers>path<0|marcelOS/drivers>sub<0||file<0||name<0|driver_01windowconverter>path<0|marcelOS/drivers/driver_01windowconverter>data<0|local lastTouch = 0~<10>local lastPosX = 0~<10>local lastPosY = 0~<10|10>function Driver_Meta_Version()~<10>return ~<34>0.1~<34|10>end~<10|10>function Driver_Event( _event ) -- is called if an Event is fired~<10>local i,obj = 0~<10>local ok = -1~<10>local t = 0~<10>local px,py = 0,0~<10>local posx,posy = 0,0~<10>local n = 0~<10>local ap,ab = nil,false~<10>local obj2 = nil~<10>local new = nil~<10|10>function Process(_x,_y,_mousekey,monitor,monP) -- Only~<10>local new = nil~<10>local mouse_event = nil~<10>if ((lastTouch + 1) ~<62> os.clock()) and (lastPosX == _x) and (lastPosY == _y) then~<10>		-- DoubleClick~<10>		new = events.CreateEvent(~<34>mouse_doubleClick~<34>,~<34>driver_windowconverter~<34>,_mousekey,_x,_y,monP)~<10>		mTask.RawRaiseEvent(new)~<10>		else~<10>		if (monitor) and ((lastTouch + 0.6) ~<62> os.clock()) then -- Drag only on Monitor !!!~<10>			local adiff =  math.pow(_x-lastPosX,2)+math.pow(_y-lastPosY,2)~<10>			if adiff ~<60> 100 then -- 10^2 = 100~<10>				-- Drag!~<10>				new = events.CreateEvent(~<34>drag~<34>,~<34>driver_windowconverter~<34>,lastPosX,lastPosY,_x,_y,_mousekey,monP)~<10>				mTask.RawRaiseEvent(new)~<10>				end~<10>			end ~<10>		end~<10|10>	~<10>mouse_event = events.CreateEvent(~<34>mouse~<34>,~<34>driver_windowconverter~<34>,_mousekey,_x,_y,monP)~<10>mTask.RawRaiseEvent(mouse_event)~<10|10>n = windows.GetWindowatPos(mouse_event.params[2],mouse_event.params[3],monP)~<10>if #n ~<62> 0 then~<10>	obj = n[#n] ~<10>	if obj.task then~<10>	    posx = mouse_event.params[2]-obj.left~<10>		posy = mouse_event.params[3]-obj.top~<10>	    new = events.CreateEvent(~<34>mouse_click~<34>,~<34>driver_windowconverter~<34>,_mousekey,posx,posy,obj,monP)~<10>		mTask.RaiseHandleEvent(obj.task,new)~<10>		end~<10>	end~<10|10>lastTouch = os.clock()~<10>lastPosX = _x~<10>lastPosY = _y~<10>end~<10|10>-- internal 1.4.6 Touchscreen~<10>if (_event.name == ~<34>monitor_touch~<34>) then~<10>	new = events.CreateEventCopy(_event,~<34>monitor_touch_system~<34>,~<34>driver_windowconverter~<34>)~<10>	mTask.RawRaiseEvent(new)~<10|10>	for i,obj in ipairs(mView.main.mon) do~<10>		if obj.m:conToSide(_event.params[1]) then~<10>			ok = i~<10>			end~<10>		end~<10>		~<10>	if ok ~<62> -1 then~<10>		obj = mView.main.mon[ok]~<10>		posx,posy = obj:LocaltoGlobal(_event.params[2] ,_event.params[3] )~<10>		Process(posx,posy,1,true,mView.main)~<10>		end~<10>	~<10>	_event.enabled = false~<10>	end	~<10>if (_event.name == ~<34>mouse_click~<34>) then~<10>	new = events.CreateEventCopy(_event,~<34>mouse_click_system~<34>,~<34>driver_windowconverter~<34>)~<10>	mTask.RawRaiseEvent(new)~<10>	~<10>	i,ok = mView.main:HasPeripheral(mperipheral.TermPeripheral)~<10>	if ok ~<62> -1 then~<10>		obj = mView.main.mon[ok]~<10>		posx,posy = obj:LocaltoGlobal(_event.params[2] ,_event.params[3])~<10>		else~<10>		posx = _event.params[2]~<10>		posy = _event.params[3]~<10>		end~<10>	if not i then~<10>	    ap = mView.second~<10>		else~<10>		ap = mView.main~<10>		end~<10>	Process(posx,posy,_event.params[1],false,ap)~<10>	~<10>	_event.enabled = false	~<10>	end	~<10>if (_event.name == ~<34>key~<34>) then ~<10>	new = events.CreateEventCopy(_event,~<34>key_system~<34>,~<34>driver_windowconverter~<34>)~<10>	mTask.RawRaiseEvent(new)~<10>	~<10>	obj = windows.GetActive()~<10>	if obj and obj.task then~<10>		new = events.CreateEvent(~<34>key~<34>,~<34>driver_windowconverter~<34>,_event.params[1],obj)~<10>		mTask.RaiseHandleEvent(obj.task,new)~<10>		end~<10>	_event.enabled = false	~<10>	end~<10>if (_event.name == ~<34>char~<34>) then ~<10>    new = events.CreateEventCopy(_event,~<34>char_system~<34>,~<34>driver_windowconverter~<34>)~<10>	mTask.RawRaiseEvent(new)~<10>	~<10>	obj = windows.GetActive()~<10>	if obj and obj.task then~<10>		new = events.CreateEvent(~<34>char~<34>,~<34>driver_windowconverter~<34>,_event.params[1],obj)~<10>		mTask.RaiseHandleEvent(obj.task,new)~<10>		end~<10>	_event.enabled = false	~<10>	end~<10>if (_event.name == ~<34>mouse_drag~<34>) then~<10>	new = events.CreateEventCopy(_event,~<34>mouse_drag_window~<34>,~<34>driver_windowconverter~<34>)~<10>	mTask.RawRaiseEvent(new)~<10|10>	i,ok = mView.main:HasPeripheral(mperipheral.TermPeripheral)~<10>	if ok ~<62> -1 then~<10>		obj = mView.main.mon[ok]~<10>		posx,posy = obj:LocaltoGlobal(_event.params[2] ,_event.params[3])~<10>		ap = mView.main~<10>		else~<10>		posx = _event.params[2]~<10>		posy = _event.params[3]	~<10>		ap = mView.second~<10>		end~<10>	new = events.CreateEvent(~<34>drag~<34>,~<34>driver_windowconverter~<34>,lastPosX,lastPosY,posx,posy,_event.params[1],ap)~<10>	mTask.RawRaiseEvent(new)~<10>	lastTouch = os.clock()~<10>	lastPosX = posx~<10>	lastPosY = posy~<10>	~<10>	_event.enabled = false	~<10>	end	~<10>if (_event.name == ~<34>drag~<34>) then~<10>	obj = windows.GetActive()~<10>	if obj and obj.task then~<10>		new = events.CreateEventCopy(_event,~<34>mouse_drag~<34>)~<10>		new.params[#new.params] = obj~<10>		mTask.RaiseHandleEvent(obj.task,new)~<10>		end~<10>	end~<10>end~<10|10>function Driver_Initial()~<10>end>>file<0||name<0|driver_IP>path<0|marcelOS/drivers/driver_IP>data<0|local function Detect()~<10>local i,obj = 0~<10>for i,obj in ipairs(driver.driver_sides) do~<10>	if peripheral.getType( obj ) == ~<34>modem~<34> then~<10>	   rednet.open(obj)~<10>	   end~<10>	end~<10>end~<10|10>function Driver_Meta_Version()~<10>return ~<34>0.1~<34|10>end~<10|10>function Driver_Initial()~<10>Detect()~<10>end~<10|10>function Driver_Event( _event ) -- is called if an Event is fired~<10>local _ClientIP , _ServerIP, _meta , _port, _msg, _result = nil~<10>local new = nil~<10>local s,s2,s3 = nil,nil,-1~<10|10>if (_event.name == ~<34>MPeripheral~<34>) and (_event.params[2].type == ~<34>modem~<34>) then~<10>	if (_event.params[1] == ~<34>add~<34>) then~<10>		--_event.params[2].p.open(ip.UsedChannel)~<10>		rednet.open(_event.params[2].side)~<10>		end -- Close nicht machbar, weil es dann sowieso schon zu spät ist.~<10>	end~<10|10>if _event.name == ~<34>rednet_message~<34> then~<10>	--print(_event:instring())	ok = ip.Legal(_event.params[1])~<10>	_ClientIP , _ServerIP , _port, _meta , _msg, _result = ip.GetMessage(_event.params[2])~<10>	s,s2,s3 = ip.OwnIP:GetDHCP_C(_event.params[1])~<10>	if s2 then~<10>		s2.entf = _event.params[3]~<10>		s2.lastping = os.clock()	~<10>		end~<10>	if _result then		~<10>		if ip.DHCPMessage(_ClientIP , _ServerIP ,p1,_port , _meta , _msg, _event.params[3]) then -- internes weiterleiten~<10>			new = events.CreateEvent(~<34>DHCP~<34>,~<34>driver_IP~<34>, _event.params[1], _ClientIP , _ServerIP ,_port )  -- für ~<34>3G Watchdog~<34|10>			else~<10>			new = events.CreateEvent(~<34>internet~<34>,~<34>driver_IP~<34>, _event.params[1], _ClientIP , _ServerIP ,_port, _meta , _msg , p3 , ok)~<10>			end~<10>		mTask.RawRaiseEvent(new)~<10>		end~<10>	_event.enabled = false~<10>	_event = nil -- Destroy Event !!!~<10>	end~<10>end>>file<0||name<0|driver_mView>path<0|marcelOS/drivers/driver_mView>data<0|function Driver_Meta_Version()~<10>return ~<34>0.1~<34|10>end~<10|10>function Driver_Initial()~<10>end~<10|10>function Driver_Event( _event ) -- is called if an Event is fired~<10>local newe = nil~<10>local done = ~<34|34|10>local n = 0~<10>local x = 0~<10>local mon = 0~<10>local obj = 0~<10>local new = nil~<10>if (_event.name == ~<34>MPeripheral~<34>) and (_event.params[2].type == ~<34>monitor~<34>) then~<10>	if (_event.params[1] == ~<34>add~<34>) then~<10>		mView.main:mPeripheralAdd( _event.params[2] )~<10>		done = ~<34>add~<34|10>		else~<10>		mView.main:mPeripheralDel( _event.params[2] )~<10>		done = ~<34>del~<34|10>		end~<10>	mView.main:Change()~<10>	mView.main:PreRender()~<10>	mView.main:clear()~<10>	print(~<34>MAIN MONITOR Configured~<34>)~<10>	mView.main:Flush()~<10>	newe = events.CreateEvent(~<34>MonChanged~<34>,~<34>driver_mView~<34>, done, _event.params[2] , _event.params[2].p)~<10>	mTask.RawRaiseEvent(newe)~<10>	end~<10>end>>file<0||name<0|driver_peripheral>path<0|marcelOS/drivers/driver_peripheral>data<0|local function DetectAdd()~<10>local i,obj = 0~<10>local i2,obj2 = 0~<10>local p_sides = {~<34>back~<34>,~<34>top~<34>,~<34>left~<34>,~<34>bottom~<34>,~<34>right~<34>,~<34>front~<34>}~<10>local new,newe = 0~<10>local m = -1~<10>for i,obj in ipairs(p_sides) do~<10>	if peripheral.getType( obj ) then~<10>	   m = -1~<10>	   for i2,obj2 in ipairs(mperipheral.Peripherals) do	~<10>			if obj2:conToSide(obj) then~<10>				m = i2~<10>				end~<10>			end~<10>	   if (m == -1) then~<10>		  new = mperipheral.CreatePeripheral()		~<10>		  new.p = peripheral.wrap(obj)~<10>		  new.side = obj~<10>		  new.type = peripheral.getType(obj) ~<10>		  new.owner = ~<34>driver_peripheral~<34|10>		  ~<10>		  newe = events.CreateEvent(~<34>MPeripheral~<34>,~<34>driver_peripheral~<34>, ~<34>add~<34>, new , new.p)~<10>		  mTask.RawRaiseEvent(newe)~<10>		  end~<10>	   end~<10>	end~<10>end~<10|10>local function DetectDel()~<10>local i,obj = 0~<10>local i2,obj2 = 1,nil~<10>local p_sides = {~<34>back~<34>,~<34>top~<34>,~<34>left~<34>,~<34>bottom~<34>,~<34>right~<34>,~<34>front~<34>}~<10>local new,newe = 0~<10>local con = false~<10>local x = 0~<10>while i2 ~<60>= #mperipheral.Peripherals do~<10>	obj2 = mperipheral.Peripherals[i2]~<10>	con = true~<10>	if (obj2.owner == ~<34>driver_peripheral~<34>) then -- kümmer mich nur um meine ;)~<10>		con = false~<10>		for i,obj in ipairs(p_sides) do~<10>			if obj2:conToSide(obj) and (peripheral.wrap(obj) ~<126>= nil) then ~<10>				con = true~<10>				break~<10>				end~<10>			end~<10>		end~<10>	if (not con) then~<10>		newe = events.CreateEvent(~<34>MPeripheral~<34>,~<34>driver_peripheral~<34>, ~<34>del~<34>, obj2 , obj2.p)~<10>		mTask.RawRaiseEvent(newe)~<10>		x = #mperipheral.Peripherals~<10>		mperipheral.Peripherals[i2] = mperipheral.Peripherals[x]~<10>		mperipheral.Peripherals[x] = nil~<10>		else~<10>		i2 = i2 + 1~<10>		end~<10>	end~<10>end~<10|10>function Driver_Meta_Version()~<10>return ~<34>0.1~<34|10>end~<10|10>function Driver_Event( _event ) -- is called if an Event is fired~<10>if (_event.name == ~<34>peripheral~<34>) then~<10>print(~<34>ShouldADD~<34>)~<10>	DetectAdd()~<10>	end~<10>if (_event.name == ~<34>peripheral_detach~<34>) then~<10>print(~<34>ShouldDEL~<34>)~<10>	DetectDel()~<10>	end~<10>end~<10|10>function Driver_Initial()~<10>DetectAdd()~<10>mView.main:CheckTerm()~<10>end>>file<0||name<0|driver_peripheralcable>path<0|marcelOS/drivers/driver_peripheralcable>data<0|function Driver_Meta_Version()~<10>return ~<34>0.1~<34|10>end~<10|10>function Driver_Initial()~<10>end~<10|10>function Driver_Event( _event ) -- is called if an Event is fired~<10>local newe = nil~<10>local done = ~<34|34|10>if (_event.name == ~<34>MPeripheral~<34>) and (_event.params[2].type == ~<34>cable~<34>) then~<10>	if (_event.params[1] == ~<34>add~<34>) then~<10>		done = ~<34>add~<34|10|10>		local sides = { _event.params[2].p.list() }~<10>		for i,obj in ipairs(sides) do ~<10>			new = mperipheral.CreatePeripheral()		~<10>			new.p = peripheral.wrap(obj)~<10>			new.side = obj~<10>			new.type = peripheral.getType(obj) ~<10>			new.owner = ~<34>driver_peripheralcable~<34|10>		  ~<10>			newe = events.CreateEvent(~<34>MPeripheral~<34>,~<34>driver_peripheralcable~<34>, ~<34>add~<34>, new , new.p)~<10>			mTask.RawRaiseEvent(newe)~<10>			end~<10|10>		else~<10>		done = ~<34>del~<34|10>		end~<10>	end~<10>	~<10>end>>file<0||name<0|driver_turtle>path<0|marcelOS/drivers/driver_turtle>data<0|function Driver_Meta_Version()~<10>return ~<34>0.1~<34|10>end~<10|10>function Driver_Event( _event ) -- is called if an Event is fired~<10>if (_event.name == ~<34>turtle~<34>) then~<10>	if _event.params[1] == ~<34>forward~<34> then~<10>		mgps.forward()~<10>	elseif _event.params[1] == ~<34>back~<34> then~<10>		mgps.back()~<10>	elseif _event.params[1] == ~<34>turnRight~<34> then~<10>		mgps.turnRight()~<10>	elseif _event.params[1] == ~<34>turnLeft~<34> then~<10>		mgps.turnLeft()~<10>	elseif _event.params[1] == ~<34>up~<34> then~<10>		mgps.up()~<10>	elseif _event.params[1] == ~<34>down~<34> then~<10>		mgps.down()~<10>	elseif _event.params[1] == ~<34>refuel~<34> then~<10>		turtle.refuel(_event.params[2])~<10>		end~<10>	end~<10>end~<10|10>function Driver_Initial()~<10>end>>file<0||name<0|driver_windows>path<0|marcelOS/drivers/driver_windows>data<0|local lastTouch = 0~<10>local lastPosX = 0~<10>local lastPosY = 0~<10|10>function Driver_Meta_Version()~<10>return ~<34>0.1~<34|10>end~<10|10>function secondFlush()~<10>mView.second:Flush()~<10>end~<10|10>function Driver_Event( _event ) -- is called if an Event is fired~<10>local i,obj = 0~<10>local ok = -1~<10>local t = 0~<10>local px,py = 0,0~<10>local posx,posy = 0,0~<10>local n = 0~<10>local ap,ab = nil,false~<10>local obj2 = nil~<10|10>-- internal 1.4.6 Touchscreen~<10>if (_event.name == ~<34>monitor_touch_system~<34>) then~<10>	-- Gib ein Touch Befehl mit globalen Koordinaten an.~<10>	-- Und ein speziellen Touch Befehl nur für das Fenster ...~<10>	for i,obj in ipairs(mView.main.mon) do~<10>		if obj.m:conToSide(_event.params[1]) then~<10>			ok = i~<10>			end~<10>		end~<10>		~<10>	for i = 1,windows.GetWindowCount() do~<10>		t = windows.GetWindow(i)~<10>		if t:ChangeMonitor(mView.main,true) then~<10>			obj2 = t~<10>			end~<10>		end~<10>	~<10>	pcall(secondFlush) -- to clear the screen!~<10>		~<10>	if ok ~<62> -1 then~<10>		obj = mView.main.mon[ok]~<10>		posx,posy = obj:LocaltoGlobal(_event.params[2] ,_event.params[3] )~<10>		if obj2 then ~<10>			obj2.left = posx - math.floor(obj2.width / 2)~<10>			obj2.top = posy - math.floor(obj2.height / 2)~<10>			if obj2.left ~<60> 1 then obj2.left = 1 end~<10>			if obj2.top ~<60> 1 then obj2.top = 1 end~<10>			end~<10>		end~<10>	end	~<10>if (_event.name == ~<34>mouse_click_system~<34>) then~<10>	-- Gib ein Touch Befehl mit globalen Koordinaten an.~<10>	-- Und ein speziellen Touch Befehl nur für das Fenster ...~<10>	i,ok = mView.main:HasPeripheral(mperipheral.TermPeripheral)~<10>	~<10>	if not i then -- if term is no part of main!~<10>		-- Put Active Window in second monitor~<10>		obj = windows.GetActive()~<10>		for i = 1,windows.GetWindowCount() do~<10>			t = windows.GetWindow(i)~<10>			if t == obj then~<10>			    ab = t:ChangeMonitor(mView.second,true)~<10>				else~<10>				t:ChangeMonitor(mView.main,true)~<10>				end~<10>			end~<10>		if obj and ab then ~<10>			obj:FullScreen(true)~<10>			end~<10>		else~<10>		for i = 1,windows.GetWindowCount() do~<10>			t = windows.GetWindow(i)~<10>			t.Monitor = mView.main~<10>			end~<10>		end~<10>	windows.Invalidate()~<10>	end	~<10>if (_event.name == ~<34>key_system~<34>) then ~<10>	mon = windows.GetActive()~<10>	if (_event.params[1] == 199) or (_event.params[1] == 157) then		~<10>		windows.ChangeWindow(true)~<10>		x = windows.GetActive()~<10>		if x then~<10>			x.selobj = nil~<10>			end~<10>		end~<10>	if (mon ~<126>= nil) and (mon:Selected(true)) then~<10>		if (_event.params[1] == 62) and (mon.task) then~<10>			mon.task:Stop()~<10>			else~<10>			if (mon.Monitor ~<126>= mView.second) then ~<10>				mon:PressKey( _event.params[1])~<10>				end~<10>			end~<10>		end~<10>		~<10>	windows.Invalidate()~<10>	end~<10>if (_event.name == ~<34>mouse~<34>) then ~<10>	n = windows.GetWindowatPos(_event.params[2],_event.params[3])~<10>	if #n ~<62> 0 then~<10>		obj = n[#n] ~<10>		if (_event.params[2] == obj.left+obj.width) and (_event.params[3] == obj.top) then~<10>			local n2 = windows.WindowsofTask(obj.task)~<10>			windows.DestroyWindow(obj)~<10>			if (n2 == 1) then~<10>			   obj.task:Stop() ~<10>			   end~<10>			elseif (_event.params[2] == obj.left+obj.width-2) and (_event.params[3] == obj.top) then~<10>				obj:FullScreen(true)~<10>				else~<10>				windows.SetActive(obj)~<10>				windows.uptop(obj)~<10>				end~<10>		end~<10>	end~<10>	~<10>local function WThrowEvent(name,_obj)~<10>if _obj.task then~<10>	local new = events.CreateEvent(name,~<34>driver_windows~<34>,_obj)~<10>	mTask.RaiseHandleEvent(_obj.task,new)~<10>	end~<10>end~<10|10>if (_event.name == ~<34>drag~<34>) and (_event.params[6] ~<126>= mView.second) then~<10>	n = windows.GetWindowatPos(_event.params[1],_event.params[2],nil,_event.params[6] or mView.main) -- von~<10>	if #n ~<62> 0 then~<10>		local rx,ry = 0~<10>		obj = n[#n] ~<10>		rx = _event.params[3] - _event.params[1]~<10>		ry = _event.params[4] - _event.params[2]~<10>		-- move~<10>		if (_event.params[2] == obj.top) then~<10>			obj:move(rx,ry)~<10>			WThrowEvent(~<34>window_move~<34>,obj)~<10>			elseif (_event.params[1] == obj.left) and (obj.width - rx ~<62> 5) then -- resize left~<10>				obj:move(rx,0)~<10>				obj.width = obj.width - rx~<10>				WThrowEvent(~<34>window_resize~<34>,obj)~<10>				elseif (_event.params[1] == obj:right()) and (obj.width + rx ~<62> 5) then -- resize right~<10>					obj.width = obj.width + rx~<10>					WThrowEvent(~<34>window_resize~<34>,obj)~<10>					elseif (_event.params[2] == obj:bottom()) and (obj.height + ry ~<62> 5) then -- resize right~<10>						obj.height = obj.height + ry~<10>						WThrowEvent(~<34>window_resize~<34>,obj)~<10>						end~<10>		~<10>		end~<10>	end~<10>end~<10|10>function Driver_Initial()~<10>end>>>>folder<0||name<0|programs>path<0|marcelOS/programs>sub<0||file<0||name<0|cmd>path<0|marcelOS/programs/cmd>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>1~<124>0.1~<62>changePrint~<60>2~<124>true~<62>eventfilter~<60>0~<124>key~<124>window_resize~<124>window_fullscreen~<62>EventManager~<60>3~<124>true~<62|62>code~<60>0~<124|126>i~<60>36~<62>print(~<34>Hello, i run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>2~<124>0.1~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>Application.window  =  windows.CreateWindow( Application.name , Application , true) ~<10>Application.window:SetSize(26,12)~<10|10>local Edit1 = winobj.TEdit(~<34>Edit1~<34>,Application.window,Application.window)~<10>Edit1.width = 25~<10>Edit1.top = 1~<10>Edit1.left = 1~<10>Application.window:RegisterEvents(Application) ~<10|10>local History = vec3.TList(2)~<10>local Hindex = 1~<10>History[1] = ~<34|34> -- current~<10|10>function getEvent(_event)~<10>if ((_event.name == ~<34>window_resize~<34>) or (_event.name == ~<34>window_fullscreen~<34>)) then~<10>	Edit1.width = Application.window.width~<10>	end~<10>if (_event.name == ~<34>key~<34>) then~<10>	local _p = 0~<10>	if (_event.params[1] == 200) or (_event.params[1] == 208) then~<10>		if Hindex == 1 then~<10>			History[1] = Edit1.text.text~<10>			end~<10>		if (_event.params[1] == 200) then~<10>			_p , Hindex = History:Inc(Hindex)~<10>			else~<10>			_p , Hindex = History:Dec(Hindex)~<10>			end~<10>		Edit1.text:SetText(History[Hindex])~<10>	elseif (_event.params[1] == 28) then~<10>			Hindex = 1~<10>			local s = Edit1.text.text~<10>			Edit1.text:SetText(~<34|34>)~<10>			History:Insert(s,2)~<10>			Application.window.l:clear()~<10>			Application.window.l.CursorY = 4~<10>			~<10>			local nForcePrint = 0~<10>			local func, e = loadstring( s, ~<34>lua~<34> )~<10>			local func2, e2 = loadstring( ~<34>return ~<34>..s, ~<34>lua~<34> )~<10>			~<10>			if func2 then~<10>				if not func then~<10>					e = nil~<10>					nForcePrint = 1~<10>					end~<10>				func = func2	~<10>				end~<10>			~<10>			if func then~<10>				local tResults = { pcall(func) }~<10>				if tResults[1] then~<10>					local n = 1~<10>					while (tResults[n + 1] ~<126>= nil) or (n ~<60>= ta) do~<10>						local as = tostring( tResults[n + 1] )~<10>						 Application.window:print( as )~<10>						n = n + 1~<10>						end~<10>					else~<10>					Application.window:print( tResults[2] )~<10>					end~<10>				else~<10>				Application.window:print( e )~<10>				end~<10>			end~<10>	end~<10>end~<10|10|10>Application.window:print( ~<34>Interactive CMD prompt.~<34>)~<10>while true do~<10>	mTask.sleepEvent(Application,2)~<10>	EventHandle()~<10>	Application.window:Paint()~<10>	end>>folder<0||name<0|dll>path<0|marcelOS/programs/dll>sub<0||file<0||name<0|info.txt>path<0|marcelOS/programs/dll/info.txt>data<0|dll's are like programs, but they dont have a while true loop, they are more like windows cmd programs.~<10>Start them with the right Arguments :)>>file<0||name<0|mprojectmeta>path<0|marcelOS/programs/dll/mprojectmeta>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>1~<124>0.1~<62>changePrint~<60>2~<124>false~<62>eventfilter~<60>http_success~<124>http_failure~<62>EventManager~<60>3~<124>false~<62>Debug~<60>3~<124>true~<62|62>code~<60>0~<124|126>i~<60>36~<62>print(~<34>Hello, i run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>2~<124>0.1~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>Application.useevents = true~<10>local tArgs = {...}~<10>-- Args 1: Data in EHTF~<10>-- Args: mode (create / install)~<10>-- Args: source~<10>-- Args: dest -optional if install~<10>-- NEEDED if create:~<10>-- Args: version~<10>-- Args: includesha1~<10>-- Args: name~<10|10>-- Args 2: Output EHTF~<10>-- Args: info~<10|10|10>local conf = ehtf.THTNode()~<10>local output = tArgs[2]~<10>local p = nil~<10>local mode = ~<34|34|10>local configstring = ~<34|34|10>local version = ~<34|34|10>local includesha1 = false~<10>local name = ~<34|34|10>local onDone = nil~<10|10>if type(tArgs[1]) == ~<34>table~<34> then~<10>	conf = tArgs[1]~<10>	else~<10>	conf:FromStr(tArgs[1])~<10>	end~<10>local source = ~<34>/~<34|10>local dest = nil~<10|10>p = conf:FindAboutC(~<34>mode~<34>)~<10>if p then~<10>	mode = p:SValuesS(1)~<10>	end	~<10>p = conf:FindAboutC(~<34>source~<34>)~<10>if p then~<10>	source = p:SValuesS(1)~<10>	end	~<10>p = conf:FindAboutC(~<34>configstring~<34>)~<10>if p then~<10>	configstring = p:SValuesS(1)~<10>	end	~<10>p = conf:FindAboutC(~<34>onDone~<34>)~<10>if p then~<10>	onDone = p:SValues(1)~<10>	end~<10>p = conf:FindAboutC(~<34>dest~<34>)~<10>if p then~<10>	dest = p:SValuesS(1)~<10>	end~<10>p = conf:FindAboutC(~<34>version~<34>)~<10>if p then~<10>	version = p:SValuesS(1)~<10>	end	~<10>p = conf:FindAboutC(~<34>includesha1~<34>)~<10>if p then~<10>	includesha1 = p:SValuesB(1)~<10>	end	~<10>p = conf:FindAboutC(~<34>name~<34>)~<10>if p then~<10>	name = p:SValuesS(1)~<10>	end~<10>	~<10>	~<10>local function GetData(source)~<10>Debug(source)~<10>if source:sub(1,7) == ~<34>http://~<34> then~<10>	http.request(source)~<10>	Debug(~<34>http~<34>,~<34>get~<34>)~<10>	local e,p1,p2 = Application:WaitForEvent()~<10>	while ((e ~<126>= ~<34>http_success~<34>) and (e ~<126>= ~<34>http_failure~<34>)) or (p1 ~<126>= source) do~<10>		local e,p1,p2 = Application:WaitForEvent()~<10>		end~<10>	if e == ~<34>http_success~<34> then~<10>		local s = p2.readAll()~<10>		p2.close()~<10>		return s~<10>		end~<10>	else~<10>	Debug(~<34>local~<34>,~<34>get~<34>)~<10>	return ehtfutils.FileToString(source)~<10>	end~<10>Debug(~<34>ERROR~<34>)~<10>return ~<34|34|10>end~<10|10>local function ExtractData(adata,adest,asource)~<10>local i,obj = 1,nil~<10>local p,o,p2,p3,p4 = nil,nil,nil,nil~<10>local ap = ~<34|34|10>local apath = ~<34|34|10>local afile = ~<34|34|10>local filedata = ~<34|34|10>local _filedata~<10>local needupdate = true~<10|10>p = adata:FindAboutC(~<34>path~<34>)~<10>if p then ~<10>	apath = p:SValuesS(1)~<10>	fs.makeDir(path.C(adest,apath))~<10>	end~<10>o = adata:FindAboutC(~<34>sub~<34>)~<10>	~<10>for i,obj in ipairs(o.nodes) do~<10>	if obj.about == ~<34>folder~<34> then~<10>		ExtractData(obj,adest,asource)~<10>		else~<10>		p2 = obj:FindAboutC(~<34>data~<34>)~<10>		if p2 then~<10>			afile = path.C(asource,p2:SValuesS(1)) ~<10>			p3 = obj:FindAboutC(~<34>path~<34>)~<10>			if p3 then~<10>				apath = path.C(adest,p3:SValuesS(1))~<10>				needupdate = true~<10>				p4 = obj:FindAboutC(~<34>sha1~<34>)~<10>				if p4 then~<10>					_filedata = ehtfutils.FileToString(apath) or ~<34|34|10>					needupdate = (md5.md5(_filedata) ~<126>= p4:SValuesS(1))~<10>					end~<10>				if needupdate then~<10>				    Debug(apath) ~<10>					filedata = GetData(afile)~<10>					~<10>					ehtfutils.StringToFile(apath,filedata)~<10>					end~<10>				end~<10>			end~<10>		end~<10>	end~<10>end~<10|10>local function LoadData(anode,mainpath,pretopath,topath,apath,aname,dosha1) --mainpath = SOURCE PATH dont get changed , pretoPath = for Saving, not implemented ! , toPath : Dest Path dont get changed , apath = local PATH --~<62> get changed !!! ~<10>local i,obj = 1,nil~<10>local lmainpath = path.C(mainpath,apath)~<10>local ltopath = path.C(topath,apath)~<10>local gtopath = path.C(pretopath,topath,apath)~<10>fs.makeDir(gtopath)~<10>if apath == '' then~<10>	local lmainpath = mainpath~<10>	local ltopath = topath~<10>	end~<10>local tData = fs.list( lmainpath )~<10>local p,o,p2 = nil,nil,nil~<10>local ap = ~<34|34|10>local amainp = ~<34|34|10>local atop = ~<34|34|10|10>p = anode:Add(~<34>folder~<34>,~<34|34>)~<10>p:Add(~<34>name~<34>,aname)~<10>p:Add(~<34>path~<34>,apath)~<10>o = p:Add(~<34>sub~<34>,~<34|34>)~<10>for i,obj in ipairs(tData) do~<10>	ap = path.C(apath,obj)~<10>	amainp =  path.C(lmainpath,obj)~<10>	atop =  path.C(ltopath,obj)~<10>	atop2 =  path.C(gtopath,obj)~<10>	if fs.isDir(amainp) then~<10>		if (amainp ~<126>= ~<34>/rom~<34>) then -- we dont load rom !~<10>			LoadData(o,  mainpath ,pretopath, topath ,   ap  ,obj , dosha1)~<10>			sleep(0.01)~<10>			end~<10>		else~<10>		p2 = o:Add(~<34>file~<34>,~<34|34>)~<10>		p2:Add(~<34>name~<34>,obj)~<10>		p2:Add(~<34>path~<34>,ap)~<10>		~<10>		local _data = ehtfutils.FileToString(amainp)~<10>		ehtfutils.StringToFile(atop2,_data)~<10>		p2:Add(~<34>data~<34>, atop)~<10>		if dosha1 then~<10>			p2:Add(~<34>sha1~<34>, md5.md5(_data))~<10>			end~<10>		end~<10>	end~<10>end~<10|10|10>if mode == ~<34>create~<34> then~<10>	Debug(~<34>create~<34>)~<10>	~<10>	if name == ~<34|34> then~<10>		name = source~<10>		end~<10>	local meta = ehtf.THTNode()~<10>	local p = nil~<10|10>	meta:Add(~<34>about~<34>,~<34>Softwareupdate~<34>)~<10>	meta:Add(~<34>name~<34>,name)~<10>	meta:Add(~<34>path~<34>,source)~<10>	meta:Add(~<34>ver~<34>,version)~<10>	meta:Add(~<34>sha1~<34>,includesha1)~<10>	p = meta:Add(~<34>data~<34>,~<34|34>)~<10|10|10>	fs.makeDir(dest)~<10>	LoadData(p,source,dest,'data','','',includesha1)~<10|10>	meta:SavetoFile(path.FOLDER(dest) .. ~<34>config.ehtf~<34>)~<10>	~<10>	if onDone then~<10>		onDone(mode,source,name)~<10>		end~<10>	Debug(~<34>Done~<34>)~<10>	else~<10>	Debug(~<34>install~<34>)~<10|10>	local Data = ehtf.THTNode()~<10>	if configstring ~<126>= ~<34|34> then~<10>		local configstring = GetData(path.C(source,~<34>config.ehtf~<34>))~<10>		Debug(configstring)~<10>		else~<10>		Debug(~<34>Config available~<34>)~<10>		end~<10>		~<10>	Data:FromStr(configstring)~<10>	Debug(~<34>Loaded Data: ~<34> .. configstring)~<10>	if not dest then~<10>		dest = Data:FindAboutC(~<34>path~<34>)~<10>		dest = dest:SValuesS(1)~<10>		end~<10>	if not fs.exists(dest) then~<10>		fs.makeDir(dest)~<10>		end~<10>	ExtractData(Data:FindAboutC(~<34>data~<34>):FindAboutC(~<34>folder~<34>),dest,source)~<10>	if onDone then~<10>		onDone(mode,source,name)~<10>		end~<10>	Debug(~<34>Done~<34>)~<10>	end>>file<0||name<0|mzip>path<0|marcelOS/programs/dll/mzip>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>1~<124>0.1~<62>changePrint~<60>2~<124>false~<62>IdleCount~<60>1~<124>100~<62>EventManager~<60>3~<124>false~<62>Debug~<60>3~<124>true~<62|62>code~<60>0~<124|126>i~<60>36~<62>print(~<34>Hello, i run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>2~<124>0.1~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>-- Can Compress / extract a Directory in a single string~<10>local tArgs = {...}~<10>-- Args 1: Data in EHTF~<10>-- Args: mode (compress / extract)~<10>-- Args: source~<10>-- Args: dest~<10>-- Args: includerom~<10>-- Args: oneLine~<10|10>-- Args 2: Output EHTF~<10>-- Args: data~<10>local conf = ehtf.THTNode()~<10>local output = tArgs[2]~<10>local p = nil~<10>if type(tArgs[1]) == ~<34>table~<34> then~<10>	conf = tArgs[1]~<10>	else~<10>	conf:FromStr(tArgs[1])~<10>	end~<10>local source = ~<34>/~<34|10>local dest = ~<34>/compressed.mzip~<34|10>local mode = ~<34|34|10>local includerom = false~<10>local oneLine = false~<10|10>p = conf:FindAboutC(~<34>mode~<34>)~<10>if p then~<10>	mode = p:SValuesS(1)~<10>	end~<10>p = conf:FindAboutC(~<34>source~<34>)~<10>if p then~<10>	source = p:SValuesS(1)~<10>	end	~<10>p = conf:FindAboutC(~<34>dest~<34>)~<10>if p then~<10>	dest = p:SValuesS(1)~<10>	end~<10>p = conf:FindAboutC(~<34>includerom~<34>)~<10>if p then~<10>	includerom = p:SValuesB(1)~<10>	end~<10>p = conf:FindAboutC(~<34>oneLine~<34>)~<10>if p then~<10>	oneLine = p:SValuesB(1)~<10>	end	~<10|10>local Data = ehtf.THTNode()~<10|10>function AlternativeCutOut(Sender , achar , bchar)  local abyte = string.byte(achar)  local result = ((achar == Sender.vardec._Begin)~<10>		or (achar == Sender.vardec._End) ~<10>		or (achar == Sender.vardec._Array) ~<10>		or (achar == Sender.vardec._System) ~<10>		or (abyte == 34) -- ~<34|10>		or (abyte == 0)~<10>		or (abyte == 10)~<10>		or (abyte == 13)~<10>		or (abyte == 92) -- ~<92|10>		)  return result  end~<10|10>if oneLine then~<10>	Data.CutOutfunc = AlternativeCutOut~<10>	end~<10|10>local function LoadData(adata,apath,aname)~<10>local i,obj = 1,nil~<10>local tData = fs.list( apath )~<10>local p,o,p2 = nil,nil,nil~<10>local ap = ~<34|34|10|10>p = adata:Add(~<34>folder~<34>,~<34|34>)~<10>p:Add(~<34>name~<34>,aname)~<10>p:Add(~<34>path~<34>,apath)~<10>o = p:Add(~<34>sub~<34>,~<34|34>)~<10>for i,obj in ipairs(tData) do~<10>	ap = path.C(apath,obj)~<10>	if fs.isDir(ap) then~<10>		if includerom or (ap ~<126>= ~<34>/rom~<34>) then -- we dont load rom !~<10>			LoadData(o,  ap  ,obj)~<10>			end~<10>		else~<10>		p2 = o:Add(~<34>file~<34>,~<34|34>)~<10>		p2:Add(~<34>name~<34>,obj)~<10>		p2:Add(~<34>path~<34>,ap)~<10>		p2:Add(~<34>data~<34>, ehtfutils.FileToString(ap))~<10>		end~<10>	end~<10>end~<10|10>function aSleepFunc()~<10>sleep(0.0001)~<10>end~<10|10|10|10>local function ExtractData(adata,apath)~<10>local i,obj = 1,nil~<10>local p,o,p2,p3 = nil,nil,nil~<10>local ap,bp = ~<34|34|10>local aname = ~<34|34|10>local afile = ~<34|34|10>local filedata = ~<34|34|10>p = adata:FindAboutC(~<34>name~<34>)~<10>if p then ~<10>	aname = p:SValuesS(1)~<10>	ap = path.C(apath,aname)~<10>	fs.makeDir(ap)~<10>	end~<10>o = adata:FindAboutC(~<34>sub~<34>)~<10>	~<10>for i,obj in ipairs(o.nodes) do~<10>	if obj.about == ~<34>folder~<34> then~<10>		ExtractData(obj,ap)~<10>		else~<10>		p2 = obj:FindAboutC(~<34>name~<34>)~<10>		if p2 then~<10>			afile = p2:SValuesS(1)~<10>			bp = path.C(ap,afile)~<10>			p3 = obj:FindAboutC(~<34>data~<34>)~<10>			if p3 then~<10>				filedata = p3:SValuesS(1)~<10>				ehtfutils.StringToFile(bp,filedata)~<10>				end~<10>			end~<10>		end~<10>	end~<10>end~<10|10>if mode == ~<34>compress~<34> then~<10>	Debug(~<34>compressing~<34>)~<10>	LoadData(Data,source,source)~<10>	local lmode = vec3.Copy(ehtfutils.stToStrMode)~<10>	lmode[~<34>tsUseInsert~<34>] = false~<10>	Debug(~<34>done1~<34>)~<10>	if output then~<10>		if output:FindAboutC(~<34>string~<34>) then~<10>			output:Add(~<34>data~<34>,Data:ToStr(lmode,aSleepFunc))~<10>			else~<10>			local p = output:Add(~<34>data~<34>,~<34|34>)~<10>			p:Add(Data)~<10>			end~<10>		else~<10>		Debug(~<34>k~<34>)~<10>		Data:SavetoFile(dest,lmode)~<10>		Debug(~<34>SAVED to ~<34> .. dest)~<10>		end~<10|10>	end~<10>if mode == ~<34>extract~<34> then~<10>	Debug(~<34>extracting~<34>)~<10>	if not fs.exists(dest) then~<10>		fs.makeDir(dest)~<10>		end~<10>		~<10>	Data:LoadfromFile(source)~<10>	ExtractData(Data:FindAboutC(~<34>folder~<34>),dest)~<10>	Debug(~<34>Done~<34>)~<10|10>	end~<10>	>>>>file<0||name<0|mview-settings>path<0|marcelOS/programs/mview-settings>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>1~<124>0.1~<62>changePrint~<60>2~<124>false~<62>IdleCount~<60>1~<124>1~<62>EventManager~<60>3~<124>false~<62|62>code~<60>0~<124|126>i~<60>36~<62>print(~<34>Hello, i run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>2~<124>0.1~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>Application.useevents = true~<10>Application.window:SetSize(30,23)~<10>Application.window:FindSpace(111)~<10>local Data = ehtf.THTNode()~<10|10>local MultiLabel1 = winobj.TMultiLabel(~<34>MultiLabel1~<34>,Application.window,Application.window)~<10>MultiLabel1.top = 2~<10>MultiLabel1.left = 2~<10>MultiLabel1.width = 20~<10>MultiLabel1.height = 5~<10>MultiLabel1.data:write(~<34>source xD~<34>) ~<10|10>local function DoStart()~<10>local conf = ehtf.THTNode()~<10>local mode = ~<34|34|10>local source = Edit1.text.text~<10>local dest = Edit2.text.text~<10>local includerom = Checkbox2.checked~<10>local oneLine = Checkbox3.checked or Checkbox4.checked or Checkbox5.checked~<10>local output = ehtf.THTNode()~<10>local p = nil~<10>local timeout = 20~<10>local acount = 0~<10>local extractpath = Edit3.text.text~<10|10>if Checkbox1.checked then ~<10>	mode = ~<34>extract~<34|10>   else ~<10>	mode = ~<34>compress~<34|10>	end~<10|10>conf:Add(~<34>mode~<34>,mode)~<10>conf:Add(~<34>source~<34>,source)~<10>conf:Add(~<34>dest~<34>,dest)~<10>conf:Add(~<34>includerom~<34>,includerom)~<10>conf:Add(~<34>oneLine~<34>,oneLine)~<10|10>local co = mTask.CreateTask( ~<34>zip~<34> )~<10>co.file = path.C( path.PROGRAMS() , ~<34>mzip~<34> )~<10>co.args:Add(conf)~<10>if Checkbox4.checked or Checkbox5.checked then~<10>	output:Add(~<34>string~<34>)~<10>	co.args:Add(output)~<10>	end~<10>co:run()~<10|10>if Checkbox4.checked or Checkbox5.checked then~<10>	~<10>	p = output:FindAboutC(~<34>data~<34>)~<10>	while not p do~<10>		sleep(1)~<10>		print(~<34>waiting...~<34>)~<10>		acount = acount + 1~<10>		if acount ~<62>= timeout then~<10>			print(~<34>ERROR mzip timed out~<34>)~<10>			break~<10>			end~<10>		p = output:FindAboutC(~<34>data~<34>)~<10>		end~<10|10>	print(~<34>create file~<34>)~<10>	local template = ehtfutils.Bin2FileToString(path.C(path.DATA(),~<34>createstartdisk/selfextract_template~<34>))~<10>	if Checkbox5.checked then~<10>		local template2 = ehtfutils.Bin2FileToString(path.C(path.DATA(),~<34>createstartdisk/install_template~<34>))~<10>		local template3 = ehtfutils.Bin2FileToString(path.C(path.DATA(),~<34>createstartdisk/installfinished_template~<34>))~<10>		template = template2 .. ~<34> local dest = ~<92|34>/~<92|34>  local myData = ~<92|34|34> .. p:SValuesS(1) .. ~<34|92|34>  ~<34> .. template .. ~<34>  ~<34> .. template3~<10>		else~<10>		if extractpath == ~<34|34> then~<10>			template = ~<34>print(~<92|34>enter extraction path~<92|34>) local dest = read()  local myData = ~<92|34|34> .. p:SValuesS(1) .. ~<34|92|34>  ~<34> .. template ~<10>			else~<10>			template = ~<34>local dest = ~<92|34|34> .. extractpath .. ~<34|92|34>  local myData = ~<92|34|34> .. p:SValuesS(1) .. ~<34|92|34>  ~<34> .. template~<10>			end~<10>		end~<10>	ehtfutils.StringToFile(dest,template)	~<10>	--print(template)~<10>	end~<10|10|10>end~<10|10|10>local Button1 = winobj.TButton(~<34>Button1~<34>,Application.window,Application.window)~<10>Button1.width = 15~<10>Button1.top = 17~<10>Button1.left = 10~<10>Button1.border = true~<10>Button1.checked = true~<10>Button1.caption = ~<34>Start~<34|10>Button1.onClick = DoStart~<10|10>local function getEvent(_event)~<10>Application.window:Event(_event)~<10>end~<10|10>local function EventHandle()~<10>local i,obj = 0,nil~<10>for i, obj in ipairs(Application.events) do~<10>	getEvent(obj)~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>while true do~<10>	EventHandle()~<10>	Application.window.l:clear()~<10>	Application.window:Paint()~<10>	sleep(0.1)~<10>	end>>folder<0||name<0|programs-dll>path<0|marcelOS/programs/programs-dll>sub<0||file<0||name<0|avi>path<0|marcelOS/programs/programs-dll/avi>data<0||>>file<0||name<0|execute>path<0|marcelOS/programs/programs-dll/execute>data<0|local Arg = {...}~<10|10>local co = mTask.CreateTask( Application.name )~<10>co.file = Arg[1]~<10>local i,obj = 1,nil~<10>for i = 2,#Arg do~<10>	co.args:Add(Arg[i])~<10>	end~<10>co:run()>>file<0||name<0|lnk>path<0|marcelOS/programs/programs-dll/lnk>data<0||>>>>file<0||name<0|Project_create>path<0|marcelOS/programs/Project_create>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>1~<124>0.1~<62>changePrint~<60>2~<124>false~<62>eventfilter~<60|62>EventManager~<60>3~<124>false~<62|62>code~<60>0~<124|126>i~<60>36~<62>print(~<34>Hello, i run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>2~<124>0.1~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>Application.window  =  windows.CreateWindow( Application.name , Application , true) ~<10>Application.window:SetSize(30,17)~<10>Application.window:FindSpace()~<10>local Data = ehtf.THTNode()~<10|10>local Label1 = winobj.TLabel(~<34>Label1~<34>,Application.window,Application.window)~<10>Label1.width = 6~<10>Label1.top = 2~<10>Label1.left = 2~<10>Label1.caption = ~<34>source~<34|10|10>local Edit1 = winobj.TEdit(~<34>Edit1~<34>,Application.window,Application.window)~<10>Edit1.width = 15~<10>Edit1.top = 2~<10>Edit1.left = 10~<10>Edit1.border = false~<10>Edit1.text.text = ~<34>/~<34|10|10>local Label2 = winobj.TLabel(~<34>Label2~<34>,Application.window,Application.window)~<10>Label2.width = 6~<10>Label2.top = 4~<10>Label2.left = 2~<10>Label2.caption = ~<34>dest~<34|10|10>local Edit2 = winobj.TEdit(~<34>Edit2~<34>,Application.window,Application.window)~<10>Edit2.width = 15~<10>Edit2.top = 4~<10>Edit2.left = 10~<10>Edit2.border = false~<10>Edit2.text.text = ~<34>/newProject~<34|10|10>local Label3 = winobj.TLabel(~<34>Label3~<34>,Application.window,Application.window)~<10>Label3.width = 6~<10>Label3.top = 6~<10>Label3.left = 2~<10>Label3.caption = ~<34>ver.~<34|10|10>local Edit3 = winobj.TEdit(~<34>Edit3~<34>,Application.window,Application.window)~<10>Edit3.width = 15~<10>Edit3.top = 6~<10>Edit3.left = 10~<10>Edit3.border = false~<10>Edit3.text.text = ~<34>0.0.1~<34|10|10>local Label4 = winobj.TLabel(~<34>Label4~<34>,Application.window,Application.window)~<10>Label4.width = 6~<10>Label4.top = 8~<10>Label4.left = 2~<10>Label4.caption = ~<34>name~<34|10|10>local Edit4 = winobj.TEdit(~<34>Edit4~<34>,Application.window,Application.window)~<10>Edit4.width = 15~<10>Edit4.top = 8~<10>Edit4.left = 10~<10>Edit4.border = false~<10>Edit4.text.text = ~<34|34|10|10|10>local Checkbox1 = winobj.TCheckbox(~<34>Checkbox1~<34>,Application.window,Application.window)~<10>Checkbox1.width = 15~<10>Checkbox1.top = 10~<10>Checkbox1.left = 10~<10>Checkbox1.border = false~<10>Checkbox1.checked = false~<10>Checkbox1.caption = ~<34>incl. SHA1~<34|10|10>Application.window:RegisterEvents(Application) ~<10|10>local function DoStart()~<10>local source = Edit1.text.text~<10>local dest = Edit2.text.text~<10>local version = Edit3.text.text~<10>local includesha1 = Checkbox1.checked~<10>local name = Edit4.text.text~<10>local conf = ehtf.THTNode()~<10|10>conf:Add(~<34>mode~<34>,~<34>create~<34>)~<10>conf:Add(~<34>name~<34>,name)~<10>conf:Add(~<34>source~<34>,source)~<10>if dest ~<126>= ~<34|34> then~<10>	conf:Add(~<34>dest~<34>,dest)~<10>	end~<10>conf:Add(~<34>version~<34>,version)~<10>conf:Add(~<34>includesha1~<34>,includesha1)~<10|10>local co = mTask.CreateTask( ~<34>mproject~<34> )~<10>co.file = path.C( path.PROGRAMS() , ~<34>dll~<34>, ~<34>mprojectmeta~<34> )~<10>co.args:Add(conf)~<10>co:run()~<10>end~<10|10>local function DoStart2()~<10>local source = Edit1.text.text~<10>local dest = Edit2.text.text~<10>local conf = ehtf.THTNode()~<10|10>conf:Add(~<34>mode~<34>,~<34>install~<34>)~<10>conf:Add(~<34>source~<34>,source)~<10>if dest ~<126>= ~<34|34> then~<10>	conf:Add(~<34>dest~<34>,dest)~<10>	end~<10|10>local co = mTask.CreateTask( ~<34>mproject~<34> )~<10>co.file = path.C( path.PROGRAMS() , ~<34>dll~<34>, ~<34>mprojectmeta~<34> )~<10>co.args:Add(conf)~<10>co:run()~<10>end~<10|10|10>local Button1 = winobj.TButton(~<34>Button1~<34>,Application.window,Application.window)~<10>Button1.width = 15~<10>Button1.top = 12~<10>Button1.left = 10~<10>Button1.border = true~<10>Button1.caption = ~<34>Create~<34|10>Button1.onClick = DoStart~<10|10>local Button2 = winobj.TButton(~<34>Button1~<34>,Application.window,Application.window)~<10>Button2.width = 15~<10>Button2.top = 16~<10>Button2.left = 10~<10>Button2.border = true~<10>Button2.caption = ~<34>Install~<34|10>Button2.onClick = DoStart2~<10|10>local function EventHandle()~<10>local i,obj = 0,nil~<10>for i, obj in ipairs(Application.events) do~<10>	Application.window:Event(obj)~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>while true do~<10>	EventHandle()~<10>	Application.window.l:clear()~<10>	Application.window:Paint()~<10>	mTask.sleepEvent(Application,6)~<10>	end>>file<0||name<0|SoftwareUpdater>path<0|marcelOS/programs/SoftwareUpdater>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>explorer~<62>version~<60>1~<124>0.2~<62>changePrint~<60>2~<124>false~<62>eventfilter~<60>0~<124>http_success~<124>mouse_click~<124>window_resize~<124>window_fullscreen~<62>Debug~<60>3~<124>true~<62>EventManager~<60>3~<124>true~<62|62>code~<60>0~<124>print(~<34>Hello, SoftwareUpdater run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>explorer~<62>version~<60>2~<124>0.2~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>Application.window = windows.CreateWindow( Application.name , Application , true)~<10>Application.window:SetSize(40,20)~<10>Application.window:FindSpace(111)~<10>local lookout = ~<34>http://marcelmaertens.ma.funpic.de/marcelOS/listprojects.php~<34|10>local basepath = ~<34>http://marcelmaertens.ma.funpic.de/marcelOS/Softwareupdate/~<34|10>local localpath = path.C(path.DATA(),~<34>SoftwareUpdater~<34>)~<10>local localdatapath = path.C(localpath,~<34>programs~<34>) ~<10>local projects = vec3.TList()~<10>local currentDownloads = 0~<10>local autoupdate = false~<10|10>local Listbox1 = winobj.TListbox(~<34>TListbox~<34>,Application.window,Application.window)~<10>Listbox1.left = 1~<10>Listbox1.top = 1~<10>Listbox1.width = Application.window.width-1~<10>Listbox1.height = 7~<10>Listbox1.border = true~<10>Listbox1:Resize()~<10|10>local Label1 = winobj.TLabel(~<34>TLabel~<34>,Application.window,Application.window)~<10>Label1.left = 1~<10>Label1.top = 9~<10>Label1.width = Application.window.width-1~<10>Label1.caption = ~<34>Description~<34|10|10>local Label2 = winobj.TLabel(~<34>TLabel~<34>,Application.window,Application.window)~<10>Label2.left = 1~<10>Label2.top = 10~<10>Label2.width = Application.window.width-1~<10>Label2.caption = ~<34>lastest ver:~<34|10|10>local Label3 = winobj.TLabel(~<34>TLabel~<34>,Application.window,Application.window)~<10>Label3.left = 1~<10>Label3.top = 11~<10>Label3.width = Application.window.width-1~<10>Label3.caption = ~<34>current ver:~<34|10|10>local Label4 = winobj.TLabel(~<34>TLabel~<34>,Application.window,Application.window)~<10>Label4.left = 1~<10>Label4.top = Application.window.height-1~<10>Label4.width = Application.window.width-1~<10>Label4.caption = ~<34>current Downloads: 0~<34|10|10>local Button1 = winobj.TButton(~<34>TButton~<34>,Application.window,Application.window)~<10>Button1.left = 2~<10>Button1.top = 13~<10>Button1.width = Application.window.width-2~<10>Button1.caption = ~<34>Download~<34|10|10|10|10>local TProject_SoftwareUpdater = classapi.class(nil,~<34>TProject_SoftwareUpdater~<34>)~<10|10>function TProject_SoftwareUpdater:__init(_name)~<10>	self.name = _name~<10>	self.path = path.C(basepath,self.name)~<10>	self.cpath = path.C(self.path,~<34>config.ehtf~<34>)~<10>	self.config = nil~<10>	self.configstr = nil~<10>	self.localproject = nil -- of same class, assigned in checkLocal~<10>	self.installed = nil~<10>	~<10>	self.projectname = ~<34|34|10>	self.version = ~<34|34|10>	self.description = ~<34|34|10>end~<10|10>function TProject_SoftwareUpdater:RequestConfig()~<10>self.cpath = path.C(self.path,~<34>config.ehtf~<34>)~<10>http.request(self.cpath)~<10>end~<10|10>function TProject_SoftwareUpdater:buildConfig(_config)~<10>self.configstr = _config.readAll()~<10>_config:close()~<10>self.config = ehtf.THTNode()~<10>self.config:FromStr(self.configstr)~<10>local p = nil~<10>p = self.config:FindAboutC(~<34>name~<34>)~<10>if p then self.projectname = p:SValuesS(1) end~<10>p = self.config:FindAboutC(~<34>ver~<34>)~<10>if p then self.version = p:SValuesS(1) end~<10>p = self.config:FindAboutC(~<34>description~<34>)~<10>if p then self.description = p:SValuesS(1) end~<10>Debug(~<34>m~<34>,self.configstr)~<10>end~<10|10>function TProject_SoftwareUpdater:checkLocal(_config)~<10>local s = path.C(localdatapath,self.name)~<10>self.installed = fs.exists(s)~<10>if self.installed then~<10>    local obj = TProject_SoftwareUpdater(self.name)~<10>	self.localproject = obj~<10>	obj.path = s~<10>	obj.cpath = path.C(obj.path,~<34>config.ehtf~<34>)~<10>	local f = fs.open(obj.cpath,~<34>r~<34>)~<10>	obj:buildConfig(f)~<10>	end~<10>end~<10|10|10>local function SelChanged(self,old)~<10>if Listbox1.selected == -1 then return end~<10>obj = projects[Listbox1.selected]~<10>Label1.caption = (obj.projectname or obj.name)~<10>if obj.version ~<126>= ~<34|34> then~<10>	Label2.caption = ~<34>lastest ver: ~<34> .. obj.version~<10>	else~<10>	Label2.caption = ~<34>lastest ver: NONE~<34|10>	end~<10>if obj.localproject then~<10>	Label3.caption = ~<34>current ver: ~<34> .. obj.localproject.version~<10>	else~<10>	Label3.caption = ~<34>current ver: NONE~<34|10>	end~<10>Label4.caption = ~<34>current Downloads: ~<34> .. tostring(currentDownloads)~<10>end~<10|10>local function OnInstalled()~<10>currentDownloads = currentDownloads - 1~<10>SelChanged()~<10>end~<10|10|10>function TProject_SoftwareUpdater:Install() ~<10>local conf = ehtf.THTNode()~<10>currentDownloads = currentDownloads + 1~<10>SelChanged()~<10|10>conf:Add(~<34>mode~<34>,~<34>install~<34>)~<10>conf:Add(~<34>source~<34>,self.path)~<10>conf:Add(~<34>configstring~<34>,self.configstr)~<10>conf:Add(~<34>onDone~<34>,OnInstalled)~<10|10>local co = mTask.CreateTask( ~<34>mproject~<34> )~<10>co.file = path.C( path.PROGRAMS() , ~<34>dll~<34>, ~<34>mprojectmeta~<34> )~<10>co.args:Add(conf)~<10>co:run()~<10>-- Save local Data~<10>local s = path.C(localdatapath,self.name)~<10>local s2 = path.C(s,~<34>config.ehtf~<34>)~<10>if not fs.exists(s) then ~<10>	fs.makeDir(s)~<10>	end~<10>ehtfutils.StringToFile(s2,self.configstr)~<10>end~<10|10>local function Button1Click(self)~<10>if Listbox1.selected == -1 then return end~<10>obj = projects[Listbox1.selected]~<10>obj:Install()~<10|10>end~<10|10>local function getProjects()~<10>http.request(lookout)~<10>end~<10|10>local function generateProjects(h)~<10>projects = vec3.TList()~<10>Listbox1.data = vec3.TList()~<10>local sLine = h.readLine()~<10>while sLine do~<10>  local obj = TProject_SoftwareUpdater(sLine)~<10>  projects:Add(obj)~<10>  Listbox1.data:Add(sLine)~<10>  obj:RequestConfig()~<10>  sLine = h.readLine() ~<10>  end~<10>end~<10|10>Button1.onClick = Button1Click~<10>Listbox1.onSelectionChange = SelChanged~<10>Application.window:RegisterEvents(Application)~<10|10>local function getEvent(_event)~<10>if (_event.name == ~<34>window_resize~<34>) or (_event.name == ~<34>window_fullscreen~<34>) then~<10>	Listbox1.width = Application.window.width - 2~<10>	Listbox1:Resize()~<10>	end~<10>if (_event.name == ~<34>http_success~<34>) then~<10>	if _event.params[1] == lookout then~<10>		generateProjects(_event.params[2])~<10>		end~<10>	local i,obj = 0~<10>	for i,obj in ipairs(projects) do~<10>		if obj.cpath == _event.params[1] then~<10>			obj:buildConfig(_event.params[2])~<10>			obj:checkLocal()~<10>			if autoupdate and obj.localproject and (obj.version ~<126>= obj.localproject.version) then~<10>				-- AutoUpdate!!!~<10>				obj:Install()~<10>				end~<10>			SelChanged()~<10>			end~<10>		end~<10>	end~<10>end~<10|10>local function EventHandle()~<10>local i,obj = 0,nil~<10>for i, obj in ipairs(Application.events) do~<10>	Application.window:Event(obj)~<10>	getEvent(obj)~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>aNode = ehtf.THTNode()~<10>aNode:LoadfromFile(path.C(localpath,~<34>settings.ehtf~<34>))~<10>autoupdate = aNode:Load(~<34>autoupdate~<34>,false)~<10|10>getProjects()~<10>while true do~<10>	EventHandle()~<10>	Application.window.l:clear()~<10>	Application.window:Paint()~<10>	mTask.sleepEvent(Application,6)~<10>	end>>file<0||name<0|ssh_Client>path<0|marcelOS/programs/ssh_Client>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>explorer~<62>version~<60>1~<124>0.2~<62>changePrint~<60>2~<124>false~<62>eventfilter~<60>0~<124>internet~<124>mouse_click~<124>window_resize~<124>window_fullscreen~<62>Debug~<60>3~<124>true~<62>EventManager~<60>3~<124>true~<62|62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>explorer~<62>version~<60>2~<124>0.2~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>Application.window = windows.CreateWindow( Application.name , Application , true)~<10>Application.window:SetSize(40,20)~<10>Application.window:FindSpace(111)~<10>local seed = ~<34|34|10>local sendCommand = false~<10|10>local Label1 = winobj.TLabel(~<34>Label1~<34>,Application.window,Application.window)~<10>Label1.width = 6~<10>Label1.top = 2~<10>Label1.left = 2~<10>Label1.caption = ~<34>ip~<34|10|10>local Edit1 = winobj.TEdit(~<34>Edit1~<34>,Application.window,Application.window)~<10>Edit1.width = 15~<10>Edit1.top = 2~<10>Edit1.left = 10~<10>Edit1.border = false~<10>Edit1.text.text = ~<34|34|10|10>local Label2 = winobj.TLabel(~<34>Label2~<34>,Application.window,Application.window)~<10>Label2.width = 6~<10>Label2.top = 4~<10>Label2.left = 2~<10>Label2.caption = ~<34>code~<34|10|10>local Edit2 = winobj.TEdit(~<34>Edit2~<34>,Application.window,Application.window)~<10>Edit2.width = 15~<10>Edit2.top = 4~<10>Edit2.left = 10~<10>Edit2.border = false~<10>Edit2.text.text = ~<34>print('TEST')~<34|10|10>local Label3 = winobj.TLabel(~<34>Label3~<34>,Application.window,Application.window)~<10>Label3.width = 6~<10>Label3.top = 6~<10>Label3.left = 2~<10>Label3.caption = ~<34>name~<34|10|10>local Edit3 = winobj.TEdit(~<34>Edit3~<34>,Application.window,Application.window)~<10>Edit3.width = 15~<10>Edit3.top = 6~<10>Edit3.left = 10~<10>Edit3.border = false~<10>Edit3.text.text = ~<34>root~<34|10|10>local Label4 = winobj.TLabel(~<34>Label4~<34>,Application.window,Application.window)~<10>Label4.width = 6~<10>Label4.top = 8~<10>Label4.left = 2~<10>Label4.caption = ~<34>password~<34|10|10>local Edit4 = winobj.TEdit(~<34>Edit4~<34>,Application.window,Application.window)~<10>Edit4.width = 15~<10>Edit4.top = 8~<10>Edit4.left = 10~<10>Edit4.border = false~<10>Edit4.text.text = ~<34|34|10|10>local Checkbox1 = winobj.TCheckbox(~<34>Checkbox1~<34>,Application.window,Application.window)~<10>Checkbox1.top = 10~<10>Checkbox1.left = 2~<10>Checkbox1.width = 10~<10>Checkbox1.border = false~<10>Checkbox1.caption = ~<34>su~<34|10|10>local Checkbox2 = winobj.TCheckbox(~<34>Checkbox1~<34>,Application.window,Application.window)~<10>Checkbox2.top = 10~<10>Checkbox2.left = 10~<10>Checkbox2.width = 10~<10>Checkbox2.border = false~<10>Checkbox2.caption = ~<34>cmd~<34|10>Checkbox2.checked = true~<10|10>local Button1 = winobj.TButton(~<34>TButton~<34>,Application.window,Application.window)~<10>Button1.left = 2~<10>Button1.top = 14~<10>Button1.width = Application.window.width-2~<10>Button1.caption = ~<34>Send~<34|10|10>local function Button1Click(self)~<10>aNode = ehtf.THTNode()~<10>aNode:Add(~<34>requestseed~<34>,true)~<10>aNode:Add(~<34>name~<34>,Edit3.text.text)~<10>sendCommand = true~<10>ip.SendMessage(nil, tonumber(Edit1.text.text), nil,22,nil, aNode:ToStr())~<10>end~<10|10>Button1.onClick = Button1Click~<10>Application.window:RegisterEvents(Application)~<10|10>local function getEvent(_event)~<10>if (_event.name == ~<34>internet~<34>) and (_event.params[4] == ~<34>22~<34>) then~<10>	aNode = ehtf.THTNode()~<10>	aNode:FromStr(_event.params[6])~<10>	local _seed = aNode:Load(~<34>seed~<34>,false)~<10>	if _seed then~<10>		Debug(~<34>sshC~<34>,~<34>recieved Seed: ~<34> .. _seed)~<10>		seed = _seed~<10>		if sendCommand then~<10>			aNode = ehtf.THTNode()~<10>			local _cmd = ~<34|34|10>			if Checkbox2.checked then~<10>				_cmd = ~<34>--mMultiOS ~<92>n --~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124|62>version~<60>1~<124>1~<62>changePrint~<60>2~<124>false~<62>Debug~<60>3~<124>true~<62|62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124|62>version~<60>2~<124>1~<62|62|62|62> ~<92>n ~<34> .. Edit2.text.text~<10>				else~<10>				_cmd = Edit2.text.text~<10>				end~<10>			aNode:Add(~<34>command~<34>,_cmd)~<10>			aNode:Add(~<34>hash~<34>,md5.md5(_cmd .. Edit4.text.text .. seed))~<10>			aNode:Add(~<34>name~<34>,Edit3.text.text)~<10>			if Checkbox1.caption then~<10>				aNode:Add('su',true)~<10>				end~<10>			ip.SendMessage(nil, tonumber(Edit1.text.text), nil,22,nil, aNode:ToStr())~<10>			Debug(~<34>sshC~<34>,~<34>Command sended~<34>)~<10>			sendCommand = false~<10>			end~<10>		end~<10>	end~<10>end~<10|10>local function EventHandle()~<10>local i,obj = 0,nil~<10>for i, obj in ipairs(Application.events) do~<10>	Application.window:Event(obj)~<10>	getEvent(obj)~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>while true do~<10>	EventHandle()~<10>	Application.window.l:clear()~<10>	Application.window:Paint()~<10>	mTask.sleepEvent(Application,6)~<10>	end>>file<0||name<0|ssh_service>path<0|marcelOS/programs/ssh_service>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>explorer~<62>version~<60>1~<124>0.2~<62>changePrint~<60>2~<124>false~<62>eventfilter~<60>0~<124>internet~<124>window_resize~<124>window_fullscreen~<62>EventManager~<60>3~<124>true~<62>Debug~<60>3~<124>true~<62|62>code~<60>0~<124>print(~<34>Hello, explorer run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>explorer~<62>version~<60>2~<124>0.2~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>-- This Program is a Server which will execute Programs send by an other Computer, if this PC has the right Password~<10|10>Application.window = windows.CreateWindow( Application.name , Application , true)~<10>Application.window:SetSize(25,6)~<10>Application.window:FindSpace(111)~<10|10>Application.window:RegisterEvents(Application)~<10|10>local Users = {}~<10>TSSHservice_User = classapi.class(nil,~<34>TSSHservice_User~<34>)~<10>function TSSHservice_User:__init(_name,_pw)~<10>	self.name = _name~<10>	self.su = false~<10>	self.pw = _pw or mStrings.UUID()~<10>end~<10|10>local Instances = {}~<10>TSSHservice_Instance = classapi.class(nil,~<34>TSSHservice_Instance~<34>)~<10>function TSSHservice_Instance:__init(_user,_connected)~<10>	self.user = _user~<10>	self.seed = nil~<10>	self.connected = _connected~<10>end~<10|10>function TSSHservice_Instance:sendSeed()~<10>self.seed = mStrings.UUID()~<10>--self.seed = tostring(os.clock()) .. mStrings.UUID() .. tostring(os.time())~<10>local aNode = ehtf.THTNode()~<10>aNode:Add('seed',self.seed)~<10>ip.SendMessage(nil, self.connected, nil,22,nil, aNode:ToStr())~<10>Application.window:print(~<34>seed Sended ~<34> .. tostring(self.connected))~<10>end~<10|10>local function GiveInstance(_ip,_name)~<10>local i,obj~<10>for i,obj in ipairs(Instances) do~<10>	if (obj.connected == _ip) and obj.user and (obj.user.name == _name) then~<10>		return obj~<10>		end~<10>	end~<10>for i,obj in ipairs(Users) do~<10>	if (obj.name == _name) then~<10>		local new = TSSHservice_Instance(obj,_ip)~<10>		Instances[#Instances+1] = new~<10>		return new~<10>		end~<10>	end~<10>return nil~<10>end~<10|10>local function getEvent(_event)~<10>if (_event.name == ~<34>internet~<34>) and (_event.params[4] == ~<34>22~<34>) then~<10>	Debug(~<34>rev~<34>)~<10>	aNode = ehtf.THTNode()~<10>	aNode:FromStr(_event.params[6])~<10>	local command = aNode:Load(~<34>command~<34>,nil)~<10>	local hash = aNode:Load(~<34>hash~<34>,nil)~<10>	local name = aNode:Load(~<34>name~<34>,nil)~<10>	local _sudo = aNode:Load(~<34>sudo~<34>,false)~<10>	local requestseed = aNode:Load(~<34>requestseed~<34>,nil)~<10>	if requestseed and name then~<10>		local aobj = GiveInstance(_event.params[2],name)~<10>		if aobj then~<10>			aobj.connected = _event.params[2]~<10>			aobj:sendSeed()~<10>			end~<10>		end~<10>	~<10>	if command and hash and name then~<10>		local aobj = GiveInstance(_event.params[2],name)~<10>		if aobj and aobj.seed and aobj.user and aobj.user.pw then~<10>			local testhash = md5.md5(command .. aobj.user.pw .. aobj.seed)~<10>			if testhash == hash then~<10>				-- VALID~<10>				~<10>				local apath = path.C(path.TEMP(),~<34>remoteControl~<34>)~<10>				if (not fs.exists(apath)) then~<10>					fs.makeDir(apath)~<10>					end~<10>				local adata = path.C(apath,mStrings.UUID())~<10>				while fs.exists(adata) do~<10>					adata = path.C(apath,mStrings.UUID())~<10>					end~<10>				ehtfutils.StringToFile(adata,command)~<10>				Application.window:print(~<34>execute ~<34> .. adata)~<10>				~<10>				local co,co2 = mTask.CreateTask( adata or ~<34|34> , true )~<10>				co.file = adata~<10>				if _sudo and aobj.user.su then~<10>					co2:sudoRun()~<10>					else~<10>					co:run()~<10>					end~<10>				aobj:sendSeed()~<10>				end~<10>			end~<10>		end~<10>	end~<10>end~<10|10>local function EventHandle()~<10>local i,obj = 0,nil~<10>for i, obj in ipairs(Application.events) do~<10>	Application.window:Event(obj)~<10>	getEvent(obj)~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>local aNode = ehtf.THTNode()~<10>aNode:LoadfromFile(path.C(path.DATA(),~<34>ssh_service~<34>,~<34>users.ehtf~<34>))~<10>local i,obj = 0,nil~<10>for i,obj in ipairs(aNode.nodes) do~<10>	local _name = obj:Load(~<34>name~<34>,~<34|34>)~<10>	local _su = obj:Load(~<34>su~<34>,false)~<10>	local _pw = obj:Load(~<34>pw~<34>,~<34|34>)~<10>	local new = TSSHservice_User(_name,_pw)~<10>	if _su == true then~<10>		new.su = true~<10>		end~<10>	Users[#Users+1] = new~<10>	Debug(~<34>ssh~<34>, new.pw)~<10>	Debug(~<34>ssh~<34>, new.name)~<10>	end~<10|10>Debug(~<34>ssh~<34>, tostring(#Users) .. ~<34> profiles active~<34>)~<10>Application.window:print(tostring(#Users) .. ~<34> profiles active~<34>)~<10>while true do~<10>	EventHandle()~<10>	Application.window:Paint()~<10>	mTask.sleepEvent(Application,6)~<10>	end>>file<0||name<0|Startdisk>path<0|marcelOS/programs/Startdisk>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>1~<124>0.1~<62>changePrint~<60>2~<124>false~<62>eventfilter~<60|62>EventManager~<60>3~<124>false~<62>Debug~<60>3~<124>true~<62|62>code~<60>0~<124|126>i~<60>36~<62>print(~<34>Hello, i run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>2~<124>0.1~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>Application.window  =  windows.CreateWindow( Application.name , Application , true) ~<10>Application.window:SetSize(30,23)~<10>Application.window:FindSpace()~<10>local Data = ehtf.THTNode()~<10|10>local Label1 = winobj.TLabel(~<34>Label1~<34>,Application.window,Application.window)~<10>Label1.width = 6~<10>Label1.top = 2~<10>Label1.left = 2~<10>Label1.caption = ~<34>source~<34|10|10>local Edit1 = winobj.TEdit(~<34>Edit1~<34>,Application.window,Application.window)~<10>Edit1.width = 15~<10>Edit1.top = 2~<10>Edit1.left = 10~<10>Edit1.border = false~<10>Edit1.text.text = ~<34>/~<34|10|10>local Label2 = winobj.TLabel(~<34>Label2~<34>,Application.window,Application.window)~<10>Label2.width = 6~<10>Label2.top = 4~<10>Label2.left = 2~<10>Label2.caption = ~<34>dest~<34|10|10>local Edit2 = winobj.TEdit(~<34>Edit2~<34>,Application.window,Application.window)~<10>Edit2.width = 15~<10>Edit2.top = 4~<10>Edit2.left = 10~<10>Edit2.border = false~<10>Edit2.text.text = ~<34>/compressed.mzip~<34|10|10>local Checkbox1 = winobj.TCheckbox(~<34>Checkbox1~<34>,Application.window,Application.window)~<10>Checkbox1.width = 15~<10>Checkbox1.top = 6~<10>Checkbox1.left = 10~<10>Checkbox1.border = false~<10>Checkbox1.checked = false~<10>Checkbox1.caption = ~<34>Extract~<34|10|10>local Checkbox2 = winobj.TCheckbox(~<34>Checkbox2~<34>,Application.window,Application.window)~<10>Checkbox2.width = 15~<10>Checkbox2.top = 8~<10>Checkbox2.left = 10~<10>Checkbox2.border = false~<10>Checkbox2.checked = false~<10>Checkbox2.caption = ~<34>include /ROM~<34|10|10>local Checkbox3 = winobj.TCheckbox(~<34>Checkbox3~<34>,Application.window,Application.window)~<10>Checkbox3.width = 15~<10>Checkbox3.top = 10~<10>Checkbox3.left = 10~<10>Checkbox3.border = false~<10>Checkbox3.checked = true~<10>Checkbox3.caption = ~<34>All in one Line~<34|10|10>local Checkbox4 = winobj.TCheckbox(~<34>Checkbox4~<34>,Application.window,Application.window)~<10>Checkbox4.width = 15~<10>Checkbox4.top = 12~<10>Checkbox4.left = 10~<10>Checkbox4.border = false~<10>Checkbox4.checked = false~<10>Checkbox4.caption = ~<34>Self extraction~<34|10|10>local Label3 = winobj.TLabel(~<34>Label3~<34>,Application.window,Application.window)~<10>Label3.width = 6~<10>Label3.top = 13~<10>Label3.left = 2~<10>Label3.visible = false~<10>Label3.caption = ~<34>extract~<34|10|10>local Edit3 = winobj.TEdit(~<34>Edit3~<34>,Application.window,Application.window)~<10>Edit3.width = 15~<10>Edit3.top = 13~<10>Edit3.left = 10~<10>Edit3.border = false~<10>Edit3.visible = false~<10>Edit3.text.text = ~<34|34|10|10>local Checkbox5 = winobj.TCheckbox(~<34>Checkbox5~<34>,Application.window,Application.window)~<10>Checkbox5.width = 15~<10>Checkbox5.top = 15~<10>Checkbox5.left = 10~<10>Checkbox5.border = false~<10>Checkbox5.checked = false~<10>Checkbox5.caption = ~<34>Install Disk~<34|10|10>local function CheckboxOnChange ()~<10>Label3.visible = Checkbox4.checked~<10>Edit3.visible = Checkbox4.checked~<10>end~<10|10>Checkbox4.onChange = CheckboxOnChange~<10|10>Application.window:RegisterEvents(Application) ~<10|10>local function DoStart()~<10>local conf = ehtf.THTNode()~<10>local mode = ~<34|34|10>local source = Edit1.text.text~<10>local dest = Edit2.text.text~<10>local includerom = Checkbox2.checked~<10>local oneLine = Checkbox3.checked or Checkbox4.checked or Checkbox5.checked~<10>local output = ehtf.THTNode()~<10>local p = nil~<10>local timeout = 200~<10>local acount = 0~<10>local extractpath = Edit3.text.text~<10|10>if Checkbox1.checked then ~<10>	mode = ~<34>extract~<34|10>   else ~<10>	mode = ~<34>compress~<34|10>	end~<10|10>conf:Add(~<34>mode~<34>,mode)~<10>conf:Add(~<34>source~<34>,source)~<10>conf:Add(~<34>dest~<34>,dest)~<10>conf:Add(~<34>includerom~<34>,includerom)~<10>conf:Add(~<34>oneLine~<34>,oneLine)~<10|10>local co = mTask.CreateTask( ~<34>zip~<34> )~<10>co.file = path.C( path.PROGRAMS() , ~<34>dll~<34>, ~<34>mzip~<34> )~<10>co.args:Add(conf)~<10>if Checkbox4.checked or Checkbox5.checked then~<10>	output:Add(~<34>string~<34>)~<10>	co.args:Add(output)~<10>	end~<10>co:run()~<10|10>if Checkbox4.checked or Checkbox5.checked then~<10>	~<10>	p = output:FindAboutC(~<34>data~<34>)~<10>	while not p do~<10>		sleep(1)~<10>		Debug(~<34>waiting... ( ~<34> .. tostring(acount) .. ~<34> ~<124> ~<34> .. tostring(timeout) .. ~<34> )~<34>)~<10>		acount = acount + 1~<10>		if acount ~<62>= timeout then~<10>			Debug(~<34>ERROR mzip timed out~<34>)~<10>			return nil~<10>			end~<10>		p = output:FindAboutC(~<34>data~<34>)~<10>		end~<10|10>	Debug(~<34>create file~<34>)~<10>	local template = ehtfutils.FileToString(path.C(path.DATA(),~<34>Startdisk/selfextract_template~<34>))~<10>	if Checkbox5.checked then~<10>		local template2 = ehtfutils.FileToString(path.C(path.DATA(),~<34>Startdisk/install_template~<34>))~<10>		local template3 = ehtfutils.FileToString(path.C(path.DATA(),~<34>Startdisk/installfinished_template~<34>))~<10>		template = template2 .. ~<34> local dest = ~<92|34>/~<92|34>  local myData = ~<92|34|34> .. p:SValuesS(1) .. ~<34|92|34>  ~<34> .. template .. ~<34>  ~<34> .. template3~<10>		else~<10>		if extractpath == ~<34|34> then~<10>			template = ~<34>pr~<34> .. ~<34>int(~<92|34>enter extraction path~<92|34>) local dest = re~<34> .. ~<34>ad()  local myData = ~<92|34|34> .. p:SValuesS(1) .. ~<34|92|34>  ~<34> .. template ~<10>			else~<10>			template = ~<34>local dest = ~<92|34|34> .. extractpath .. ~<34|92|34>  local myData = ~<92|34|34> .. p:SValuesS(1) .. ~<34|92|34>  ~<34> .. template~<10>			end~<10>		end~<10>	ehtfutils.StringToFile(dest,template)	~<10>	--Debug(template)~<10>	end~<10|10|10>end~<10|10>local Button1 = winobj.TButton(~<34>Button1~<34>,Application.window,Application.window)~<10>Button1.width = 15~<10>Button1.top = 17~<10>Button1.left = 10~<10>Button1.border = true~<10>Button1.checked = true~<10>Button1.caption = ~<34>Start~<34|10>Button1.onClick = DoStart~<10|10>local function EventHandle()~<10>local i,obj = 0,nil~<10>for i, obj in ipairs(Application.events) do~<10>	Application.window:Event(obj)~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>while true do~<10>	EventHandle()~<10>	Application.window.l:clear()~<10>	Application.window:Paint()~<10>	mTask.sleepEvent(Application,6)~<10>	end>>file<0||name<0|taskmanager>path<0|marcelOS/programs/taskmanager>data<0|--mMultiOS~<10>--~<60|126>t~<60>true~<62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>taskmanager~<62>version~<60>1~<124>0.1~<62>changePrint~<60>2~<124>false~<62>IdleCount~<60>1~<124>30~<62|62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>taskmanager~<62>version~<60>2~<124>0.1~<62|62>code~<60>0~<124|126>i~<60>23~<62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>Application.useevents = true~<10>Application.window = windows.CreateWindow( Application.name , Application , true)~<10>Application.window:SetSize(45,20)~<10>Application.window:FindSpace(111)~<10>local lastrun = 0~<10>local frames = 0~<10>local timeout = 1~<10>local selected = nil~<10|10>local Eintrag = vec3.TList()~<10>local TEintrag_Taskmgr = classapi.class(nil,~<34>TEintrag_Taskmgr~<34>)~<10|10>function TEintrag_Taskmgr:__init()~<10>	self.name = ~<34|34|10>	self.pfad = ~<34|34|10>	if _tiefe then~<10>		self.tiefe = _tiefe~<10>		else~<10>		--Berechnen~<10>		end~<10>	self.pos = _pos~<10>	self.last = -1~<10>	self.alive = true~<10>	self.prg = nil~<10>	self.selected = false~<10>	Eintrag[#Eintrag+1] = self~<10>end~<10|10>local function NewEintrag(_pfad , _tabelle , _pos , _selected,_tiefe)~<10>local new = TEintrag_Taskmgr(_pfad , _tabelle , _pos , _selected,_tiefe)~<10>return new~<10>end~<10|10|10>local function Show()~<10>local i = 1~<10>local i2,c,p = 1,nil~<10>local obj,obj2 = mTask.GetProgram(i)~<10>local totalCPU = 0~<10>local acol = colors.white~<10>while obj do~<10>    totalCPU = totalCPU + obj.lastruntime ~<10>	i = i + 1~<10>	obj,obj2 = mTask.GetProgram(i)~<10>	end~<10>if lastrun + timeout ~<62>= os.clock() then~<10>	frames = frames + 1~<10>	else~<10>	local n = frames/(os.clock()-lastrun)~<10>	Application.window.name = tostring(math.floor((1-(n/20))*1000)/10) .. ~<34>%      ~<34> .. tostring(math.floor(n*100)/100) .. ~<34> /sec~<34|10>	lastrun = os.clock()~<10>	frames = 0~<10>	end~<10|10>Application.window.l:clear()~<10>Application.window:writePos(1,1,~<34>name~<34>)~<10>Application.window:writePos(20,1,~<34>idle~<34>)~<10>Application.window:writePos(28,1,~<34>CPU~<34>)~<10>Application.window:writePos(36,1,~<34>%~<34>)~<10>for i2,p in ipairs(Eintrag) do~<10>	p.alive = false --test here~<10>	end~<10>i = 1~<10>local obj,obj2 = mTask.GetProgram(i)~<10>while obj do~<10>	i2 = 1~<10>	c = nil~<10>	for i2,p in ipairs(Eintrag) do~<10>		if p.name == obj.name then~<10>			c = p~<10>			break~<10>			end~<10>		end~<10>	if not c then~<10>		c = TEintrag_Taskmgr()~<10>		Eintrag:Add(c)~<10>		c.name = obj.name~<10>		end~<10>	c.pos = i*2+1~<10>	c.prg = obj~<10>	c.last = obj.lastrun~<10>	c.alive = true~<10>	if c.selected then~<10>	   acol = colors.blue~<10>	   else~<10>	   acol = colors.white~<10>	   end~<10>	Application.window:writePos(1,i*2+1,obj.name,acol)~<10>	Application.window:writePos(20,i*2+1,tostring(os.clock()-obj.lastrun))~<10>    Application.window:writePos(28,i*2+1,tostring(obj.lastruntime))~<10>	if totalCPU ~<62> 0.1 then~<10>	   Application.window:writePos(36,i*2+1,tostring(math.floor(obj.lastruntime/totalCPU*100)))~<10>	   else~<10>	   Application.window:writePos(36,i*2+1,~<34>0~<34>)~<10>	   end~<10>	~<10>	i = i + 1~<10>	obj,obj2 = mTask.GetProgram(i)~<10>	end~<10>for i2 = #Eintrag,1,-1 do~<10>	p = Eintrag[i2]~<10>	if not p.alive then~<10>		Eintrag:Del(i2)~<10>		end~<10>	end~<10>--Application.window:Paint()~<10>end~<10|10>local function EintragOfPos(_x,_y)~<10>local i,obj = 0~<10>for i,obj in ipairs(Eintrag) do~<10>	if (obj.pos == _y) then~<10>		selected = obj~<10>		break~<10>		end~<10>	end~<10>for i,obj in ipairs(Eintrag) do~<10>	obj.selected = (obj == selected)~<10>	end~<10>end~<10|10>local function getEvent(_event)~<10>Application.window:Event(_event)~<10>if (_event.name == ~<34>mouse_window~<34>) then~<10>	EintragOfPos(_event.params[2],_event.params[3])~<10>	end~<10>end~<10|10>local function EventHandle()~<10>local i,obj = 0,nil~<10>for i, obj in ipairs(Application.events) do~<10>	getEvent(obj)~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>Show()~<10>while true do~<10>	Show()~<10>	EventHandle()~<10>	Application.window:Paint()~<10>	sleep(0)~<10>	end>>>>folder<0||name<0|startup>path<0|marcelOS/startup>sub<0||file<0||name<0|01-apis>path<0|marcelOS/startup/01-apis>data<0|-- Load APIs~<10>-- Basic APIS till ~<34>EHTF~<34> dont use API_INITIAL !!!~<10>local REIHE = {~<34>classapi~<34>,~<34>path~<34>,~<34>vec3~<34>,~<34>mStrings~<34>,~<34>ehtfutils~<34>,~<34>ehtf~<34>,~<34>events~<34>,~<34>mperipheral~<34>,~<34>driver~<34>,~<34>ip~<34>,~<34>lps~<34>,~<34>mView~<34>,~<34>winobj~<34>,~<34>windows~<34>,~<34>mTaskModify~<34>,~<34>mTask~<34>,~<34>programs~<34>}~<10>local ok = false~<10>local i,obj = 0~<10|10>local tApis = fs.list( ~<34>/marcelOS/apis~<34> )~<10>for n,sFile in ipairs( tApis ) do~<10>	if not fs.isDir( sFile ) then~<10>		ok = true~<10>		for i,obj in ipairs( REIHE ) do~<10>			if obj == sFile then~<10>				ok = false~<10>				break~<10>				end~<10>			end~<10>		if ok then~<10>			REIHE[#REIHE+1] = sFile~<10>			end~<10>		end~<10>	end~<10>	~<10>boot.BootYield()~<10|10>for i,obj in ipairs( REIHE ) do ~<10>	os.loadAPI( fs.combine( ~<34>/marcelOS/apis~<34>, obj ) )~<10>	end~<10|10>boot.BootYield()	~<10>	~<10>-- After all API loadet, call the API.API_Initial()~<10>boot.BootMsg(~<34>Initial all APIS~<34>)~<10>for i,obj in ipairs( REIHE ) do ~<10>	local aname = obj .. ~<34>.API_Initial~<34|10>	local afunc = driver.findfunction(aname) -- Driver API ist notwendig hier !!!~<10>	if afunc then~<10>	   assert(afunc)()~<10>       end~<10>	end~<10>	~<10>boot.BootYield()~<10>	~<10>-- Clear OS temp dir~<10>if path.TEMP() then~<10>	fs.delete(path.TEMP())~<10>	end>>file<0||name<0|02-autostart>path<0|marcelOS/startup/02-autostart>data<0|-- Load AUTOSTART~<10>local REIHE = {~<34>DHCPregister~<34>,~<34>explorer~<34>,~<34>taskmanager~<34>,~<34>debugger~<34>}~<10>local asROOT = {true,true,true,true}~<10|10>local co = nil~<10>sleep(0.1) -- NO ERROR !~<10>for i,obj in ipairs( REIHE ) do ~<10>	co,cosu = mTask.CreateTask(obj,asROOT[i])~<10>	co.file = path.AUTORUN() .. ~<34>/~<34> .. obj~<10>	co.args:Add(~<34>autostart~<34>)~<10>	co.rt_fak = 10~<10>	if asROOT[i] and (cosu ~<126>= nil) then ~<10>		cosu:sudoRun()~<10>		else~<10>		co:run()~<10>		end~<10>	end>>file<0||name<0|03-login>path<0|marcelOS/startup/03-login>data<0|-- Login // Open OS so no Login Acc needed~<10|10>sleep(0.1) -- Debugausgabe anschauen + sleep zumied kein ~<34>To long without yieling~<34>>>file<0||name<0|04-userautostart>path<0|marcelOS/startup/04-userautostart>data<0|-- Load AUTOSTART~<10|10>local co = nil~<10>local tApis = fs.list( path.USERAUTOSTART() )~<10|10>for n,sFile in ipairs( tApis ) do~<10>	co = mTask.CreateTask( sFile )~<10>	co.file = path.USERAUTOSTART() .. ~<34>/~<34> .. sFile~<10>	co.args:Add(~<34>userautostart~<34>)~<10>	co:run()~<10>	end>>file<0||name<0|05-debug>path<0|marcelOS/startup/05-debug>data<0|-- Login // Open OS so no Login Acc needed~<10|10>sleep(2) -- Debugausgabe anschauen + sleep zumied kein ~<34>To long without yieling~<34|10>term.clear()~<10>term.setCursorPos(1,1)>>file<0||name<0|06-task>path<0|marcelOS/startup/06-task>data<0|local lastsleep =  os.clock() ~<10|10>-- THE ENDLESS LOOP OF COOLNES~<10>local Sleepvar = 0.1~<10|10>while true do~<10>	mTask.RunAll()~<10>	if lastsleep + Sleepvar ~<60> os.clock() then~<10>		lastsleep = os.clock()~<10>		mTask.GetEvents(0,false) ~<10>		end~<10>	end>>>>folder<0||name<0|temp>path<0|marcelOS/temp>sub<0||folder<0||name<0|marcelOS>path<0|marcelOS/temp/marcelOS>sub<0||folder<0||name<0|programs>path<0|marcelOS/temp/marcelOS/programs>sub<0||folder<0||name<0|dll>path<0|marcelOS/temp/marcelOS/programs/dll>sub<0||file<0||name<0|mzip>path<0|marcelOS/temp/marcelOS/programs/dll/mzip>data<0| local  Application  ,ApplicationSU  =  mTask.LastStarted()  coroutine.yield()  --mMultiOS ~<10> local  function  Debug(title,msg,color)  ~<10>  if  ThrowDebug  then  ThrowDebug(Application,title,msg,color)  end  ~<10>  end  print(~<34>Hello, i run under marcelOS~<34>) ~<10> --  Can  Compress  /  extract  a  Directory  in  a  single  string ~<10> local  tArgs  =  {...} ~<10> --  Args  1:  Data  in  EHTF ~<10> --  Args:  mode  (compress / extract) ~<10> --  Args:  source ~<10> --  Args:  dest ~<10> --  Args:  includerom ~<10> --  Args:  oneLine ~<10|10> --  Args  2:  Output  EHTF ~<10> --  Args:  data ~<10> local  conf  =  ehtf.THTNode() ~<10> local  output  =  tArgs[2] ~<10> local  p  =  nil ~<10> if  type(tArgs[1])  ==  ~<34>table~<34>  then ~<10> 	conf  =  tArgs[1] ~<10> 	else ~<10> conf:FromStr(tArgs[1]) ~<10> 	end ~<10> local  source  =  ~<34>/~<34> ~<10> local  dest  =  ~<34>/compressed.mzip~<34> ~<10> local  mode  =  ~<34|34> ~<10> local  includerom  =  false ~<10> local  oneLine  =  false ~<10|10> p  =  conf:FindAboutC(~<34>mode~<34>) ~<10> if  p  then ~<10> 	mode  =  p:SValuesS(1) ~<10> 	end ~<10> p  =  conf:FindAboutC(~<34>source~<34>) ~<10> if  p  then ~<10> 	source  =  p:SValuesS(1) ~<10> 	end	 ~<10> p  =  conf:FindAboutC(~<34>dest~<34>) ~<10> if  p  then ~<10> 	dest  =  p:SValuesS(1) ~<10> 	end ~<10> p  =  conf:FindAboutC(~<34>includerom~<34>) ~<10> if  p  then ~<10> 	includerom  =  p:SValuesB(1) ~<10> 	end ~<10> p  =  conf:FindAboutC(~<34>oneLine~<34>) ~<10> if  p  then ~<10> 	oneLine  =  p:SValuesB(1) ~<10> 	end	 ~<10|10> local  Data  =  ehtf.THTNode() ~<10|10> function  AlternativeCutOut(Sender , achar , bchar)  local  abyte  =  string.byte(achar)  local  result  =  ((achar == Sender.vardec._Begin)or(achar == Sender.vardec._End)or(achar == Sender.vardec._Array)or(achar == Sender.vardec._System)or(abyte == 34)or(abyte == 0)or(abyte == 10)or(abyte == 13)or(abyte == 92)  		)  return  result  end ~<10|10> if  oneLine  then ~<10> 	Data.CutOutfunc  =  AlternativeCutOut ~<10> 	end ~<10|10> local  function  LoadData(adata,apath,aname) ~<10> local  i,obj  =  1,nil ~<10> local  tData  =  fs.list( apath ) ~<10> local  p,o,p2  =  nil,nil,nil ~<10> local  ap  =  ~<34|34> ~<10|10> p  =  adata:Add(~<34>folder~<34>,~<34|34>) ~<10> p:Add(~<34>name~<34>,aname) ~<10> p:Add(~<34>path~<34>,apath) ~<10> o  =  p:Add(~<34>sub~<34>,~<34|34>) ~<10> for  i,obj  in  ipairs(tData)  do ~<10> 	ap  =  path.C(apath,obj) ~<10> 	if  fs.isDir(ap)  then ~<10> 		if  includerom  or  (ap ~<126>= ~<34>/rom~<34>)  then  --  we  dont  load  rom  ! ~<10> LoadData(o,  ap  ,obj) ~<10> 			end ~<10> 		else ~<10> 		p2  =  o:Add(~<34>file~<34>,~<34|34>) ~<10> p2:Add(~<34>name~<34>,obj) ~<10> p2:Add(~<34>path~<34>,ap) ~<10> p2:Add(~<34>data~<34>,ehtfutils.FileToString(ap)) ~<10> 		end ~<10> 	end ~<10> end ~<10|10> function  aSleepFunc() ~<10> mTask.sleep(Application,0.0001) ~<10> end ~<10|10|10|10> local  function  ExtractData(adata,apath) ~<10> local  i,obj  =  1,nil ~<10> local  p,o,p2,p3  =  nil,nil,nil ~<10> local  ap,bp  =  ~<34|34> ~<10> local  aname  =  ~<34|34> ~<10> local  afile  =  ~<34|34> ~<10> local  filedata  =  ~<34|34> ~<10> p  =  adata:FindAboutC(~<34>name~<34>) ~<10> if  p  then ~<10> 	aname  =  p:SValuesS(1) ~<10> 	ap  =  path.C(apath,aname) ~<10> fs.makeDir(ap) ~<10> 	end ~<10> o  =  adata:FindAboutC(~<34>sub~<34>) ~<10> 	 ~<10> for  i,obj  in  ipairs(o.nodes)  do ~<10> 	if  obj.about  ==  ~<34>folder~<34>  then ~<10> ExtractData(obj,ap) ~<10> 		else ~<10> 		p2  =  obj:FindAboutC(~<34>name~<34>) ~<10> 		if  p2  then ~<10> 			afile  =  p2:SValuesS(1) ~<10> 			bp  =  path.C(ap,afile) ~<10> 			p3  =  obj:FindAboutC(~<34>data~<34>) ~<10> 			if  p3  then ~<10> 				filedata  =  p3:SValuesS(1) ~<10> ehtfutils.StringToFile(bp,filedata) ~<10> 				end ~<10> 			end ~<10> 		end ~<10> 	end ~<10> end ~<10|10> if  mode  ==  ~<34>compress~<34>  then ~<10> Debug(~<34>compressing~<34>) ~<10> LoadData(Data,source,source) ~<10> 	local  lmode  =  vec3.Copy(ehtfutils.stToStrMode) ~<10> 	lmode[~<34>tsUseInsert~<34>]  =  false ~<10> Debug(~<34>done1~<34>) ~<10> 	if  output  then ~<10> 		if  output:FindAboutC(~<34>string~<34>)  then ~<10> output:Add(~<34>data~<34>,Data:ToStr(lmode,aSleepFunc)) ~<10> 			else ~<10> 			local  p  =  output:Add(~<34>data~<34>,~<34|34>) ~<10> p:Add(Data) ~<10> 			end ~<10> 		else ~<10> Debug(~<34>k~<34>) ~<10> Data:SavetoFile(dest,lmode) ~<10> Debug(~<34>SAVED to ~<34> .. dest) ~<10> 		end ~<10|10> 	end ~<10> if  mode  ==  ~<34>extract~<34>  then ~<10> Debug(~<34>extracting~<34>) ~<10> 	if  not  fs.exists(dest)  then ~<10> fs.makeDir(dest) ~<10> 		end ~<10> 		 ~<10> Data:LoadfromFile(source) ~<10> ExtractData(Data:FindAboutC(~<34>folder~<34>),dest) ~<10> Debug(~<34>Done~<34>) ~<10|10> 	end ~<10> 	 >>>>>>>>>>>>folder<0||name<0|MGRUB>path<0|/MGRUB>sub<0||file<0||name<0|boot>path<0|MGRUB/boot>data<0|-- marcelOS boot functions~<10|10>bootmsg = {}~<10>showmsg = true~<10>savemsg = true~<10>showtime = true~<10>bootlastsleep = os.clock() ~<10>bootSleepvar = 0.1~<10>local lastsaved = 0~<10|10>local file = fs.open(~<34>/MGRUB/boot.info~<34>,~<34>w~<34>)~<10>file.writeLine(~<34>[0]INITIAL BOOT API~<34>)~<10>file:close()~<10|10>function BootYield()~<10>if bootlastsleep + bootSleepvar ~<60> os.clock() then~<10>	bootlastsleep = os.clock()~<10>	sleep(0.00001) ~<10>	end~<10>end~<10|10>function BootMsg( astr )~<10>if showtime then~<10>	astr = ~<34>[~<34> .. tostring(os.clock()) .. ~<34>]~<34> .. astr~<10>	end~<10>bootmsg[#bootmsg + 1] = astr~<10>if showmsg then ~<10>	print(astr)~<10>	end~<10>if savemsg and (#bootmsg % 5  == 0) then~<10>	local file = fs.open(~<34>/MGRUB/boot.info~<34>,~<34>a~<34>)~<10>	local i ~<10>	for i = lastsaved+1,#bootmsg do~<10>		file.writeLine(bootmsg[i])~<10>		end~<10>	lastsaved = #bootmsg~<10>	file:close()~<10>	end~<10>end>>file<0||name<0|boot.info>path<0|MGRUB/boot.info>data<0|[0]INITIAL BOOT API~<10>[0]MGRUB 0.98.2 - BOOT LOADER~<10>[0]Loading settings to Boot~<10>[0]standart OS: marcelOS.mgrub~<10>[0]timeout : 2~<10>[2.05]booting into marcelOS~<10>[2.05]visit http://marcelmaertens.funpic.de for information~<10>[2.1]starting path~<10>[2.1]starting vec3~<10>[2.1]starting mStrings~<10>[2.1]starting events~<10>[2.1]starting Peripherals~<10>[2.1]starting drivers~<10>[2.1]starting ip~<10>[2.1]starting lps~<10>[2.1]starting mView~<10>[2.15]starting winobj~<10>[2.15]starting windows~<10>[2.15]starting mTaskModify~<10>[2.15]starting mTask~<10>[2.15]starting programs~<10>[2.15]starting mgps~<10>[2.15]starting sha1~<10>[2.15]Initial all APIS~<10>[2.15]Driver 'driver_01windowconverter' v.:0.1~<10>[2.15]Driver 'driver_IP' v.:0.1~<10>[2.2]Driver 'driver_mView' v.:0.1~<10>[2.2]Driver 'driver_peripheral' v.:0.1~<10>[2.2]Driver 'driver_peripheralcable' v.:0.1~<10>[2.2]Driver 'driver_turtle' v.:0.1~<10>[2.2]Driver 'driver_windows' v.:0.1~<10>[2.35]addTerm~<10>[2.55]sudo-prg  /marcelOS/autorun/DHCPregister~<10>[2.55]sudo-arg  autostart~<10>[2.55]sudo-prg  /marcelOS/autorun/explorer~<10>[2.55]sudo-arg  autostart~<10>[2.6]sudo-prg  /marcelOS/autorun/taskmanager~<10>[2.6]sudo-arg  autostart~<10>[2.6]sudo-prg  /marcelOS/autorun/debugger~<10>[2.6]sudo-arg  autostart~<10>[8.65]prg  /marcelOS/programs/programs-dll/execute~<10>[8.65]arg  marcelOS/programs/SoftwareUpdater explorer~<10>[8.65]prg  marcelOS/programs/SoftwareUpdater~<10>[8.65]arg  explorer~<10>[9.2]prg  marcelOS/programs/dll/mprojectmeta~<10>[9.2]arg  table: 78549b0d~<10>[60.4]prg  marcelOS/programs/dll/mprojectmeta~<10>[60.4]arg  table: 5e818594~<10>[105.35]prg  /marcelOS/programs/programs-dll/execute~<10>[105.35]arg  marcelOS/programs/Startdisk explorer~<10>[105.35]prg  marcelOS/programs/Startdisk>>file<0||name<0|craftOS.mgrub>path<0|MGRUB/craftOS.mgrub>data<0|name CraftOS~<10>owner ComputerCraft~<10>lastboot 2.753~<10>bootcount 5~<10>bootfile >>file<0||name<0|marcelOS>path<0|MGRUB/marcelOS>data<0|OSPath = ~<34>/marcelOS~<34|10>boot.BootMsg(~<34>visit http://marcelmaertens.funpic.de for information~<34>)~<10|10>if fs.isDir(OSPath..~<34>/startup~<34>) then~<10>	local files = fs.list(OSPath..~<34>/startup~<34>)~<10>	table.sort(files)~<10>	local k,file = 0,0~<10>	for k, file in ipairs(files) do~<10>		local path = fs.combine(OSPath..~<34>/startup~<34>, file)~<10>		if not fs.isDir(path) then~<10>			shell.run(path)~<10>			end~<10>		end~<10>	end>>file<0||name<0|marcelOS.mgrub>path<0|MGRUB/marcelOS.mgrub>data<0|name marcelOS~<10>owner Marcel_Maertens_http://marcelmaertens.funpic.de~<10>lastboot 18.382~<10>bootcount 6344~<10>bootfile marcelOS>>file<0||name<0|redworks>path<0|MGRUB/redworks>data<0|shell.setPath( ~<34>.:/rom/programs~<34> )~<10>help.setPath( ~<34>/rom/help~<34> )~<10|10>shell.setAlias( ~<34>ls~<34>, ~<34>list~<34> )~<10>shell.setAlias( ~<34>dir~<34>, ~<34>list~<34> )~<10>shell.setAlias( ~<34>cp~<34>, ~<34>copy~<34> )~<10>shell.setAlias( ~<34>mv~<34>, ~<34>move~<34> )~<10>shell.setAlias( ~<34>rm~<34>, ~<34>delete~<34> )~<10|10>if fs.isDir('/mem/autorun') then~<10>	local files = fs.list('/mem/autorun')~<10>	table.sort(files)~<10>	for k, file in ipairs(files) do~<10>		local path = fs.combine('/mem/autorun', file)~<10>		if not fs.isDir(path) then~<10>			shell.run(path)~<10>		end~<10>	end~<10>end>>file<0||name<0|redworks.mgrub.disabled>path<0|MGRUB/redworks.mgrub.disabled>data<0|name redworks~<10>owner http://www.computercraft.info/forums2/index.php?/topic/11-121314redworks-addon/~<10>lastboot 1.275~<10>bootcount 3~<10>bootfile redworks>>file<0||name<0|settings>path<0|MGRUB/settings>data<0|standart marcelOS.mgrub~<10>timeout 2~<10>bootsleep 0>>>>file<0||name<0|startup>path<0|/startup>data<0|local function FileEnding( _str )~<10>local x = string.len(_str)~<10>local ok = false~<10>local result = ~<34|34|10>while x ~<62> 0 do~<10>	if string.char(string.byte(_str , x)) == ~<34>.~<34> then~<10>		ok = true~<10>		break~<10>		end~<10>	x = x - 1~<10>	end~<10>if ok then~<10>	result = string.sub(_str,x)~<10>	end~<10>return result~<10>end~<10|10>local function Values( _str , _seperator )~<10>local _seperator, fields = _seperator or ~<34> ~<34>, {}~<10>local pattern = string.format(~<34>([^%s]+)~<34>, _seperator)~<10>_str:gsub(pattern, function(c) fields[#fields+1] = c end)~<10>while #fields ~<62> 2 do ~<10>	fields[#fields-1] = fields[#fields-1] .. fields[#fields]~<10>	fields[#fields] = nil~<10>	end~<10>return fields~<10>end~<10|10>local function SelectColor(acolor)~<10>if term.isColor and term.isColor() then~<10>	term.setTextColor(acolor or colors.white)~<10>	end~<10>end~<10|10>local MGRUB_PATH = ~<34>/MGRUB~<34|10>local OSs = {}~<10>OSs.__index = OSs~<10|10>function OSs.create(_file)~<10>	local acnt = {}~<10>	setmetatable(acnt,OSs)~<10>	acnt.name = ~<34|34|10>	acnt.file = _file~<10>	acnt.owner = ~<34>unknown~<34|10>	acnt.lastboot = 0~<10>	acnt.bootcount = 0~<10>	acnt.bootfile = nil~<10>	return acnt~<10>end~<10|10>function OSs:GetInfo()~<10>local file = fs.open(MGRUB_PATH .. ~<34>/~<34> .. self.file,~<34>r~<34>)~<10>if file then~<10>	local  sLine = ~<34|34|10>	local puffer = {}~<10>	sLine = file:readLine()~<10>	while sLine do~<10>		puffer = Values(sLine, ~<34> ~<34>)~<10>		if puffer[1] == ~<34>name~<34> then self.name = puffer[2] end~<10>		if puffer[1] == ~<34>owner~<34> then self.owner = puffer[2] end~<10>		if puffer[1] == ~<34>lastboot~<34> then self.lastboot = tonumber(puffer[2]) end~<10>		if puffer[1] == ~<34>bootcount~<34> then self.bootcount = tonumber(puffer[2]) end~<10>		if puffer[1] == ~<34>bootfile~<34> then self.bootfile = puffer[2] end~<10>		sLine = file:readLine()~<10>		end~<10>	file:close()~<10>	end~<10>return (file ~<126>= nil)~<10>end~<10|10>function OSs:WriteInfo()~<10>fs.delete(MGRUB_PATH .. ~<34>/~<34> .. self.file)~<10>local file = fs.open(MGRUB_PATH .. ~<34>/~<34> .. self.file,~<34>w~<34>)~<10>file.writeLine(~<34>name ~<34>.. (self.name or ~<34|34>))~<10>file.writeLine(~<34>owner ~<34>.. (self.owner or ~<34|34>))~<10>file.writeLine(~<34>lastboot ~<34>.. (self.lastboot or ~<34|34>))~<10>file.writeLine(~<34>bootcount ~<34>.. (self.bootcount or ~<34|34>))~<10>file.writeLine(~<34>bootfile ~<34>.. (self.bootfile or ~<34|34>))~<10>file.close()~<10>end~<10|10>function OSs:Boot()~<10>self.lastboot = os.time()~<10>self.bootcount = self.bootcount + 1~<10>self:WriteInfo()~<10>if self.bootfile ~<126>= nil then~<10>	if string.char(string.byte(self.bootfile , 1)) == ~<34>/~<34> then~<10>		shell.run(self.bootfile)~<10>		else~<10>		shell.run(MGRUB_PATH .. ~<34>/~<34> .. self.bootfile)~<10>		end~<10>	end~<10>end~<10|10|10|10>-- STARTING --~<10>-- LOADING SETTINGS --~<10|10>local standart = ~<34|34|10>local timeout = 10~<10>local bootsleep = 4~<10>local current = -1~<10>local runto = 0~<10>local MGRUB_VERSION = ~<34>0.98.2~<34|10|10>-- Load Boot API -- ~<10>os.loadAPI(MGRUB_PATH .. ~<34>/boot~<34>)~<10|10>boot.BootMsg(~<34>MGRUB ~<34> .. MGRUB_VERSION .. ~<34> - BOOT LOADER~<34>)~<10>local file = fs.open(MGRUB_PATH .. ~<34>/settings~<34>,~<34>r~<34>)~<10>if file then~<10>	local  sLine = ~<34|34|10>	local puffer = {}~<10>	sLine = file:readLine()~<10>	while sLine do~<10>		puffer = Values(sLine, ~<34> ~<34>)~<10>		if puffer[1] == ~<34>standart~<34> then standart = puffer[2] end~<10>		if puffer[1] == ~<34>timeout~<34> then timeout = tonumber(puffer[2]) end~<10>		if puffer[1] == ~<34>bootsleep~<34> then bootsleep = tonumber(puffer[2]) end~<10>		sLine = file:readLine()~<10>		end~<10>		~<10>	file:close()~<10>	boot.BootMsg(~<34>Loading settings to Boot~<34>)~<10>	boot.BootMsg(~<34>standart OS: ~<34> .. standart)~<10>	boot.BootMsg(~<34>timeout : ~<34> .. timeout)~<10>	else~<10>	boot.BootMsg(~<34>unable to load settings~<34>)~<10>	boot.BootMsg(~<34>please check the '~<34>.. MGRUB_PATH .. ~<34>/settings' File !~<34> )~<10>	end~<10>sleep(bootsleep)~<10|10>-- CHECK FOR OSs --~<10>for i,obj in ipairs(fs.list(MGRUB_PATH)) do~<10>	if FileEnding( obj ) == ~<34>.mgrub~<34> then~<10>		local new = OSs.create(obj)~<10>		if not new:GetInfo() then~<10>			boot.BootMsg(~<34>Failed to Load OS: ~<34> .. obj)~<10>			else~<10>			OSs[#OSs+1] = new~<10>			if obj == standart then~<10>				current = #OSs~<10>				end~<10>			end~<10>		end~<10>	end~<10|10>-- AUSWAHL -- ~<10>local function Render()~<10>term.clear()~<10>term.setCursorPos(1,1)~<10>print(~<34>MGRUB ~<34> .. MGRUB_VERSION .. ~<34> - BOOT LOADER~<34>)~<10>print(~<34|34>)~<10>for i,obj in ipairs(OSs) do~<10>	if i == current then~<10>		SelectColor(colors.green)~<10>		print(~<34>  ~<62> ~<34> .. obj.name .. ~<34> ~<60>  ~<34>)~<10>		SelectColor(colors.white)~<10>		else~<10>		print(~<34>    ~<34> .. obj.name .. ~<34>    ~<34>)~<10>		end~<10>	end~<10>print(~<34|34>)~<10>print(~<34|34>)~<10>local t = math.floor(runto - os.clock())~<10>if (t ~<60> 3) and (term.isColor()) then~<10>	write(~<34>timeout ~<34>)~<10>	SelectColor(colors.red)~<10>	print(t)~<10>	SelectColor(colors.white)~<10>	else~<10>	print(~<34>timeout ~<34>.. tostring(t))~<10>	end~<10|10>local x,y = term.getSize()~<10>term.setCursorPos(1,y)~<10>write(~<34>xMAC94x~<34>)~<10>local astr = ~<34>GPL2.0 - http://goo.gl/8Axgz~<34|10>term.setCursorPos(x-string.len(astr),y)~<10>write(astr)~<10|10>end	~<10|10>function GetEvents( _atime )~<10>local timer = os.startTimer( (_atime or 0) )~<10>local event, p1, p2, p3, p4, p5 = 0~<10>local i,obj~<10>while true do~<10>	event, p1, p2, p3, p4, p5 = os.pullEvent()~<10>	if ((event == ~<34>timer~<34>) and (p1 == timer)) then ~<10>		break ~<10>	elseif  event == ~<34>key~<34> then~<10>		if (p1 == 17) or (p1 == 200) then ~<10>			current = current - 1~<10>			if current ~<60> 1 then current = #OSs end~<10>			runto = os.clock() + timeout + 5~<10>			end~<10>		if (p1 == 31) or (p1 == 208) then ~<10>			current = current + 1~<10>			if current ~<62> #OSs then current = 1 end~<10>			runto = os.clock() + timeout + 5~<10>			end~<10>		if (p1 == 28) then ~<10>			runto = -1~<10>			end~<10>		end~<10>	end~<10>end~<10|10>runto = os.clock() + timeout~<10>while os.clock() ~<60> runto do~<10>	Render()~<10>	GetEvents(0.05)~<10>	end~<10|10>if current ~<126>= -1 then~<10>	boot.BootMsg(~<34>booting into ~<34> .. OSs[current].name)~<10>	OSs[current]:Boot()~<10>	end~<10>	>>folder<0||name<0|user>path<0|/user>sub<0||folder<0||name<0|autostart>path<0|user/autostart>sub<0||>>folder<0||name<0|examples>path<0|user/examples>sub<0||file<0||name<0|evlc>path<0|user/examples/evlc>data<0|10~<10>3~<10>2~<10>go~<10>                     ~<10>z~<10>                     ~<10>                     ~<10>ez~<10>                     ~<10>					 ~<10>lez~<10>					 ~<10>					 ~<10>ulez~<10>					 ~<10>					 ~<10>Rulez~<10>					 ~<10>					 ~<10> Rulez~<10>					 ~<10>					 ~<10>l Rulez~<10>					 ~<10>					 ~<10>el Rulez~<10>					 ~<10>					 ~<10>cel Rulez~<10>					 ~<10>					 ~<10>rcel Rulez~<10>					 ~<10>					 ~<10>arcel Rulez~<10>					 ~<10>					 ~<10>Marcel Rulez~<10>					 ~<10>					 ~<10> Marcel Rulez~<10>					 ~<10>					 ~<10>  Marcel Rulez~<10>					 ~<10>					 ~<10>   Marcel Rulez~<10>					 ~<10>					 ~<10>    Marcel Rulez~<10>					 ~<10>					 ~<10>     Marcel Rulez~<10>					 ~<10>					 ~<10>      Marcel Rule~<10>					 ~<10>					 ~<10>      Marcel Rule~<10>					 ~<10>					 ~<10>       Marcel Rul~<10>					 ~<10>					 ~<10>        Marcel Ru~<10>					 ~<10>					 ~<10>         Marcel R~<10>					 ~<10>					 ~<10>          Marcel ~<10>					 ~<10>					 ~<10>           Marcel~<10>					 ~<10>					 ~<10>            Marce~<10>					 ~<10>					 ~<10>             Marc~<10>					 ~<10>					 ~<10>              Mar~<10>					 ~<10>					 ~<10>               Ma~<10>					 ~<10>					 ~<10>                M~<10>					 ~<10>					 ~<10>                 ~<10>					 ~<10>					 ~<10>                ~<10>					 >>file<0||name<0|evlc2>path<0|user/examples/evlc2>data<0|10~<10>14~<10>4~<10>go~<10>+   ~<124>        +           ~<124>       ~<10>   - -                  - -      +~<10>    ~<124>      +             ~<124|10>       +           +        +~<10>+                      +         ~<10>--__--__--__--,------,        ~<10>--__--__--__--~<124>   /_/  ~<10>--__--__--__-~<126|124>__( ^ .^)  +     +  ~<10>--__--__--__--~<34|34>  ~<34|34>      ~<10>+             ~<124>       +        ~<10>    +        - -~<10>              ~<124>                  +~<10>                +~<10>+      +                     +    ~<10>+            +                  ~<10>    +                   +       +~<10>           +~<10>       +           +        +~<10>+                      +         ~<10>-__--__--__--_,------,        ~<10>-__--__--__--_~<124>   /_/  ~<10>-__--__--__--~<126|124>__( ^ .^)  +     +  ~<10>-__--__--__--_~<34|34>  ~<34|34>      ~<10>+                    +        ~<10>    +         +  ~<10>                                +~<10>                +~<10>+      +                     +    ~<10>+            +                  ~<10>    +                   +       +~<10>           +~<10>       +           +        +~<10>+                      +         ~<10>__--__--__--__,------,        ~<10>__--__--__--__~<124>   /_/  ~<10>__--__--__--_~<126|124>__( ^ .^)  +     +  ~<10>__--__--__--__~<34|34>  ~<34|34>  ~<10>+                    +        ~<10>    +         +~<10>                                +~<10>                +~<10>+      +                     +    ~<10>+            +                  ~<10>    +                   +       +~<10>           +~<10>       +           +        +~<10>+                      +         ~<10>_--__--__--__-,------,        ~<10>_--__--__--__-~<124>   /_/  ~<10>_--__--__--__~<126|124>__( ^ .^)  +     +  ~<10>_--__--__--__-~<34|34>  ~<34|34>      ~<10>+                    +        ~<10>    +         +~<10>                                +~<10>                +~<10>+      +                     +    >>file<0||name<0|logo.img>path<0|user/examples/logo.img>data<0| _____ ____  __  ____ ____       ____  _____~<10> ~<124> ~<124> ~<124> ~<124>__~<124> ~<124>__~<124> ~<124>    ~<124>___ ~<124>    ~<124>    ~<124> ~<124>____~<10> ~<124> ~<124> ~<124> ~<124>  ~<124> ~<124> ~<124>_ ~<124>__  ~<124>___ ~<124>__  ~<124>____~<124>_____~<124>>>>>folder<0||name<0|programs>path<0|user/programs>sub<0||file<0||name<0|MSPaint>path<0|user/programs/MSPaint>data<0|local count = 0~<10>local Arg = {...}~<10>Application.useevents = true~<10>Application.window:SetSize(40,20)~<10>Application.window:FindSpace(111)~<10>local i,obj = 0~<10>local mystring = ~<34>X~<34|10>local astr = ~<34>X - O I / ~<92> _ - ~<124> H L R F~<34|10|10|10>local function getEvent(_event)~<10>if (_event.name == ~<34>mouse~<34>) then~<10>	local posx = _event.params[2]~<10>	local posy = _event.params[3]~<10>	if posy ~<62> 4 then~<10>		Application.window:writePos(posx,posy,mystring)~<10>		else~<10>		if posx ~<62> string.len(astr) then~<10>			mystring = ~<34> ~<34|10>			else	~<10>			mystring = string.char(string.byte(astr,posx))~<10>			end~<10>		end~<10>	end~<10>end~<10|10>local function EventHandle()~<10>local i,obj = 0~<10>for i, obj in ipairs(Application.events) do~<10>	getEvent(obj)~<10>	Application.events[i] = nil~<10>	end~<10>end~<10|10>local function Load(path)~<10>if fs.exists(path) then~<10>	~<10>	local file = fs.open(path,~<34>r~<34>)~<10>	local sLine = file.readLine()~<10>	local n = 4~<10>	Application.window.l:clear()~<10>	while sLine do~<10>		Application.window:writePos(1,n,sLine)~<10>		sLine = file.readLine()~<10>		n = n + 1~<10>		end~<10>	file.close()~<10>	~<10>	end~<10>end~<10|10>Load(Arg[1])~<10|10>while true do~<10>	Application.window:writePos(1,1,~<34>SAVE~<34>)~<10>	Application.window:writePos(1,2,~<34>Color ~<34> .. astr)~<10>	Application.window:writePos(1,3,~<34>......................................................................................~<34>)~<10>	EventHandle()~<10>	sleep(0.05)~<10>	end>>file<0||name<0|simple>path<0|user/programs/simple>data<0|--mMultiOS~<10>--~<60|126|60>t~<60>true~<62|62>marcelOS~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>1~<124>0.1~<62>changePrint~<60>2~<124>true~<62>IdleCount~<60>1~<124>3~<62>EventManager~<60>3~<124>true~<62|62>code~<60>0~<124|126>i~<60>36~<62>print(~<34>Hello, i run under marcelOS~<34>)~<62|62>other~<60>info~<60>0~<124|124>name~<60>0~<124>accManage~<62>version~<60>2~<124>0.1~<62|62>code~<60>0~<124|126|60>il~<60>23~<62|62>print(~<34>Unknown OS ...~<34>)~<62|62|62|10>Application.useevents = true~<10>Application.window = windows.CreateWindow( Application.name , Application , true)~<10>Application.window:SetSize(18,14)~<10>Application.window.left = 10~<10>Application.window.top = 5~<10|10>local Edit1 = winobj.TEdit(~<34>Edit1~<34>,Application.window,Application.window)~<10>Edit1.width = 12~<10>Edit1.top = 2~<10>Edit1.left = 2~<10>Edit1.text:SetText(~<34>Default :D~<34>)~<10|10>function getEvent(_event)~<10>Application.window:print(_event.name)~<10>end~<10|10>while true do~<10>    Application.window.l:clear()~<10>	Application.window:Paint()~<10>	Application.window.l.CursorX = 1~<10>	Application.window.l.CursorY = 5~<10>	EventHandle()~<10>	sleep(1)~<10>	end>>>>>>>>>"  --[[ 
APIS needed for Decompressing !!!
- classapi
- path
- ehtfutils
- ehtf
]]

--[[
classapi
]]

--[[
THANKS to Ian
http://www.rtsoft.com/forums/showthread.php?1466-A-cleaner-easier-class-idiom-in-Lua
]]

function class(superclass, name)
    local cls = superclass and superclass() or {}
    cls.__name = name or ""
    cls.__super = superclass
	cls.__index = cls
    return setmetatable(cls, 
	  {
	  __call = function (c, ...)
      local instance = setmetatable({__class = cls}, cls)
      if cls.__init then
         cls.__init(instance, ...)
         end
      return instance
      end
	  }
	)
end

--[[

function class()
    local cls = {}
    cls.__index = cls
    return setmetatable(cls, 
	  {
	  __call = function (c, ...)
      local instance = setmetatable({}, cls)
      if cls.__init then
         cls.__init(instance, ...)
         end
      return instance
      end
	  }
	)
end
]]

function issubclass(class1, class2)
if (type(class1) ~= "table") or (type(class2) ~= "table") then
	return false
	end
while true do
    if class1 == class2 then
        return true
        end
    class2 = class2.__super
    if not class2 then
        break
		end
    end
return false
end

function isinstance(inst, cls)
return (type(inst) == "table") and issubclass(inst.__class, cls)
end



--[[
path
]]

local osPath = "marcelOS"
local apisPath = "apis"
local dataPath = "data"
local autorunPath = "autorun"
local tempPath = "temp"
local userPath = "user"
local userautostartPath = "autostart"
local driverPath = "drivers"
local programsPath = "programs"

function FOLDER(apath)
apath = tostring(apath)
if string.char(string.byte(apath,apath:len())) ~= '/' then
	return apath.."/"
	else
	return apath
	end
end

function ROOT(apath)
apath = tostring(apath)
if string.char(string.byte(apath)) ~= '/' then
	return "/"..apath
	else
	return apath
	end
end

function RPath(astr,bstr)
if astr == "/" then
	return ROOT(bstr)
	else
	return ROOT(fs.combine(astr,bstr))
	end
end

function OS()
return ROOT(osPath)
end

function APIS()
return ROOT(fs.combine(osPath,apisPath))
end

function DATA()
return ROOT(fs.combine(osPath,dataPath))
end

function AUTORUN()
return ROOT(fs.combine(osPath,autorunPath))
end

function USER()
return ROOT(userPath)
end

function DRIVERS()
return ROOT(fs.combine(osPath,driverPath))
end

function TEMP()
return ROOT(fs.combine(osPath,tempPath))
end

function PROGRAMS()
return ROOT(fs.combine(osPath,programsPath))
end

function USERAUTOSTART()
return ROOT(fs.combine(userPath,userautostartPath))
end


--[[
ehtfutils
]]

TEHTFStatus = {"EHTFdone","EHTFdonePart","EHTFerror","EHTFexit","EHTFincorrectString","EHTFnone"}

TVarDec = class(nil,"TVarDec")

function TVarDec:__init()
	self._Begin = "<"
	self._End = ">"
	self._Array = "|"
	self._System = "~"
	end

ToStrPar = {"tsWriteMetaInfo","tsWriteTypecast","tsUseTypecast","tsUseInsert"}
ToStrMode = {["tsWriteMetaInfo"] = true,["tsWriteTypecast"] = true,["tsUseTypecast"] = true,["tsUseInsert"] = true}
stToStrMode =  {["tsWriteMetaInfo"] = false,["tsWriteTypecast"] = true,["tsUseTypecast"] = true,["tsUseInsert"] = true}
stToStrModeAll =  {["tsWriteMetaInfo"] = true,["tsWriteTypecast"] = true,["tsUseTypecast"] = true,["tsUseInsert"] = true}
EHTFversion = "0.9.8"

function stvardec()
return TVarDec()
end

function TVarDec:Assign(vardec)
-- Pflicht da Klasse und kein Record !
self._Begin = vardec._Begin
self._End = vardec._End
self._Array = vardec._Array
self._System = vardec._System
end

function FileToString( apath )
local result = ""
local file = fs.open(apath,"r")
if file then
	result = file.readAll()
	file.close()
	end
return result
end

function StringToFile( apath , astring )
local file = fs.open(apath,"w")
if file then
	file.write(astring)
	file.close()
	end
end

function HTStrtoSVar(astr,typecast)
-- Andere funktion...
local result
if typecast == 0 then
	result = tostring(astr)
	elseif (typecast == 1) or (typecast == 2) then
		result = tonumber(astr)
		elseif typecast == 3 then
			result = toboolean(astr)
			else
			result = astr
			end
return result
end

function GetArt(SVar)
-- NEW FUNCTION
local result = 0
if type(SVar) == "number" then 
	result = 1
	elseif type(SVar) == "string" then
		result = 0
		elseif type(SVar) == "boolean" then
			result = 3
			else
			result = -1
			end
return result
end

function toboolean(avalue)
if type(avalue) == "number" then
	return (avalue == -1)
	elseif type(avalue) == "string" then
		return (string.lower(avalue) == "true")
		elseif type(avalue) == "boolean" then
			return avalue
			else
			return (avalue ~= nil)
			end
end

function HTVardectoStr(newvardec, oldvardec)
local result = oldvardec._System .. oldvardec._Begin.. "v"  .. oldvardec._Begin .. EHTFversion .. oldvardec._End
       .. "_b"   .. oldvardec._Begin .. string.byte(newvardec._Begin)   .. oldvardec._End
       .. "_e"     .. oldvardec._Begin .. string.byte(newvardec._End)     .. oldvardec._End
       .. "_a"   .. oldvardec._Begin .. string.byte(newvardec._Array)   .. oldvardec._End
       .. "_s"  .. oldvardec._Begin .. string.byte(newvardec._System)  .. oldvardec._End
       .. oldvardec._End
return result
end

--[[
EHTF
]]

--[[
Yeah, this is the Epic EHTF Node system in LUA.
Now easy Save Data of every type in a Simple String !
e.g. if you want to send a huge complex ammount of information over rednet...

I RECOMMENT TO TURN tsUseInsert ALWAYS OFF !!! BEACAUSE EITHER ME or LUA is to ****** to find out, that the lenght of a string "hel/lo Wörld" 13 is...

]]

THTNode = class(nil,"THTNode")

function StCutOutFunc(Sender , achar)
local result = ((achar == Sender.vardec._Begin)
		or (achar == Sender.vardec._End) 
		or (achar == Sender.vardec._Array) 
		or (achar == Sender.vardec._System) 
		or (achar == string.char(0)))  
return result
end

function THTNode:__init()
	self.parent = nil
	self.vardec = TVarDec()
	self.nodes = {}
	self.Values = {} -- No Type needed, because lua :) 
	self.about = ""
	self.CutOutfunc = StCutOutFunc
	self.CaseSensitive = false
	end


--[[ 
Missing:


FindAllAbout
FindAllAboutC
FindAllVar
ValidAbout
GetCount
GetItem
SetItem


Die FundAbout(about , p ) funktionen.... kein Out Parameter !
]]

--[[##################]]
--[[       THTNode    ]]
--[[##################]]   

function THTNode:Assign( from )
local i = 0
self.vardec = from.vardec
self.CutOutfunc = from.CutOutfunc
self.CaseSensitive = from.CaseSensitive
self.about = from.about
self.parent = from.parent

self.Values = {}
for i = 1,#from.Values do
	self.Values[i] = from.Values[i]
	end
	
self.nodes = {}
for i = 1,#from.nodes do
	self.nodes[i] = THTNode()
	self.nodes[i]:Assign(from.nodes[i])
	self.nodes[i].parent = self
	end
end


--[[##################]]
--[[  Add functtions  ]]
--[[##################]]   

function THTNode:AddChild()
local result = THTNode()
self.nodes[#self.nodes+1] = result
result.parent = self
result.vardec = self.vardec
result.CutOutfunc = self.CutOutfunc
result.CaseSensitive = self.CaseSensitive
return result
end

function THTNode:AddChildPos( pos )
local result = THTNode()
self:Insert(pos,result)
result.parent = self
result.vardec = self.vardec
result.CutOutfunc = self.CutOutfunc
result.CaseSensitive = self.CaseSensitive
return result
end

function THTNode:Add(aabout , SVar)
local result = nil
local i = 0
if type(aabout) == "table" then
	if isinstance(aabout,THTNode) then
		result = #self.nodes+1
		self.nodes[result] = aabout
		aabout.parent = self
		return result
		end
	end
result = self:AddChild()
result.about = aabout
if type(SVar) == "table" then
	for i = 1,#SVar do
		result:AddValue(SVar[i])
		end
	else
	result:AddValue( SVar )
	end
return result
end

function THTNode:ParentAddBehind()
local result = nil
if self.parent ~= nil then
	local  i = self.parent:FindNode(self)
	if i > 0 then 
		result = self.parent:AddChildPos(i+1)
		end
	end
return result
end

function THTNode:ParentAddBefore()
local result = nil
if self.parent ~= nil then
	local  i = self.parent:FindNode(self)
	if i > 0 then 
		result = self.parent:AddChildPos(i-1)
		end
	end
return result
end

--[[#####################]]
--[[  useful functtions  ]]
--[[#####################]]   

function THTNode:AddValue( SVar )
local result = #self.Values+1
self.Values[result] = SVar
return result
end


function THTNode:UnGroup( aindex )
local i = 0
local result = nil
if type(aindex) ~= "number" then
	result = aindex
	aindex = self:FindNode(aindex)	
	else
	result = self.nodes[aindex]
	end
if (aindex < 1) or (aindex > #self.nodes) then 
	return nil
	end
self.nodes[aindex] = nil
for i = aindex,#self.nodes-1 do
	self.nodes[i] = self.nodes [i+1]
	end
result.parent = nil
return result
end


function THTNode:Delet( aindex )
local i = 0
if type(aindex) ~= "number" then
	aindex = self:FindNode(aindex)	
	end
if (aindex < 1) or (aindex > #self.nodes) then 
	return
	end
self.nodes[aindex] = nil
for i = aindex,#self.nodes-1 do
	self.nodes[i] = self.nodes [i+1]
	end
end

function THTNode:Reduceto( aindex)
if type(aindex) == "number" then 
	self:INTRedureToNumber(aindex)
	else
	self:INTRedureToNode(aindex)
	end
end

-- INTERNAL
function THTNode:INTReducetoNumber( aindex )
local i = 0
for i = #self.nodes,aindex+1,-1 do
	self.nodes[i] = nil
	end
end

function THTNode:INTReducetoNode( anode )
local i = 0
for i = #self.nodes,1,-1 do
	if self.nodes[i] == anode then
		return
		else
		self.nodes[i] = nil
		end
	end
end
-- Public

function THTNode:Insert( aindex, anode)
local i = 0
if aindex > #self.nodes+1 then 
	return
	end
for i = #self.nodes+1,aindex+1,-1 do
	self.nodes[i] = self.nodes[i-1]
	end
self.nodes[aindex] = anode
anode.parent = self
end

function THTNode:Node(x)
local i = 0
local result = self
for i = 1,#x do
	if type(x[i]) == "number" then
		if (x[i] > 0) and (x[i] <= #self.nodes) then
			result = result.nodes[x[i]]
			else
			result = nil
			end
		else
		result = (result.FindAbout(x[i]))
		end
	if result == nil then
		return result
		end
	end
return result
end

--[[###################]]
--[[  Find functtions  ]]
--[[###################]]


function THTNode:FindNode( anode )
local i = 0
local result = -1
for i = 1,#self.nodes do
	if self.nodes[i] == anode then
		result = i
		return result
		end
	end
return result
end

function THTNode:FindAbout( astring )
local i = 0
local result = nil
astring = self:CaseFunc(astring)
for i = 1,#self.nodes do
	if self:CaseFunc(self.nodes[i].about) == astring then
		result = self.nodes[i]
		return result
		end
	result = self.nodes[i]:FindAbout(astring)
	if result then
		return result
		end
	end
return result
end

function THTNode:FindAboutCi( astring )
local i = 1
local result = -1
astring = self:CaseFunc(astring)
for i = 1,#self.nodes do
	if self:CaseFunc(self.nodes[i].about) == astring then
		result = i
		return result
		end
	end
return result
end

function THTNode:FindAboutC( astring )
local i = self:FindAboutCi( astring )
local result = nil
if i > 0 then
	result = self.nodes[i]
	return result
	end
return result
end

function THTNode:FindAboutN( astring )
local i = 0
local result = nil
astring = self:CaseFunc(astring)
for i = #self.nodes,1,-1 do
	if self:CaseFunc(self.nodes[i].about) == astring then
		result = self.nodes[i]
		return result
		end
	result = self.nodes[i]:FindAboutN(astring)
	if result then
		return result
		end
	end
return result
end

function THTNode:FindAboutNC( astring )
local i = self:FindAboutNCi( astring )
local result = nil
if i > 0 then
	result = self.nodes[i]
	end
return result
end

function THTNode:FindAboutNCi( astring )
local i = 1
local result = -1
astring = self:CaseFunc(astring)
for i = #self.nodes,1,-1 do
	if self:CaseFunc(self.nodes[i].about) == astring then
		result = i
		return result 
		end
	end
return result 
end

function THTNode:FindVar( SVar )
local i = 1
local i2 = 1
local result = nil
for i = 1,#self.nodes do
	for i2 = 1,#self.Values do
		if self.Values == SVar then
			result = self.nodes[i]
			return result 
			end
		end
	result = self.nodes[i]:FindVar( SVar )
	if result then 
		return result
		end
	end
return result
end

function THTNode:SetSValues_Check( acardinal ,writemode )   
local i = 0
local result = acardinal > 0
if (acardinal > #self.Values) and (readmode) then
	i = #self.Values+1
	for i = i,acardinal-1 do
		print(i)
		self.Values[i] = ""
		end
	end
return result
end
	
function THTNode:SValues( acardinal , aValue )
local result = (aValue or nil)
local writemode = aValue ~= nil
if self:SetSValues_Check(acardinal, writemode) then 
	if writemode then 
		self.Values[acardinal] = result
		else
		result = self.Values[acardinal]
		end
	else
	result = ""
	end
return result
end

function THTNode:SValuesS( acardinal , aValue )
local result = tostring(aValue or "")
local writemode = (aValue ~= nil)
if self:SetSValues_Check(acardinal, writemode) then 
	if writemode then 
		self.Values[acardinal] = result
		else
		result = tostring(self.Values[acardinal]) or ""
		end
	else
	result = ""
	end
return result
end

function THTNode:SValuesI( acardinal , aValue )
local result = tonumber(aValue or 0)
local writemode = aValue ~= nil
if self:SetSValues_Check(acardinal, writemode) then 
	if writemode then 
		self.Values[acardinal] = result
		else
		result = tonumber(self.Values[acardinal]) or 0
		end
	else
	result = 0
	end
return result
end

function THTNode:SValuesB( acardinal , aValue )
local result = toboolean(aValue or 0)
local writemode = aValue ~= nil
if self:SetSValues_Check(acardinal, writemode) then 
	if writemode then 
		self.Values[acardinal] = result
		else
		result = toboolean(self.Values[acardinal] or 0)
		end
	else
	result = false
	end
return result
end
	
function THTNode:CaseFunc( astr )
local result = ""
if self.CaseSensitive then result = astr
	else result = string.lower(astr) end
return result
end

function THTNode:CutOutChars( astring , IntFunc )
local i = 1
local i2 = 1
local von = 1
local result = ""
local achar = ""
local offen = false

for i = 1,string.len(astring) do
	achar = string.char(string.byte(astring,i))
	if (self.CutOutfunc and self:CutOutfunc(achar)) or ((not self.CutOutfunc) and StCutOutFunc(self,achar)) then -- Irgendwie wird CurOutFunc ned gespeichert... deswegen umgehung :)
		if von < i then
			if offen then 
				result = result .. self.vardec._End
				end
			result = result .. string.sub(astring,von,i-1)
			offen = false
			end
		
		if offen then
			result = result .. self.vardec._Array .. string.byte(achar)
			else
			result = result .. self.vardec._System .. self.vardec._Begin .. string.byte(achar)
			end
			
		offen = true
		von = i +1
		i2 = i2 + 1
		if IntFunc and ((i2 % 10000) == 0) then 
			IntFunc(self)
			end
		end
	end
if offen then 
	result = result .. self.vardec._End
	end
result = result .. string.sub(astring,von)
return result
end

function THTNode:ToStr( mode , IntFunc )
local i = 1
local atext = ""
local result = ""
local lmode = vec3.Copy(mode or stToStrMode)

if IntFunc then 
	IntFunc(self)
	end

if lmode["tsWriteMetaInfo"] then
	result = HTVardectoStr(self.vardec,stvardec())
	end
	
result = result .. self:CutOutChars(self.about , IntFunc  ) .. self.vardec._Begin
if lmode["tsWriteTypecast"] then
	result = result .. self.vardec._System .. "t" .. self.vardec._Begin .. "true" .. self.vardec._End 
	end
if lmode["tsUseTypecast"] and (#self.Values > 0) then
	result = result .. tostring(GetArt(self.Values[1])) .. self.vardec._Array
	end
for i = 1,#self.Values do
	atext = self:SValuesS(i)
	if lmode["tsUseInsert"] and (string.len(atext) > 20) then
		atext = self.vardec._System .. 'i' .. self.vardec._Begin .. tostring(string.len(atext)) .. self.vardec._End .. atext
		else
		atext = self:CutOutChars(atext , IntFunc )
		end
	
	if (i == #self.Values) and (#self.nodes == 0) and (string.len(atext) > 0) then 
		result = result .. atext
		else
		result = result .. atext .. self.vardec._Array
		end
	end
lmode["tsWriteMetaInfo"] = false
lmode["tsWriteTypecast"] = false
for i = 1,#self.nodes do
	result = result .. self.nodes[i]:ToStr(lmode, IntFunc)
	end
result = result .. self.vardec._End	
return result
end

function THTNode:FromStr( astring , vardec ,IntFunc )
local a,b,c = HTStrtoNode(astring, self, vardec ,IntFunc)
self = a
return b,c
end

function THTNode:LoadfromFile( path , vardec )
local b,c = self:FromStr(FileToString(path), vardec)
return b,c
end

function THTNode:SavetoFile( path, mode )
local a = self:ToStr( mode )
StringToFile(path , a)
end


function HTStrtoNode(astring,resultNODE,vardec,IntFunc) -- resultNode - result (TEHTFStatus) - i;
local deep = 0
local sysdeep = 0
local atext = ""
local systext = ""
local charpuffer = ""
local obj = {nil}
local i = 1
local instsys = false
local curtypecast = -1
local typecast = false
local systypecast = false
local syscurtypecast = 0
local sysnode = nil
local newnode = nil
local p,o = nil
local rp = "EHTFnone"
local result = "EHTFerror"
local lastsystemsymbol = -1

function d(b)
if b or (b == nil) then 
	deep = deep + 1
	else
	deep = deep -1
	end
result = (deep > 0)
return result
end

function Insert_Value()
if deep >= 1 then
	if typecast then
		if (#obj[deep].Values == 0) and (curtypecast == -1) then
			curtypecast = tonumber(atext or 0) or 0
			else
			obj[deep]:AddValue(HTStrtoSVar(atext,curtypecast))
			end
		else
		obj[deep]:AddValue(HTStrtoSVar(atext,-1)) -- he should guesses
		end
	atext = ""
	end
end

function InterpretSystemNode(anode)
local result = "EHTFNone"
local i2 = 0
local astrpuffer = string.lower(anode.about)

if (astrpuffer == "") then
	for i2 = 1,#anode.Values do
		atext = atext.. string.char(anode:SValuesI(i2))
		end
	elseif (astrpuffer == "_b") then
		vardec._Begin = string.char(anode:SValuesI(1) or 0)
		elseif (astrpuffer == "_e") then
			vardec._End = string.char(anode:SValuesI(1) or 0)
			elseif (astrpuffer == "_a") then
				vardec._Array = string.char(anode:SValuesI(1) or 0)
				elseif (astrpuffer == "_s") then
					vardec._System = string.char(anode:SValuesI(1) or 0)
					elseif (astrpuffer == "t") then
						typecast = anode:SValuesB(1)
						elseif (astrpuffer == "il") then
							if (anode:SValuesI(1)+anode:SValuesI(2)-1) > string.len(astring) then
								result = "EHTFincorrectString"
								return result
								end
							atext = atext .. string.sub(astring,anode:SValuesI(1),anode:SValuesI(1)+anode:SValuesI(2))
							elseif (astrpuffer == "i") then
								if (i+anode:SValuesI(1)) > string.len(astring) then
									result = "EHTFincorrectString"
									return result
									end
								atext = atext .. string.sub(astring,i+1,i+anode:SValuesI(1))
								i = i + anode:SValuesI(1)
								elseif (astrpuffer == "g") then 
									i = anode:SValuesI(1)
									elseif (astrpuffer == "e") then 
										result = "EHTFexit"
										return result
										end	


for i2 = 1,#anode.nodes do
	InterpretSystemNode(anode.nodes[i2])					
	end
return result
end

if vardec == nil then
	vardec = stvardec()
	end

while i <= string.len(astring) do
	charpuffer = string.char(string.byte(astring,i))
	if charpuffer == vardec._Begin then --[[ BEGIN ]]  
		if not d() then
			result = "EHTFincorrectString"
			return resultNODE , result , i
			end
		newnode = THTNode()
		newnode.vardec = vardec
		obj[deep] = newnode
		if string.len(atext) > 0 then 
			newnode.about = atext
			end
	
		if (lastsystemsymbol > 0) then
			instsys = true --[[ SYSTEM ]]
			end
		
		if instsys and (sysnode == nil) then
			--newnode.about = vardec._System
			newnode.about = string.sub(astring,lastsystemsymbol+1,i-1)
			systypecast = typecast
			syscurtypecast = curtypecast
			typecast = false
			sysnode = newnode
			sysdeep = deep
			--systext = string.sub(atext,1,#atext-1)
			systext = string.sub(atext,1,#atext-(i-lastsystemsymbol)+1)
			else
			if deep > 1 then
				obj[deep-1]:Add(newnode)
				else
				if resultNODE then
					resultNODE:Assign(obj[1]) -- neuer node
					obj[1] = nil
					obj[1] = resultNODE
					else
					resultNODE = obj[1]
					end
				end
			end
		
		curtypecast = -1
		atext = ""
		else
		if charpuffer == vardec._End then --[ END ]]
			if string.len(atext) > 0 then 
				Insert_Value()
				end
			if (not d(false)) and (i ~= string.len(astring)) then
				result = "EHTFdonePart" -- Der node ist offiziel vorbei, hier komtm aber noch was dahinter. evt nen zweiter , andere Node !
				return resultNODE , result , i
				end
			curtypecast = -1
			if IntFunc then
				rp = IntFunc(obj[deep],instsys)
				if rp ~= EHTFnone then
					return rp
					end
				end
			if instsys and (deep < sysdeep) then
				sysdeep = 0
				instsys = false
				atext = atext .. systext -- systext ist das was vot dem systemaufruf da stand
				typecast = systypecast
				curtypecast = syscurtypecast
				rp = InterpretSystemNode(sysnode)
				if rp ~= "EHTFNone" then
					result = rp
					return resultNODE , result , i
					end
				sysnode = nil
				lastsystemsymbol = -1
				end
			else
			if charpuffer == vardec._Array then 
				Insert_Value() --[[ Array ]]
				else
				if charpuffer == vardec._System then
					lastsystemsymbol = i 
					else
					atext = atext .. charpuffer --[[ Normal ]]
					end
				end
			end
		end
	i = i + 1
	end
if deep < 1 then 
	result = "EHTFdone"
	else
	result = "EHTFincorrectString" --  Hier fehlt was. Der String bricht ab bevor alles geschlossen werden kann !
	end
	
return resultNODE , result , i
end



--[[
OWN STUFF !!!!

Auto Eddet
local dest = "/"
local myData = ""
]]

local lastsleep = os.time()

local function aSleepFunc()
if lastsleep + 1 < os.clock() then
		lastsleep = os.clock()
		sleep(0.01)
		end
end

write("read data")
local Data = THTNode()
Data:FromStr(myData,stvardec(),aSleepFunc)
print(" ... done")

local function LoadData(adata,apath)
local i,obj = 1,nil
local p,o,p2,p3 = nil,nil,nil
local ap,bp = ""
local aname = ""
local afile = ""
local filedata = ""
p = adata:FindAboutC("name")
if p then 
	aname = p:SValuesS(1)
	ap = RPath(apath,aname)
	if not fs.exists(ap) then
		print(ap)
		fs.makeDir(ap)
		end
	end
o = adata:FindAboutC("sub")
for i,obj in ipairs(o.nodes) do
	if obj.about == "folder" then
		sleep(0.001)
		LoadData(obj,ap)
		else
		p2 = obj:FindAboutC("name")
		if p2 then
			afile = p2:SValuesS(1)
			bp = RPath(ap,afile)
			p3 = obj:FindAboutC("data")
			if p3 then
				filedata = p3:SValuesS(1)
				sleep(0.001)
				StringToFile(bp,filedata)
				end
			end
		end
	end
end

--Data:LoadfromFile("/Hello.ehtf")

write("extract data")
LoadData(Data:FindAboutC("folder"),dest)
print(" ... done")

  local function SelectColor(acolor)
if term.isColor and term.isColor() then
	term.setTextColor(acolor or colors.white)
	end
end

term.clear()
term.setCursorPos(1,1)
SelectColor(colors.green)
print("Your installation is complete") 
SelectColor(colors.white)
print("PC will reboot now") 
if fs.exists("/marcelOS.install") then
	fs.delete("/marcelOS.install")
	end
sleep(1.5)
os.reboot()